### **第9章 信道编码：对抗错误的智慧 🛡️ (复习重点版)**

信道编码的核心任务是在原始信息中**增加冗余**，从而在接收端有能力**发现并纠正**在传输过程中由噪声等引起的错误。

#### **1. 核心概念：码重、码距与纠错能力**

这三个概念是衡量一个码本“好坏”的基础。

*   **汉明重量 (码重) $w(\mathbf{c})$**
    *   **定义**: 一个码字 $\mathbf{c}$ 中 "1" 的个数。
    *   **例子**: 码字 $\mathbf{c} = (1, 0, 1, 1, 0)$ 的码重是 $w(\mathbf{c}) = 3$。

*   **汉明距离 (码距) $d(\mathbf{c}_1, \mathbf{c}_2)$**
    *   **定义**: 两个等长码字 $\mathbf{c}_1$ 和 $\mathbf{c}_2$ 对应位上不相同的比特数。
    *   **例子**: $\mathbf{c}_1 = (1,0,1,1,0)$, $\mathbf{c}_2 = (1,1,1,0,0)$，它们在第2和第4位不同，所以 $d(\mathbf{c}_1, \mathbf{c}_2) = 2$。

*   **最小码距 $d_{min}$**
    *   **定义**: 一个码本中，**任意两个不同码字之间**汉明距离的最小值。这是**最重要**的参数！
    *   **纠错能力**: 一个码本能纠正 $t$ 个错误，必须满足：
        $$ \boxed{ d_{min} \ge 2t + 1 } $$
    *   **检错能力**: 一个码本能检测 $d$ 个错误，必须满足：
        $$ d_{min} \ge d + 1 $$

**一句话总结**: $d_{min}$ 越大，码字在“空间”中分布得越“稀疏”，容忍错误的能力就越强。

---

#### **2. 线性分组码：优雅的代数结构**

线性分组码用矩阵运算实现了编码，结构清晰，易于分析。

*   **生成矩阵 G**
    *   **作用**: 用于**编码**。将 $k$ 维信息向量 $\mathbf{u}$ 映射为 $n$ 维码字向量 $\mathbf{c}$。
    *   **公式**: $\mathbf{c} = \mathbf{u} \mathbf{G}$
    *   $\mathbf{G}$ 是一个 $k \times n$ 的矩阵，其各行线性无关。

*   **校验矩阵 H**
    *   **作用**: 用于**校验和译码**。所有合法的码字都与它“正交”。
    *   **公式**: $\mathbf{c} \mathbf{H}^T = \mathbf{0}$
    *   $\mathbf{H}$ 是一个 $(n-k) \times n$ 的矩阵。

*   **G 和 H 的关系**: 它们是“正交”的，满足 $\mathbf{G} \mathbf{H}^T = \mathbf{0}$。知道一个就能求出另一个。

*   **系统码**: 一种特殊的线性分组码，编码后信息位保持原样，后面附加上校验位。
    *   **码字结构**: $\mathbf{c} = (\mathbf{u} | \mathbf{p}) = (u_1, ..., u_k | p_1, ..., p_{n-k})$
    *   **系统码的 G 和 H**: 它们具有标准形式。如果 $\mathbf{G} = (\mathbf{I}_k | \mathbf{Q})$，那么 $\mathbf{H} = (-\mathbf{Q}^T | \mathbf{I}_{n-k}) = (\mathbf{Q}^T | \mathbf{I}_{n-k})$（在GF(2)中，正负号相同）。
        *   $\mathbf{I}_k$: $k \times k$ 的单位矩阵
        *   $\mathbf{Q}$: $k \times (n-k)$ 的矩阵

*   **伴随式 (Syndrome) S**
    *   **作用**: **错误检测的核心**。
    *   **计算**: 接收端收到向量 $\mathbf{y}$（可能包含错误 $\mathbf{e}$，即 $\mathbf{y} = \mathbf{c} + \mathbf{e}$），计算伴随式 $\mathbf{S} = \mathbf{y} \mathbf{H}^T$。
    *   **判断**:
        *   $\mathbf{S} = \mathbf{0} \implies$ 无错误（或发生了H检测不出的错误）。
        *   $\mathbf{S} \neq \mathbf{0} \implies$ **一定有错误**！
    *   **核心原理**: $\mathbf{S} = (\mathbf{c} + \mathbf{e})\mathbf{H}^T = \mathbf{c}\mathbf{H}^T + \mathbf{e}\mathbf{H}^T = \mathbf{0} + \mathbf{e}\mathbf{H}^T = \mathbf{e}\mathbf{H}^T$。伴随式**只与错误图样 $\mathbf{e}$ 有关**，与原始码字 $\mathbf{c}$ 无关。通过计算出的 $\mathbf{S}$，就可以查表或通过逻辑推断出最有可能的错误位置 $\mathbf{e}$，然后用 $\mathbf{y} + \mathbf{e}$ 即可纠正错误。

*   **汉明码**: 一类非常经典的、可以纠正**单个**比特错误的**完备码**。
    *   **参数**: 码长 $n = 2^m - 1$，信息位 $k = 2^m - m - 1$，校验位 $m$。
    *   **最小码距**: $d_{min} = 3$，根据公式 $3 \ge 2t+1$，所以 $t=1$，正好能纠1位错。
    *   **(7,4) 汉明码** 是最典型的例子 ($m=3$)，有4位信息和3位校验。

---

#### **3. 循环码：移位不变的特性**

循环码是线性分组码的一个子类，它有更强的代数结构，使得编码和译码可以用更高效的**移位寄存器**电路实现。

*   **核心特性**: 任何一个码字的**循环移位**仍然是该码集中的一个合法码字。

*   **生成多项式 g(x)**
    *   **地位**: 循环码的“灵魂”，完全定义了一个循环码。
    *   **性质**:
        1.  它是一个 $(n,k)$ 循环码中唯一的、次数为 $r = n-k$ 的多项式。
        2.  它必须是 $x^n+1$ 的一个因子。
        3.  所有码字多项式 $c(x)$ 都是 $g(x)$ 的倍式。

*   **系统码编码**:
    1.  将 $k$ 位信息多项式 $u(x)$ **左移** $n-k$ 位，得到 $u(x)x^{n-k}$。
    2.  用 $u(x)x^{n-k}$ **除以**生成多项式 $g(x)$，得到**余式** $p(x)$。
    3.  最终的码字多项式是 $c(x) = u(x)x^{n-k} + p(x)$。
    *   这样构造的 $c(x)$ 一定能被 $g(x)$ 整除，并且前 $k$ 个系数对应信息位，后 $n-k$ 个系数对应校验位。

*   **循环码的 G 和 H**:
    *   **生成矩阵 G** 的各行可以由 $g(x)$, $x g(x)$, $x^2 g(x)$, ..., $x^{k-1} g(x)$ 的系数构成。
    *   **校验矩阵 H** 可以由一个叫做**校验多项式** $h(x) = (x^n+1)/g(x)$ 来构造。

---

#### **4. 卷积码：带记忆的编码**

与分组码“一块一块”处理数据不同，卷积码对连续的信息比特流进行编码，其编码器有**记忆性**。

*   **编码器框图**: 通常由 $K-1$ 个移位寄存器（记忆单元）和 $n$ 个模2加法器组成。
    *   **(n, k, K)**: 表示编码率 $k/n$，约束长度为 $K$。我们重点复习 **(n, 1, K)** 的情况。
    *   **约束长度 K**: 指当前输出比特所关联的输入比特的跨度。它等于寄存器个数+1。

*   **生成多项式**: 对于 (n, 1, K) 码，有 $n$ 个生成多项式 $g^{(1)}(x), g^{(2)}(x), ..., g^{(n)}(x)$，它们的次数都不超过 $K-1$。每个生成多项式定义了如何从输入比特流及其移位版本生成一路输出。
    *   **例子 (2,1,3) 码**: 可能有 $g^{(1)}(x) = 1+x+x^2$ (二进制表示为111) 和 $g^{(2)}(x) = 1+x^2$ (二进制表示为101)。

*   **状态与状态转移图**:
    *   **状态**: 编码器在任一时刻的状态由其**移位寄存器中的内容**决定。对于 (n, 1, K) 码，有 $2^{K-1}$ 个状态。
    *   **状态转移图**: 一个有向图。
        *   **节点**: 代表编码器的各个状态。
        *   **有向边**: 代表一次状态转移。
        *   **边上的标注**: 格式为 **`输入/输出`**。例如，`0/11` 表示当输入为0时，编码器输出11，并转移到下一个状态。

*   **格图 (Trellis)**:
    *   **定义**: 将状态转移图按**时间轴**展开得到的一种图形。
    *   **结构**: 横轴是时间，纵轴是状态。在每个时刻，从每个可能的状态出发，画出因输入0或1而产生的两条分支，指向下一时刻的相应状态。
    *   **作用**: 格图是**维特比译码算法 (Viterbi Algorithm)** 的基础。维特比算法就是在格图上寻找一条与接收序列“最接近”的路径，这条路径就对应着最有可能的发送序列。这是卷积码最核心、最强大的译码方法。

**格图示例 (一个简单的 (2,1,2) 码)**
假设状态是1位寄存器的内容（0或1）。
- 从状态0，输入0，输出00，回到状态0。
- 从状态0，输入1，输出11，进入状态1。
- 从状态1，输入0，输出10，回到状态0。
- 从状态1，输入1，输出01，回到状态1。

其格图展开如下：



希望这份提纲挈领的复习能帮助你巩固这些关键知识点！祝你复习顺利！👍