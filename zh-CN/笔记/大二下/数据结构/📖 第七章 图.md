# 📖 第七章 图

## 7.1 图的基本概念

### 🌍 图的定义

*   **定义**：图 (Graph) G 由顶点集 V (Vertex) 和边集 E (Edge) 组成，记为 $G=(V, E)$。
    *   $\boxed{V}$: 顶点 (数据元素) 的有穷**非空**集合。
    *   $\boxed{E}$: 边的有穷集合。边是顶点之间的关系。
*   **特点** ✨：
    *   图是一种**非线性结构**。
    *   数据元素之间呈**多对多**的关系。
    *   顶点集 V 不能为空，但边集 E 可以为空。
*   **示例图示**：
	![](Pic/Pasted%20image%2020250519191505.png)

### 🗣️ 图的相关术语

1.  **顶点 (Vertex)**：数据元素所构成的结点。
2.  **无向图 (Undirected Graph)**：
    *   边的顶点偶对是**无序**的。
    *   边 $(v_i, v_j)$ 和 $(v_j, v_i)$ 代表同一条边，其中 $i \neq j$。
3.  **有向图 (Directed Graph)**：
    *   边的顶点偶对是**有序**的。
    *   有向边 $<v_i, v_j>$ 也称为**弧 (Arc)**。
        *   $v_i$ 是**弧尾 (Tail)** 或初始点。
        *   $v_j$ 是**弧头 (Head)** 或终端点。
4.  **(无向)完全图 (Complete Undirected Graph)**：
    *   每个顶点与其余所有顶点都有边相连的无向图。
    *   若顶点数为 $n$，则边数 $\boxed{e = n(n-1)/2}$。
5.  **有向完全图 (Complete Directed Graph)**：
    *   每个顶点与其余所有顶点之间都有**两条方向相反**的弧相连的有向图。
    *   若顶点数为 $n$，则弧数 $\boxed{e = n(n-1)}$。
    *   思考：一无向图的顶点个数为n，则该图最多有 $n(n-1)/2$ 条边。
6.  **稀疏图 (Sparse Graph)**：有很少边或弧的图 (通常 $e \ll n^2$)。
7.  **稠密图 (Dense Graph)**：有较多边或弧的图 (通常 $e$ 接近 $n^2$)。
8.  **权 (Weight)**：图中的边或弧具有的某种数值意义（如长度、成本、容量）。
9.  **网 (Network)**：边或弧带权的图。
10. **邻接 (Adjacency)**：
    *   **无向图**：若存在边 $(v_i, v_j)$，则称 $v_i$ 和 $v_j$ 互为**邻接点**。
    *   **有向图**：若存在弧 $<v_i, v_j>$，则称 $v_i$ **邻接到** $v_j$，或 $v_j$ **邻接于** $v_i$。
11. **关联 (Incidence) / 依附 (Attach)**：
    *   边或弧与顶点之间的关系。存在边 $(v_i, v_j)$ 或弧 $<v_i, v_j>$，则称该边/弧关联于 $v_i$ 和 $v_j$。
12. **子图 (Subgraph)**：
    *   对于图 $G=(V,E)$ 和 $G'=(V',E')$，如果 $V' \subseteq V$ 且 $E' \subseteq E$，并且 $E'$ 中所有边关联的顶点都在 $V'$ 中，则称 $G'$ 是 $G$ 的子图。
13. **生成子图 (Spanning Subgraph)**：
    *   若子图 $G'$ 包含原图 $G$ 的**全部顶点** (即 $V'=V$)，则称 $G'$ 为 $G$ 的生成子图。

### 🌡️ 顶点的度 (Degree)

*   **顶点的度 $D(v)$** (无向图)：与该顶点相关联的边的数目。
*   **入度 $ID(v)$** (有向图)：以该顶点为弧头的弧数目。
*   **出度 $OD(v)$** (有向图)：以该顶点为弧尾的弧数目。
*   **有向图顶点的度 $D(v)$**：$D(v) = ID(v) + OD(v)$。
*   **性质** ✨：
    *   对于无向图：$\boxed{\sum_{i=1}^{n} D(v_i) = 2e}$ (其中 $n$ 是顶点数，$e$ 是边数)。
    *   对于有向图：$\boxed{\sum_{i=1}^{n} ID(v_i) = \sum_{i=1}^{n} OD(v_i) = e}$。

*   **求解顶点个数方法归纳 (无向图)** 💡：
    *   设图中度为 $i$ 的顶点数为 $n_i$。
    *   ① 对于**无向连通图**，通常 $n_0=0$ (没有孤立顶点)。
    *   ② 若一个 $n$ 顶点 $e$ 条边的无向连通图，所有顶点的度均小于 $m$：
        *   总顶点数：$n = n_0 + n_1 + n_2 + \dots + n_{m-1}$ (如果允许$n_0$)
        *   所有顶点度之和：$\sum n_i \cdot i = 2e$
    *   **示例**：一个无向图共16条边 ($e=16$)，所有顶点度均小于5。度为4的顶点有3个 ($n_4=3$)，度为3的顶点有4个 ($n_3=4$)，其余顶点度均小于3。图中至少包含多少个顶点？
        *   解答：设顶点数最少，则应为无向连通图，所以 $n_0 = 0$。
        *   $n = n_4 + n_3 + n_2 + n_1 = 3 + 4 + n_2 + n_1 = 7 + n_2 + n_1$。
        *   度之和 $= 4 \cdot n_4 + 3 \cdot n_3 + 2 \cdot n_2 + 1 \cdot n_1 = 4 \cdot 3 + 3 \cdot 4 + 2n_2 + n_1 = 12 + 12 + 2n_2 + n_1 = 24 + 2n_2 + n_1$。
        *   已知度之和 $= 2e = 2 \cdot 16 = 32$。
        *   所以 $24 + 2n_2 + n_1 = 32 \Rightarrow 2n_2 + n_1 = 8$。
        *   我们有 $n = 7 + n_2 + n_1$。要使 $n$ 最小，需要 $n_2+n_1$ 最小。
        *   从 $2n_2 + n_1 = 8$，且 $n_1, n_2 \ge 0$。
        *   $n_1 = 8 - 2n_2$。代入 $n = 7 + n_2 + (8 - 2n_2) = 15 - n_2$。
        *   为使 $n$ 最小，需要 $n_2$ 最大。
        *   当 $n_2=0, n_1=8 \Rightarrow n=15$。
        *   当 $n_2=1, n_1=6 \Rightarrow n=14$。
        *   当 $n_2=2, n_1=4 \Rightarrow n=13$。
        *   当 $n_2=3, n_1=2 \Rightarrow n=12$。
        *   当 $n_2=4, n_1=0 \Rightarrow n=11$。
        *   所以，图中至少包含 $\boxed{11}$ 个顶点。

### 👣 路径与回路

1.  **路径 (Path)**：接续的边(或弧)构成的顶点序列 $v_{p_0}, v_{p_1}, \dots, v_{p_k}$，其中 $(v_{p_{i-1}}, v_{p_i})$ (无向) 或 $<v_{p_{i-1}}, v_{p_i}>$ (有向) 是图中的边/弧。
2.  **路径长度 (Path Length)**：路径上边或弧的数目。对于网，可以是权值之和。
3.  **回路 (Cycle) / 环 (Loop)**：第一个顶点和最后一个顶点相同的路径。
4.  **简单路径 (Simple Path)**：所有顶点均不相同的路径。
5.  **简单回路 (Simple Cycle) / 简单环 (Simple Loop)**：除路径起点和终点相同外，其余顶点均不相同的回路。
    *   思考：$n$个顶点的无向完全图中，两个顶点之间简单路径数目为多少？ (OCR Page 6: $1 + A(n-2,1) + A(n-2,2) + \dots + A(n-2,n-2)$，其中 $A(m,k)$ 是 $m$ 取 $k$ 的排列数。这个公式计算的是长度从1到n-1的所有简单路径。)

### 🔗 连通性 (无向图)

1.  **连通图 (Connected Graph)**：无向图中，任何一对顶点之间都存在路径。
2.  **连通分量 (Connected Component)**：无向图中的**极大连通子图**。极大是指包含尽可能多的顶点（和相应的边）。
    *   思考：$n$个顶点组成的连通无向图，其边的个数至少为 $\boxed{n-1}$。
    *   思考：一个有 $n$ 个结点的无向图，最少有 $\boxed{1}$ 个连通分量 (当图连通时)，最多有 $\boxed{n}$ 个连通分量 (当图没有边时)。
    *   若 G 是一个非连通无向图，共有28条边，则该图至少有 $\boxed{9}$ 个顶点。
        *   (设k个连通分量，顶点数 $n_i$，边数 $e_i$。则 $n_i-1 \le e_i \le n_i(n_i-1)/2$。总边数 $E = \sum e_i = 28$。总顶点数 $N = \sum n_i$。$k(k-1)/2 \ge 28 \Rightarrow k(k-1) \ge 56$。$7 \cdot 6 = 42$, $8 \cdot 7 = 56$。所以一个完全图至少需要8个顶点才能有28条边。如果是非连通图，则至少需要两个连通分量，例如一个 $K_8$ (28边) 和一个孤立点 $K_1$ (0边)，总共 $8+1=9$ 个顶点。)

### 🔗 强连通性 (有向图)

1.  **强连通图 (Strongly Connected Graph)**：有向图中，任何一对顶点 $v_i, v_j$ 之间都存在从 $v_i$ 到 $v_j$ 的路径**且**存在从 $v_j$ 到 $v_i$ 的路径。
2.  **强连通分量 (Strongly Connected Component)**：有向图中的**极大强连通子图**。
    *   思考：要使具有 $n (n>1)$ 个顶点的有向图强连通，至少需要 $\boxed{n}$ 条弧 (构成一个简单环)。
    *   思考：一个有 $n$ 个结点的有向图，最少有 $\boxed{1}$ 个强连通分量 (当图强连通时)，最多有 $\boxed{n}$ 个强连通分量 (当图中没有环，每个顶点自成一个强连通分量)。

### 🌳 生成树与生成森林

1.  **生成树 (Spanning Tree)** (无向图)：
    *   包含图中**全部顶点**的**极小连通子图**。极小是指边数最少。
    *   对于一个有 $n$ 个顶点的连通图，其生成树有 $n$ 个顶点和 $\boxed{n-1}$ 条边。
    *   在生成树中添加任意一条原图中的非树边，必定会形成回路或环。
2.  **有向树 (Directed Tree)**：
    *   一个有向图，其中恰有一个顶点入度为0 (根)，其余所有顶点入度均为1。
3.  **生成森林 (Spanning Forest)**：
    *   **无向图**：若图不连通，则其各个连通分量的生成树共同构成生成森林。
    *   **有向图**：有向图中，包含所有顶点的若干棵有向树构成的子图 (通常指通过DFS/BFS等遍历得到的森林)。

## 7.2 图的存储结构

### 🔢 1. 邻接矩阵 (Adjacency Matrix) - 顺序存储

*   用一个一维数组存储顶点信息 (通常是顶点编号或数据)，用一个二维数组 (矩阵) 存储边或弧的信息。
*   设图 $G=(V,E)$ 有 $n$ 个顶点。邻接矩阵 $A$ 是一个 $n \times n$ 的方阵。

*   **无权值的图的邻接矩阵**：
    *   $A[i,j] = 1$，若 $(v_i, v_j)$ 或 $<v_i, v_j>$ 是图中的边/弧。
    *   $A[i,j] = 0$，若顶点间无边/弧。
    *   $A[i,i] = 0$ 通常表示顶点 $i$ 没有自环边 (除非允许自环)。
    *   **顶点的度**：
        *   无向图：顶点 $v_i$ 的度等于矩阵第 $i$ 行 (或第 $i$ 列) 元素之和。
        *   有向图：顶点 $v_i$ 的出度等于第 $i$ 行元素之和；入度等于第 $i$ 列元素之和。
    *   **对称性**：无向图的邻接矩阵必然是**对称矩阵** ($A[i,j] = A[j,i]$)。可以压缩存储 (只存上三角或下三角)。
    *   思考：$n$个顶点的连通图用邻接矩阵表示时,该矩阵至少有 $\boxed{2(n-1)}$ 个非零元素 (每条边对应2个1)。
    *   思考：$n$个顶点的强连通图用邻接矩阵表示时,该矩阵至少有 $\boxed{n}$ 个非零元素 (每条弧对应1个1)。

*   **带权图的加权邻接矩阵 (网)**：
    *   $A[i,j] = w_{ij}$，若 $(v_i, v_j)$ 或 $<v_i, v_j>$ 是图中的边/弧，权值为 $w_{ij}$。
    *   $A[i,j] = \infty$ (或一个特殊大值)，若顶点间无边/弧。
    *   $A[i,i] = 0$ (或 $\infty$，取决于定义，通常为0表示到自身距离为0)。
    *   无向网的邻接矩阵仍然是对称的。

*   **邻接矩阵存储方式**：
    ```c++
    #define MAXV 100 // 最大顶点数
    typedef char VertexTypeData; // 顶点数据类型示例
    typedef int EdgeType;      // 边/弧的权值类型

    typedef struct {
        int no; // 顶点编号 (可选)
        VertexTypeData data; // 顶点值
    } VertexType;

    typedef struct {
        EdgeType edges[MAXV][MAXV]; // 邻接矩阵数组
        int n, e;                  // 顶点数和边数
        VertexType vexs[MAXV];     // 顶点数组 (存放顶点信息)
    } MGraph;
    ```

*   **优点** 👍：
    *   判断任意两点之间是否有边/弧方便，时间复杂度 $O(1)$。
    *   易于计算顶点的度。
    *   适合表示稠密图。
*   **缺点** 👎：
    *   空间复杂度 $O(n^2)$，对于稀疏图浪费空间。
    *   统计边数需要遍历矩阵， $O(n^2)$。
    *   增删顶点不方便。

### 🔗 2. 邻接表 (Adjacency List) - 顺序存储 + 链式存储

*   对图中每个顶点 $v_i$ 建立一个单链表，称为 $v_i$ 的**边表** (或**出边表**)。链表中的结点称为**边结点**，存储与 $v_i$ 相邻接的顶点的信息 (如邻接点在顶点数组中的下标、权值等)。
*   所有顶点的边表头指针和顶点数据一起构成**顶点表** (通常用数组实现)。

*   **结构**：
    *   **顶点表结点 (VNode)**：
        *   `data`: 顶点信息。
        *   `firstarc`: 指向该顶点第一条出边对应的边结点的指针。
        ```c++
        // 边表结点 (ArcNode)
        typedef struct ArcNode {
            int adjvex;           // 该弧指向的顶点在顶点表中的位置(下标)
            struct ArcNode *nextarc; // 指向下一条出边结点的指针
            // int weight;        // 边的权值 (可选)
        } ArcNode;

        // 顶点表结点 (VNode)
        typedef struct VNode {
            VertexTypeData data; // 顶点信息
            ArcNode *firstarc;   // 指向第一条依附该顶点的弧的指针
        } VNode, AdjList[MAXV]; // AdjList是顶点表类型

        // 图结构 (AGraph)
        typedef struct {
            AdjList adjlist;     // 邻接表 (顶点表)
            int n, e;            // 顶点数和边数
        } AGraph;
        ```

*   **特点**：
    *   **无向图**：每条边 $(v_i, v_j)$ 在邻接表中会对应两个边结点：一个在 $v_i$ 的边表中 (指向 $v_j$)，一个在 $v_j$ 的边表中 (指向 $v_i$)。空间为 $O(n+2e)$。
    *   **有向图**：每条弧 $<v_i, v_j>$ 只在 $v_i$ 的出边表中有一个边结点 (指向 $v_j$)。空间为 $O(n+e)$。
        *   若要方便求入度，可以建立**逆邻接表 (Inverse Adjacency List)**，边表存储指向该顶点的弧。

*   **优点** 👍：
    *   空间效率高，尤其对于稀疏图，空间复杂度为 $O(n+e)$。
    *   方便查找某顶点的所有邻接点。
    *   增删边比较方便。
*   **缺点** 👎：
    *   判断两顶点间是否存在边/弧，最坏需 $O(\text{degree})$ 时间 (遍历其中一个顶点的边表)。
    *   对有向图，求某顶点的入度不方便 (需要遍历整个邻接表)，除非建立逆邻接表。
    *   增删顶点不如下标方式直接。
### 🛠️ 其他存储结构

1.  **十字链表 (Orthogonal List)**：
    *   **适用对象**：有向图。
    *   **结构**：将邻接表和逆邻接表结合起来。
        *   **顶点结点**：`data`, `firstin` (指向第一条入弧), `firstout` (指向第一条出弧)。
        *   **弧结点**：`tailvex` (弧尾下标), `headvex` (弧头下标), `hlink` (指向弧头相同的下一条弧), `tlink` (指向弧尾相同的下一条弧), `info` (权值等)。
    *   **优点**：方便求出度和入度，以及遍历出边和入边。
    *   **缺点**：结构复杂。

2.  **邻接多重表 (Adjacency Multilist)**：
	    *   **适用对象**：无向图 (尤其需要对边进行操作时)。
    *   **结构**：为了解决无向图邻接表中一条边存储两次导致删除/修改边不便的问题。每条边只用一个结点表示。
        *   **顶点结点**：`data`, `firstedge` (指向第一条依附于该顶点的边)。
        *   **边结点**：`mark` (标记是否被访问), `ivex` (边的一个端点下标), `ilink` (指向依附于ivex的下一条边), `jvex` (边的另一个端点下标), `jlink` (指向依附于jvex的下一条边), `info` (权值等)。
    *   **优点**：边结点唯一，方便对边的操作。
    *   **缺点**：结构复杂。

3.  **关联矩阵 (Incidence Matrix)**：
    *   用 $n \times e$ 的矩阵 ( $n$ 个顶点，$e$ 条边)。
    *   $M[i,j] = 1$，如果顶点 $v_i$ 是边 $e_j$ 的一个端点 (无向图)。
    *   $M[i,j] = 1$，如果弧 $e_j$ 从顶点 $v_i$ 发出 (有向图)。
    *   $M[i,j] = -1$，如果弧 $e_j$ 指向顶点 $v_i$ (有向图)。
    *   $M[i,j] = 0$，其他情况。
    *   对于带权图，可以存储权值。
    *   **优点**：能表示平行边。
    *   **缺点**：空间 $O(ne)$，通常不如邻接矩阵或邻接表。

### 📊 存储结构比较

| 特性        | 邻接矩阵 (无向/有向)                               | 邻接表 (无向/有向)                                                                       |
| :-------- | :----------------------------------------- | :-------------------------------------------------------------------------------- |
| **空间复杂度** | 顶点表: $O(n)$ <br> 矩阵: $O(n^2/2)$ / $O(n^2)$ | 顶点表: $O(n)$ <br> 边表: $O(2e)$ / $O(e)$                                             |
|           | 适合稠密图                                      | 适合稀疏图                                                                             |
| **求顶点度**  | 扫描行/列 $O(n)$                               | 无向: $O(\text{degree})$ <br> 有向出度: $O(\text{degree})$ <br> 有向入度: $O(n+e)$ (或用逆邻接表) |
| **判定边存在** | $O(1)$                                     | 最坏 $O(\text{degree})$                                                             |
| **求边总数**  | 检测矩阵 $O(n^2)$                              | 遍历所有边表 $O(n+e)$                                                                   |

## 7.3 图的遍历

**目的**：从图中某一顶点出发，系统地访问图中的所有顶点，且每个顶点只被访问一次。

### 🚶 1. 深度优先搜索 (Depth-First Search, DFS)

*   **思想**：类似于树的先根遍历。从图中某个未访问的顶点 $v$ 出发，首先访问 $v$，然后选择一个与 $v$ 邻接且未被访问的顶点 $w$，再从 $w$ 出发进行深度优先搜索，如此递归下去。当一个顶点的所有邻接点都已被访问或不存在未访问邻接点时，则回溯到其前驱顶点，继续搜索其他分支。
*   **需要辅助数据结构**：
    *   `visited[n]` 数组：标记顶点是否已被访问。
*   **遍历过程 (对连通图，从顶点 s 开始)**：
    1.  选中第一个被访问的顶点 $s$，标记为已访问。
    2.  依次从 $s$ 的未被访问过的邻接顶点出发，进行深度优先遍历。
    3.  (递归结束或回溯)
*   若图不连通，则需要对每个连通分量调用一次DFS。
*   **深度优先的含义**：只要可能就尽量深入，直到所有出边都被搜索为止。一旦某顶点所有出边都被发现，搜索则回溯到其前驱结点。
*   **数据结构**：递归实现时隐式使用系统栈；非递归实现时显式使用用户栈。

*   **DFS算法说明 (更细致)** :
    *   **[染色]**：为跟踪DFS进展，用 `color[]` 数组为顶点染色。
        *   `white`: 未发现 (初始状态)。
        *   `gray`: 已发现但其邻接表/行未扫描完 (进入递归，或在栈中)。
        *   `black`: 已发现且其邻接表/行已扫描完 (递归返回，或已出栈且处理完毕)。
    *   **[打时间戳]**：用 `b[v]` (discovery time) 和 `f[v]` (finishing time) 记录顶点变灰和变黑的时刻。对于任何结点 $v$，$b[v] < f[v]$。
    *   **[前驱顶点]**：用 `p[v]` 记录 $v$ 在DFS树/森林中的父结点。

*   **DFS中的边分类**: (主要针对有向图，无向图只有树边和后向边)
    *   ① **树边 (Tree Edge)**：$v$ 是因探索 $(u,v)$ 或 $<u,v>$ 而首次被发现 ( $u=p[v]$)。构成DFS森林 $G_p$。
    *   ② **后向边 (Back Edge)**：$(u,v)$ 或 $<u,v>$ 连接 $u$ 到其在DFS树 $G_p$ 中的一个**祖先** $v$。 (指向灰色顶点)
    *   ③ **前向边 (Forward Edge)**：$(u,v)$ 或 $<u,v>$ 连接 $u$ 到其在DFS树 $G_p$ 中的一个**后代** $v$ (非树边)。 (指向黑色顶点，且 $b[u] < b[v]$)
    *   ④ **横向边 (Cross Edge)**：其他边。可以是连接同一DFS树中非祖先/后代关系的结点，或连接不同DFS树的结点。(指向黑色顶点，且 $b[v] < b[u]$)
    *   **定理**：对无向图G进行DFS，每条边要么是树边，要么是后向边。

*   **DFS性质 (括号化结构)**：
    *   发现和完成时间形成规整的括号表达式。若 $(u \dots u)$ 和 $(v \dots v)$，则有三种情况：
        1.  完全分离：$(u \dots u) (v \dots v)$ 或 $(v \dots v) (u \dots u)$ ($u,v$ 互非祖先后代)。
        2.  $u$ 是 $v$ 的后代：$(v \dots (u \dots u) \dots v)$ ($b[v] < b[u] < f[u] < f[v]$)。
        3.  $v$ 是 $u$ 的后代：$(u \dots (v \dots v) \dots u)$ ($b[u] < b[v] < f[v] < f[u]$)。
    *   **白色路径定理**：在DFS森林中，$v$ 是 $u$ 的后代，当且仅当在发现 $u$ 的时刻 $b[u]$，存在一条从 $u$ 到 $v$ 的全部由白色顶点构成的路径。

*   **DFS非递归实现 (栈)** ：
    1.  访问顶点 $v$，标记已访问，将 $v$ 入栈。
    2.  当栈不空：
        *   取栈顶顶点 $x$ (不弹出)。
        *   查找 $x$ 的一个未访问邻接点 $w$。
        *   若找到 $w$：访问 $w$，标记已访问，将 $w$ 入栈。
        *   若未找到 $w$ ( $x$ 没有未访问邻接点)：$x$ 出栈。 (对应递归返回)

*   **DFS时间复杂度**：
    *   邻接矩阵：$O(n^2)$ (扫描每行确定邻接点)。
    *   邻接表：$O(n+e)$ (每个顶点入栈一次，每条边被检查一次)。

### 🚶 2. 广度优先搜索 (Breadth-First Search, BFS)

*   **思想**：类似于树的层序遍历。从图中某个未访问的顶点 $s$ 出发，首先访问 $s$，然后依次访问 $s$ 的所有未被访问过的邻接点 $w_1, w_2, \dots, w_m$。之后再按 $w_1, w_2, \dots, w_m$ 的次序，依次访问它们各自的未被访问过的邻接点。
*   **需要辅助数据结构**：
    *   `visited[n]` 数组：标记顶点是否已被访问。
    *   一个**队列 (Queue)**：存放已被访问但其邻接点尚未完全访问的顶点。
*   **遍历过程 (对连通图，从顶点 s 开始)**：
    1.  访问源顶点 $s$，标记为已访问，$s$ 入队列。
    2.  当队列不空：
        *   队头顶点 $u$ 出队列。
        *   依次检查 $u$ 的所有邻接点 $v$：
            *   若 $v$ 未被访问，则访问 $v$，标记为已访问，$v$ 入队列。
*   若图不连通，则需要对每个连通分量调用一次BFS。
*   **广度优先的含义**：BFS始终将已发现的顶点和未发现的顶点之间的边界，沿其广度方向向外扩展。先访问距离源点 $s$ 为 $k$ 的所有顶点，然后才访问距离为 $k+1$ 的顶点。
*   **BFS算法属性 (更细致)**:
    *   **[染色]**：类似DFS，可用 white, gray, black。
        *   white: 未发现。
        *   gray: 已发现，已入队但其邻接点未检查完 (在队列中)。
        *   black: 已发现，已出队且其邻接点已检查完。
    *   **[前驱顶点 $p[v]$]**：记录BFS树中 $v$ 的父结点。
    *   **[距离 $d[v]$]**：记录从源点 $s$ 到顶点 $v$ 的**最短路径长度** (边数，对于无权图)。

*   **BFS性质 (最短路径)**：
    *   对于**无权图**，BFS算法找到的从源点 $s$ 到所有可达顶点 $v$ 的路径是**最短路径** (路径上的边数最少)。即 $d[v] = \delta(s,v)$。
    *   BFS能发现从源点 $s$ 可达的所有顶点。
    *   BFS过程会生成一棵**BFS树** (或森林)，其边 $(p[v], v)$ 称为树边。

*   **BFS时间复杂度**：
    *   邻接矩阵：$O(n^2)$ (查找每个出队顶点的邻接点)。
    *   邻接表：$O(n+e)$ (每个顶点入队出队一次，每条边被检查一次)。

### 💡 图的遍历小结

*   深度优先遍历 (DFS) 算法借助于**栈**结构实现；广度优先遍历 (BFS) 算法借助于**队列**结构实现。
*   图的遍历序列与**起始顶点**、**算法本身**(DFS/BFS)、图的**存储结构**(影响邻接点访问顺序)以及**邻接点访问的具体顺序**有关，因此不唯一。
*   对于非连通图，通过多次调用遍历过程 (从每个尚未访问的连通分量的顶点开始) 可求得各连通分量。
*   BFS可用于求无权图的单源最短路径。
*   DFS可用于检测环、拓扑排序、求强连通分量等。

## 7.4 图的连通性与相关算法

### 🌳 1. 无向图的连通分量和生成树

*   **[连通图的生成树]** (已在7.1中定义)
    *   生成树是图 $G$ 的一个包含 $G$ 所有顶点的极小连通子图 (即树)。
    *   若图 $G$ 有 $n$ 个顶点，其生成树必有 $n-1$ 条边。
    *   可以通过DFS或BFS遍历得到，分别称为**深度优先生成树 (DFS Tree)** 和 **广度优先生成树 (BFS Tree)**。在遍历过程中，记录下导致顶点被首次访问的边 (即 $p[v]$ 与 $v$ 之间的边)，这些边构成生成树。
    *   一般情况，BFS生成树的树高**小于等于**DFS生成树的高度。
    *   一个图的生成树可能不唯一 (取决于遍历起始点和邻接点选择顺序)。
*   **[非连通图的生成森林]**
    *   一个连通分量及其遍历时走过的树边构成一棵生成树。
    *   非连通图的各连通分量的生成树组成**生成森林**。

### 🔗 2. 有向图的强连通分量 (SCC) 的求法

*   **回顾**：强连通图是任意两点间相互可达，强连通分量是极大的强连通子图。
*   **Kosaraju算法 (求SCC的基本思想)** ：
    1.  对有向图 $G=(V,E)$ 进行DFS，计算每个顶点的**完成时间 (finishing times)** $f[v]$ (即DFS递归返回，顶点变黑的时刻)。
    2.  构造 $G$ 的**反向图 (Transpose Graph)** $G^T = (V, E^T)$，其中 $E^T = \{<u,v> : <v,u> \in E\}$ (即将 $G$ 中所有弧反向)。
    3.  对 $G^T$ 进行DFS。在主循环中，按照顶点在步骤1中完成时间 $f[v]$ 的**降序**依次选择未访问的顶点作为DFS的起始点。
    4.  在步骤3的DFS过程中，每从一个新的起始点开始形成的DFS树，其所有顶点构成 $G$ 的一个强连通分量。
*   **Tarjan算法 (另一种常用算法)**：基于DFS，利用栈和low-link值来识别SCC，通常只需要一次DFS。

## 7.5 最小生成树 (MST)

**场景**：在一个带权连通无向图 (网) 中，找出一个生成树，使得该树的所有边的权值之和最小。

### 💰 [概述]

*   由一个连通带权无向图 $G=(V, E)$，对每条边 $(u,v) \in E$ 赋予权值 $w(u,v)$。
*   找到一个无环子集 $T \subseteq E$，能将所有顶点连接起来，且 $T$ 各边的权值之和 $\sum_{(u,v) \in T} w(u,v)$ 最小。
*   由于 $T$ 无环且连通所有顶点， $T$ 必为一棵树，称为**最小生成树 (Minimum Spanning Tree, MST)**。
*   **应用场景**：电子电路设计中连接组件针脚，希望连线总长度最短。
*   MST算法通常基于**贪心策略**。

### ✨ MST性质 (贪心选择 / Cut Property)

*   $\boxed{\text{设 } G=(V, E) \text{ 是一个连通的带权图，权重函数为 } w \text{。设 } U \text{ 是 } V \text{ 的任意真子集。}}$
    $\boxed{\text{若边 } (u,v) \text{ 是连接 } U \text{ 和 } V-U \text{ 的所有边中权值最小的一条边 (轻边/安全边)，}}$
    $\boxed{\text{则一定存在 } G \text{ 的一棵最小生成树包括此边 } (u,v) \text{。}}$
    *   **证明**：反证法。假设MST $T_{mst}$ 不含 $(u,v)$。将 $(u,v)$ 加入 $T_{mst}$ 会形成一个环，该环上必有另一条边 $(u',v')$ 连接 $U$ 和 $V-U$。由于 $(u,v)$ 是轻边，$w(u,v) \le w(u',v')$。用 $(u,v)$ 替换 $(u',v')$ 得到 $T'_{mst}$，则 $w(T'_{mst}) \le w(T_{mst})$。$T'_{mst}$ 仍是生成树，故也是MST。

### 🌲 1. Prim算法

*   **思想**：从一个顶点开始，逐步增长树的规模。维护一个集合 $U$ (已加入MST的顶点) 和 $V-U$ (尚未加入的顶点)。每次选择一条连接 $U$ 和 $V-U$ 的权值最小的边，将其和对应 $V-U$ 中的顶点加入到MST中。
*   **步骤** (从指定顶点 $v_0$ 开始)：
    1.  初始化 $U = \{v_0\}$。维护一个 `closedge` 数组 (或类似结构)，对于 $V-U$ 中的每个顶点 $j$，`closedge[j]` 存储连接 $j$ 到 $U$ 中某顶点的边的最小权值及其在 $U$ 中的端点。
    2.  重复 $n-1$ 次：
        *   ① 从 $V-U$ (即 `closedge` 中对应项权值不为0或无穷的顶点) 中挑选一个顶点 $k$，使得连接 $k$ 到 $U$ 的边权值最小。这条边 $(closedge[k].adjvex, k)$ 即为选中的树边。
        *   将 $k$ 加入 $U$。
        *   ② 对于 $V-U$ 中剩余的每个顶点 $j$，更新 `closedge[j]`：若新加入的 $k$ 使得 $w(k,j)$ 小于 `closedge[j]` 中原来的权值，则用 $(k,j)$ 的信息更新 `closedge[j]`。
*   **数据结构 (Prim算法用)**：
    *   `EdgeInfo closedge[MAXV]`：
        *   `lowcost`: 存储当前顶点到集合U的最短边的权值。
        *   `adjvex`: 存储该最短边在集合U中的那个顶点。
    *   `closedge[k].lowcost = 0` 表示顶点 $k$ 已在 $U$ 集合中。
*   **时间复杂度**：
    *   使用邻接矩阵：$O(n^2)$ (每次找最小边 $O(n)$，更新 $O(n)$，共 $n-1$ 轮)。
    *   使用邻接表和二叉堆 (优先队列)：$O(e \log n)$。
    *   使用邻接表和斐波那契堆：$O(e + n \log n)$。

### 🌲 2. Kruskal算法

*   **思想**：按边的权值从小到大依次考察所有边。如果一条边连接了两个当前尚不连通的顶点集合 (即加入该边不会形成环)，则将该边加入MST。
*   **贪心策略**：在所有能连接森林中两棵不同树的边中选择权重最小的边 $(u,v)$。
*   **步骤**：
    1.  初始化MST $T$ 为空。将图中所有 $n$ 个顶点视为 $n$ 个独立的连通分量 (森林中的 $n$ 棵树)。
    2.  将所有边按权值**从小到大排序**。
    3.  依次检查排序后的每条边 $(u,v)$：
        *   若顶点 $u$ 和 $v$ **不属于**同一个连通分量 (即加入 $(u,v)$ 不会形成环)：
            *   将 $(u,v)$ 加入 $T$。
            *   合并 $u$ 和 $v$ 所在的连通分量。
    4.  当 $T$ 中包含 $n-1$ 条边时结束 (或所有边都检查完毕)。
*   **关键问题**：
    *   ① 如何为所有边排序：可以使用小根堆 $O(e \log e)$ 或其他排序算法。
    *   ② 如何判断两个顶点是否属于同一连通分量 / 如何合并连通分量：使用**并查集 (Union-Find Set)** 数据结构。
*   **时间复杂度**：主要取决于边的排序和并查集操作。
    *   排序：$O(e \log e)$。
    *   $e$ 次边检查，每次最多2次 `find` 和1次 `union`。若并查集采用路径压缩和按秩合并，均摊时间近 $O(1)$。总共 $O(e \alpha(e))$。
    *   总体复杂度：$\boxed{O(e \log e)}$ (或 $O(e \log n)$ 因为 $e < n^2$)。
*   **Kruskal算法的修改 ("破圈法" / Reverse Kruskal)**:
    *   从包含所有边的图开始。
    *   将所有边按权值**从大到小**排序。
    *   依次检查每条边 $e_i$：
        *   若从图中删去 $e_i$ 后，图仍然连通，则删去 $e_i$。
        *   否则，保留 $e_i$。
    *   直到剩下 $n-1$ 条边。算法重点在于如何判定环 (或保持连通性)。

## 7.6 有向无环图 (DAG) 及其应用

### 📈 1. 有向无环图 (Directed Acyclic Graph, DAG)

*   **定义**：一个没有有向环的有向图。
*   **用途**：描述工程项目或系统进行的工具。
    *   **AOV网络 (Activity On Vertex)**：顶点表示活动，有向边表示活动间的优先/依赖关系。
    *   **AOE网络 (Activity On Edge)**：顶点表示事件 (里程碑)，有向边表示活动，边的权值表示活动持续时间。
*   **性质**：若一个DAG以邻接矩阵存储，可以通过适当的顶点编号（拓扑排序的逆序），使其邻接矩阵成为一个**下三角矩阵** (或上三角矩阵，取决于编号规则)。编号规则：让弧尾顶点的编号大于弧头顶点的编号 (对应下三角)。

### 🔢 2. 拓扑排序 (Topological Sort)

*   **问题目标**：对一个有向无环图 $G$ 中的所有顶点排成一个线性序列，使得图中任意一条弧 $<u,v>$，顶点 $u$ 在序列中都出现在顶点 $v$ 之前。
*   **应用**：任务调度、课程安排等。
*   **前提**：只有**有向无环图**才能进行拓扑排序。若图中有环，则无法进行拓扑排序。
*   一个DAG的拓扑序列可能**不唯一**。

*   **算法1 (Kahn算法 - 无前驱顶点优先/基于入度)**：
    1.  计算图中所有顶点的**入度**。
    2.  将所有入度为0的顶点入队 (或入栈)。
    3.  当队列 (或栈) 不空：
        *   从队列 (或栈) 中取出一个顶点 $v$，输出 $v$ (加入拓扑序列)。
        *   对于 $v$ 的每一个邻接点 $w$ (即弧 $<v,w>$):
            *   将 $w$ 的入度减1。
            *   若 $w$ 的入度变为0，则将 $w$ 入队 (或入栈)。
    4.  若输出的顶点数等于图的总顶点数，则拓扑排序成功。否则，图中存在有向环。
    *   时间复杂度：邻接表 $O(n+e)$，邻接矩阵 $O(n^2)$。

*   **算法2 (无后继顶点优先/基于出度 - 得到逆拓扑序列)**：
    1.  计算图中所有顶点的**出度**。
    2.  将所有出度为0的顶点入栈。
    3.  当栈不空：
        *   栈顶顶点 $v$ 出栈，将 $v$ **插入到拓扑序列的最前端**。
        *   对于指向 $v$ 的每一个顶点 $u$ (即弧 $<u,v>$，需要逆邻接表或遍历所有边)：
            *   将 $u$ 的出度减1。
            *   若 $u$ 的出度变为0，则将 $u$ 入栈。
    4.  若输出的顶点数等于图的总顶点数，则成功。否则有环。

*   **算法3 (DFS深度优先遍历法 - 得到逆拓扑序列)**：
    1.  对图进行DFS。
    2.  在DFS递归调用**返回时** (即顶点处理完毕，将要出栈时)，将该顶点输出 (或加入序列的前端)。
    3.  最终得到的序列是原图的一个**逆拓扑序列**。将其反转即为拓扑序列。
    *   **注意**：此方法直接应用不能检测环。如果图有环，DFS仍然会完成，但得到的序列不是有效的拓扑序列。需要额外机制判断环。

### ⏳ 3. 关键路径 (Critical Path Method, CPM) - AOE网络

*   **背景**：在AOE网中，确定整个工程的最短完成时间，并找出影响工程进度的关键活动。
*   **相关概念和术语**：
    *   **源点 (Source)**：入度为0的顶点，工程的开始点。
    *   **汇点 (Sink)**：出度为0的顶点，工程的完成点。
    *   **关键路径 (Critical Path)**：从源点到汇点的**最长路径**。路径长度是路径上所有活动的持续时间之和。
    *   $\boxed{\text{关键路径长度 = 工程的最短完成时间}}$。
    *   **关键活动 (Critical Activity)**：关键路径上的活动。关键活动的延迟会导致整个工程的延迟。
*   **涉及变量** (活动 $a_i$ 为弧 $<v_j, v_k>$，持续时间 $dut(<j,k>)$)：
    *   **事件 $v_j$ 的最早发生时间 $ve(j)$**：从源点到 $v_j$ 的最长路径长度。
        *   $ve(\text{源点}) = 0$
        *   $\boxed{ve(j) = \max \{ ve(i) + dut(<i,j>) \}}$ (其中 $i$ 是 $j$ 的所有直接前驱事件)
        *   计算方法：按拓扑排序顺序计算。
    *   **事件 $v_j$ 的最迟发生时间 $vl(j)$**：在不推迟整个工程完成时间的前提下，$v_j$ 允许的最晚发生时间。
        *   $vl(\text{汇点}) = ve(\text{汇点})$ (即工程最短完成时间)
        *   $\boxed{vl(j) = \min \{ vl(k) - dut(<j,k>) \}}$ (其中 $k$ 是 $j$ 的所有直接后继事件)
        *   计算方法：按逆拓扑排序顺序计算。
    *   **活动 $a_i$ (弧 $<v_j, v_k>$) 的最早开始时间 $e(i)$**：
        *   $\boxed{e(i) = ve(j)}$
    *   **活动 $a_i$ (弧 $<v_j, v_k>$) 的最迟开始时间 $l(i)$**：
        *   $\boxed{l(i) = vl(k) - dut(<j,k>)}$
    *   **活动 $a_i$ 的时间余量 (Slack/Float)**：$l(i) - e(i)$。
    *   **关键活动**：时间余量为0的活动，即 $\boxed{e(i) = l(i)}$。
        *   同时，关键活动所连接的事件也满足 $ve(j) = vl(j)$ 且 $ve(k) = vl(k)$，且 $ve(k) - ve(j) = dut(<j,k>)$。
*   **求解关键路径算法步骤**：
    1.  输入所有弧的信息，建立AOE网的存储结构。
    2.  求拓扑排序序列，并在此过程中计算所有事件的**最早发生时间 $ve()$**。(同时将拓扑序列顶点入栈s)
    3.  初始化所有事件的**最迟发生时间 $vl()$** 为 $ve(\text{汇点})$。按栈s的从栈顶到栈底的顺序 (逆拓扑序) 计算各顶点的 $vl()$ 值。
    4.  根据 $ve()$ 和 $vl()$ 计算每个活动的 $e(i)$ 和 $l(i)$ 值，找出 $e(i)=l(i)$ 的关键活动，从而确定关键路径。

## 7.7 最短路径

**问题**：在带权图 (通常是有向图，权可正可负) 中，找出从一个源点到其他所有顶点 (或特定顶点，或所有顶点对之间) 的路径，使得路径上边的权值之和最小。

### 📌 [定义与性质]

*   给定带权有向图 $G=(V,E)$ 和权重函数 $w: E \to \mathbb{R}$。
*   路径 $p=<v_0, v_1, \dots, v_k>$ 的权重 $w(p) = \sum_{i=1}^{k} w(v_{i-1}, v_i)$。
*   顶点 $u$ 到 $v$ 的**最短路径权重 $\delta(u,v)$**：
    *   $\delta(u,v) = \min \{w(p) : u \leadsto v \text{ 的路径 } p \}$，若存在路径。
    *   $\delta(u,v) = \infty$，若不存在路径。
*   **单源最短路径 (Single-Source Shortest Paths, SSSP)**：求给定源点 $s \in V$ 到每个顶点 $v \in V$ 的最短路径。
*   **最短路径的最优子结构** ✨：
    *   $\boxed{\text{最短路径的子路径也是最短路径。}}$
      (若 $p=<v_0, \dots, v_k>$ 是 $v_0$到$v_k$的最短路径，则其任意子路径 $p_{ij}=<v_i, \dots, v_j>$ 也是 $v_i$到$v_j$的最短路径。)
*   **环路 (Cycles)**：
    *   若图中存在从源点可达的**负权环路**，则某些最短路径不存在 (权重可以无限小)。Bellman-Ford算法可以检测负权环路。
    *   最短路径不包含正权环路。
*   **表示最短路径**：
    *   通常用数组 $d[v]$ 存储 $\delta(s,v)$ 的估计值 (最终为实际值)。
    *   用数组 $p[v]$ (或 $\pi[v]$) 存储 $v$ 在从 $s$ 到 $v$ 的最短路径上的**前驱顶点**。
    *   这些前驱指针构成一棵以 $s$ 为根的**最短路径树 (Shortest-Path Tree)**。

### ⚙️ 松弛操作 (Relaxation)

*   **核心思想**：对于每条边 $<u,v>$，通过比较“经过 $u$ 到达 $v$”的路径与“当前已知到达 $v$”的路径，尝试改进 $v$ 的最短路径估计值 $d[v]$。
*   **操作 `Relax(u, v, w)`**：
    ```
    if (d[v] > d[u] + w(u,v)) {
        d[v] = d[u] + w(u,v);
        p[v] = u;
    }
    ```
*   **初始化 `Initialize-Single-Source(G, s)`**：
    ```
    for each vertex v in V(G) {
        d[v] = infinity;
        p[v] = NIL; // 或 -1
    }
    d[s] = 0;
    ```
*   **性质**：
    *   **三角不等式**：对于任意边 $<u,v> \in E$，$\delta(s,v) \le \delta(s,u) + w(u,v)$。
    *   **上界性质**：始终有 $d[v] \ge \delta(s,v)$。当 $d[v] = \delta(s,v)$ 时，值不再改变。
    *   **收敛性质**：若 $s \leadsto u \to v$ 是一条最短路径，且在松弛边 $<u,v>$ 之前 $d[u]=\delta(s,u)$，则松弛后 $d[v]=\delta(s,v)$。
    *   **路径松弛性质**：若 $P=<v_0, v_1, \dots, v_k>$ 是 $s=v_0$ 到 $v_k$ 的最短路径，按顺序对 $P$ 上的边进行松弛，则 $d[v_k]=\delta(s,v_k)$。

### 算法1: Bellman-Ford算法 (单源，可处理负权边)

*   **思想**：对所有边进行 $|V|-1$ 轮松弛操作。
*   **算法**：
    1.  `Initialize-Single-Source(G, s)`。
    2.  `for i = 1 to |V|-1:`
    3.  `    for each edge <u,v> in E(G):`
    4.  `        Relax(u, v, w(u,v))`
    5.  `// 检测负权环路 (可选)`
    6.  `for each edge <u,v> in E(G):`
    7.  `    if d[v] > d[u] + w(u,v):`
    8.  `        return FALSE; // 存在负权环路`
    9.  `return TRUE;`
*   **时间复杂度**：$\boxed{O(VE)}$。
*   **正确性**：若无负权环路，经过 $|V|-1$ 轮松弛后，所有 $d[v]$ 均收敛到 $\delta(s,v)$。若第 $|V|$ 轮仍可松弛，则存在负权环路。

### 算法2: DAG最短路径算法 (单源，用于有向无环图)

*   **思想**：按顶点的**拓扑排序**顺序对每个顶点的出边进行松弛。
*   **算法**：
    1.  对DAG进行拓扑排序。
    2.  `Initialize-Single-Source(G, s)`。
    3.  `for each vertex u in topologically sorted order:`
    4.  `    for each vertex v adjacent to u (i.e., <u,v> in E):`
    5.  `        Relax(u, v, w(u,v))`
*   **时间复杂度**：拓扑排序 $O(V+E)$ + 松弛 $O(V+E)$ (每条边松弛一次) = $\boxed{O(V+E)}$。
*   **应用**：可用于求解**关键路径**问题 (将AOE网活动权重取负，求最长路径即为DAG最短路径)。

### 算法3: Dijkstra算法 (单源，要求所有边权非负)

*   **思想**：贪心算法。维护一个集合 $S$ (已确定最短路径的顶点) 和一个优先队列 $Q$ (存储 $V-S$ 中的顶点，按 $d[v]$ 值排序)。
*   **算法**：
    1.  `Initialize-Single-Source(G, s)`。
    2.  $S = \emptyset$。
    3.  $Q = V(G)$ (所有顶点入优先队列)。
    4.  `while Q is not empty:`
    5.  `    u = Extract-Min(Q)` (从Q中取出 $d[u]$ 最小的顶点 $u$)
    6.  `    S = S U {u}`
    7.  `    for each vertex v adjacent to u:`
    8.  `        Relax(u, v, w(u,v))` (若松弛成功，可能需要更新 $v$ 在 $Q$ 中的优先级)
*   **时间复杂度**：取决于优先队列的实现。
    *   简单数组实现 $Q$: `Extract-Min` $O(V)$, 更新 $O(1)$。总共 $\boxed{O(V^2)}$。
    *   二叉堆/斐波那契堆实现 $Q$:
        *   二叉堆：$O((V+E)\log V)$ 或 $O(E \log V)$ (若图连通 $E \ge V-1$)。
        *   斐波那契堆：$O(E + V \log V)$。
*   **Dijkstra算法的普遍最优性 (Universal Optimality)**：FOCS 2024 论文提到，Dijkstra算法在某种意义下具有普遍最优性，即使在最坏情况下也能达到理论上的最优。

### 算法4: Floyd-Warshall算法 (所有顶点对最短路径)

*   **思想**：动态规划。允许图中存在负权边，但不能有负权环路。
*   设 $d_{ij}^{(k)}$ 是从顶点 $i$ 到顶点 $j$，只允许使用 $\{v_1, \dots, v_k\}$ 作为中间顶点的最短路径权重。
*   **递推关系**：
    *   $d_{ij}^{(0)} = w_{ij}$ (直接边的权重，若 $i=j$ 则为0，无边则为 $\infty$)。
    *   $\boxed{d_{ij}^{(k)} = \min(d_{ij}^{(k-1)}, d_{ik}^{(k-1)} + d_{kj}^{(k-1)})}$ for $k=1, \dots, |V|$。
    *   (含义：从 $i$ 到 $j$ 经过前 $k$ 个顶点的最短路，要么不经过 $v_k$ (即 $d_{ij}^{(k-1)}$)，要么经过 $v_k$ (即 $d_{ik}^{(k-1)} + d_{kj}^{(k-1)}$))。
*   **算法**：
    1.  `Let D^(0) be the adjacency matrix (with 0 on diagonal, infinity for no edge).`
    2.  `for k = 1 to |V|:`
    3.  `    for i = 1 to |V|:`
    4.  `        for j = 1 to |V|:`
    5.  `            D^(k)[i,j] = min(D^(k-1)[i,j], D^(k-1)[i,k] + D^(k-1)[k,j])`
    6.  最终 $D^{(|V|)}$ 矩阵即为所有顶点对的最短路径权重。
*   **时间复杂度**：$\boxed{O(V^3)}$。
*   **空间复杂度**：$O(V^2)$ (可以优化空间，只用两个矩阵或一个矩阵原地更新)。
*   **前驱矩阵 $P^{(k)}[i,j]$**：用于记录路径。
    *   $P^{(0)}[i,j] = i$ if $w_{ij} \ne \infty$ and $i \ne j$, else $NIL$.
    *   If $d_{ij}^{(k-1)} \le d_{ik}^{(k-1)} + d_{kj}^{(k-1)}$, then $P^{(k)}[i,j] = P^{(k-1)}[i,j]$.
    *   Else $P^{(k)}[i,j] = P^{(k-1)}[k,j]$.

### 算法5: Johnson算法 (所有顶点对，用于稀疏图)

*   **思想**：通过**重赋权 (reweighting)** 将所有边权变为非负，然后对每个顶点运行Dijkstra算法。
*   **步骤**：
    1.  构造新图 $G'$：$G' = G$，并增加一个新源点 $s_0$，从 $s_0$ 到 $G$ 中所有其他顶点各加一条权为0的边。
    2.  在 $G'$ 上运行Bellman-Ford算法，计算从 $s_0$ 到所有顶点 $v$ 的最短路径权重 $h(v) = \delta(s_0, v)$。若检测到负权环，则算法终止。
    3.  对原图 $G$ 中的每条边 $<u,v>$，重赋权 $\hat{w}(u,v) = w(u,v) + h(u) - h(v)$。可以证明 $\hat{w}(u,v) \ge 0$。
    4.  对重赋权后的图 $\hat{G}$，以每个顶点 $u \in V$ 为源点运行Dijkstra算法，得到所有对 $(u,v)$ 的最短路径权重 $\hat{\delta}(u,v)$。
    5.  原图中的最短路径权重 $\delta(u,v) = \hat{\delta}(u,v) - h(u) + h(v)$。
*   **时间复杂度**：
    *   Bellman-Ford: $O(VE)$。
    *   $V$ 次Dijkstra (用斐波那契堆): $V \times O(E + V \log V) = O(VE + V^2 \log V)$。
    *   总复杂度：$\boxed{O(VE + V^2 \log V)}$。对于稀疏图 ($E$ 接近 $V$)，优于Floyd-Warshall。