# 📖 第六章 树与二叉树

## 6.1 树的结构及基本操作

### 🌲 树的基本概念

*   **定义**：树 (Tree) 是一类重要的**非线性**数据结构，它是以**分支关系**定义的**层次结构**。
*   **形式化定义**：树是由 $n (n \ge 0)$ 个结点组成的有限集合 T。当 $n=0$ 时称为空树。对于非空树 T：
    1.  有且仅有一个特定的称为**根 (root)** 的结点。
    2.  当 $n > 1$ 时，其余结点可分为 $m (0 \le m < n)$ 个互不相交的有限集合 $T_1, T_2, ..., T_m$，其中每一个集合本身又是一棵树，并且称为根的**子树 (Subtree)**。

*   **树的特点** ✨：
    *   除根结点外，每个结点都**仅有**一个**前趋 (父) 结点**。
    *   树是一种递归定义的数据结构。
    *   下图展示了一个4层的树结构：
    * ![](Pic/Pasted%20image%2020250427203204.png)
### 🌳 基本术语

*   **结点的度 (Degree)**：结点拥有的子树数目（或分支数）。
*   **叶子 (Leaf) / 终端结点**：度为 $0$ 的结点。
*   **分支结点 / 非终端结点**：度不为 $0$ 的结点。
*   **树的度**：树中各结点度的最大值。
*   **内部结点**：除根结点之外的分支结点。
*   **双亲 (Parent) 与 孩子 (Child)**：结点的子树的根称为该结点的孩子；该结点称为其孩子的双亲。
*   **兄弟 (Sibling)**：属于同一双亲的孩子。
*   **结点的层次 (Level)**：表示该结点在树中的相对位置。根为第一层，其孩子为第二层，以此类推。若某结点在第 $L$ 层，则其孩子在第 $L+1$ 层。
*   **堂兄弟 (Cousin)**：双亲在同一层的结点互为堂兄弟 (注：此定义与常见定义“同一祖父但不同父亲”略有差异，以讲义为准)。
*   **树的深度 (Depth) / 高度 (Height)**：树中结点的最大层次。
*   **有序树 (Ordered Tree)**：树中各结点的子树从左至右是有次序的，不能互换。
*   **无序树 (Unordered Tree)**：树中各结点的子树从左至右是无次序的，可以互换。
*   **路径 (Path)**：从树中某结点 $N_i$ 出发，能够“自上而下地”通过树中结点到达结点 $N_j$，则称 $N_i$ 到 $N_j$ 存在一条路径。
*   **路径长度 (Path Length)**：一条路径上所经过的分支（边）的数目。
*   **结点的祖先 (Ancestor)**：从根到该结点所经分支上的所有结点。
*   **结点的子孙 (Descendant)**：以该结点为根的子树中的任一结点。
*   **树的路径长度**：从根到树中**每个**结点的路径长度之和。
*   **森林 (Forest)**：是 $m (m \ge 0)$ 棵互不相交的树的集合。

### 📝 树的逻辑表示

1.  **树形表示法**：用圆圈表示结点，连线表示分支关系。
2.  **文氏图表示法**：每棵树对应一个圆圈，圆圈里包含根结点和代表子树的圆圈，同一结点子树圆圈不相交。
3.  **凹入表表示法**：每棵树一个条形，子树的根对应较短的条形，同一结点的子树根条形长度一样。
4.  **广义表 (括号) 表示法** 😊：每棵树对应一个以根为名的字符串，串名放左边，串是由括号里的各个子树对应的子串构成，子串之间用逗号隔开。
![](Pic/Pasted%20image%2020250509103245.png)
### ⚙️ 树的基本操作

*   `initiate(T)`: 初始化操作
*   `root(T)` / `root(x)`: 求根函数
*   `parent(T, x)`: 求双亲函数
*   `child(T, x, i)`: 求孩子结点函数 (第 i 个孩子)
*   `right_sibling(T, x)`: 求右兄弟函数
*   `crt_tree(x, F)`: 建树函数
*   `ins_child(y, i, x)`: 插入子树操作 (将 x 作为 y 的第 i 棵子树)
*   `del_child(x, i)`: 删除子树操作 (删除 x 的第 i 棵子树)
*   `traverse(T)`: 遍历操作
*   `clear(T)`: 清除结构操作

### 📐 树的性质

*   **性质①：树中结点数 = 所有结点出度之和 + 1。**
    *   **理解**：树中每条边都由一个父节点指向一个子节点，代表父节点的一个“出度”。边的总数是 $n-1$ (其中 $n$ 是结点数)。所以，所有结点的出度加起来等于 $n-1$。因此，$n = (\sum \text{出度}) + 1$。
*   **性质②：度为 $m$ 的树第 $i$ 层至多有 $m^{i-1}$ 个结点 ($i \ge 1$)。**
    *   **理解**：每一层的结点数最多是上一层的 $m$ 倍。
        *   第1层 (根)：1 个 ($=m^0$)
        *   第2层：最多 $1 \times m = m$ 个 ($=m^1$)
        *   第 $i$ 层：最多 $m^{i-1}$ 个。
    *   **记忆点**：类似细胞分裂，每层最多扩展 $m$ 倍。

*   **性质③：高度为 $h$，度为 $m$ 的树，最多有 $\frac{m^h - 1}{m-1}$ 个结点。**
    *   **理解**：这是所有层（从第1层到第 $h$ 层）最大结点数的总和：$1 + m + m^2 + \dots + m^{h-1}$。这是一个等比数列求和的结果。
    *   **记忆点**：满 $m$ 叉树的结点总数公式。

*   **性质④：具有 $n$ 个结点，度为 $m$ 的树，最小高度为 $\lceil \log_m (n (m - 1) + 1) \rceil$。**
    *   **核心**：由性质③反推，求能容纳 $n$ 个结点的最小层数。
    *   **推导**：设最小高度为 $h$。根据性质③， $n \le \frac{m^h - 1}{m-1}$。
        整理得 $n(m-1) \le m^h - 1 \Rightarrow n(m-1) + 1 \le m^h$。
        两边取对数 $\log_m (n(m-1)+1) \le h$。
        因为 $h$ 必须是整数，所以 $h_{min} = \lceil \log_m (n(m-1)+1) \rceil$。

*   **求解结点个数方法归纳**💡：对于度为 $m$ 的树，令 $n_i$ 表示度为 $i$ 的结点个数。
    *   总结点数：$n = n_0 + n_1 + ... + n_m$ (①)
    *   总边数 (度之和)：度之和 $= n_1 + 2n_2 + ... + m n_m$ (③)
    *   由性质①：度之和 $= n - 1$ (②)
    *   联合可得：$n = n_1 + 2n_2 + ... + m n_m + 1 = n_0 + n_1 + ... + n_m$
    *   推出叶子结点数 $n_0$ 与其他度结点数的关系：$\boxed{n_0 = n_2 + 2n_3 + ... + (m-1)n_m + 1}$
    *   **例**：一棵度为3的树中有2个度为3的结点($n_3=2$)，1个度为2的结点($n_2=1$)，2个度为1的结点($n_1=2$)，则叶子结点数 $n_0 = n_2 + (3-1)n_3 + 1 = 1 + 2 \times 2 + 1 = 6$。总结点数 $n = n_0 + n_1 + n_2 + n_3 = 6 + 2 + 1 + 2 = 11$ 个结点。

## 6.2 二叉树的定义与性质

### 🌴 二叉树的概念

*   **定义**：二叉树 (Binary Tree) 是 $n (n \ge 0)$ 个结点的有限集合，它或为空树 ($n=0$)，或由一个**根 (root)** 结点和两棵互不相交的、分别称为根的**左子树 (Left Subtree)** 和**右子树 (Right Subtree)** 的二叉树组成。
*   **二叉树的特点** ✨：
    1.  定义是**递归**的。
    2.  每个结点的度**至多为 2** ($0 \le \text{degree} \le 2$)。
    3.  是**有序树** (左右子树次序不能颠倒)。

### 🌳 二叉树的五种基本形态

1.  空二叉树。
2.  只有一个根结点的二叉树。
3.  只有根结点和左子树的二叉树。
4.  只有根结点和右子树的二叉树。
5.  具有左右子树的二叉树。

### 🌟 两种特殊的二叉树

1.  **满二叉树 (Full Binary Tree)**：每一层上的结点数都达到最大值（即深度为 $k$ 且有 $2^k - 1$ 个结点的二叉树）。
2.  **完全二叉树 (Complete Binary Tree)**：深度为 $k$ 的具有 $n$ 个结点的二叉树，当且仅当其每一个结点都与深度为 $k$ 的满二叉树中编号从 1 至 $n$ 的结点一一对应时，称为完全二叉树。
    *   特点：叶子结点只可能出现在最下两层，且最下一层的叶子结点都集中在该层最左边的若干位置上。只有最下面两层结点的度可小于2。

### 📐 二叉树的性质

*   **性质1**：二叉树的第 $i$ 层上至多有 $\boxed{2^{i-1}}$ 个结点 ($i \ge 1$)。
*   **性质2**：深度为 $k$ 的二叉树至多有 $\boxed{2^k - 1}$ 个结点 ($k \ge 1$)。
*   **性质3**：对任何一棵二叉树 T，如果其终端结点数 (叶子数) 为 $n_0$，度为 2 的结点数为 $n_2$，则 $\boxed{n_0 = n_2 + 1}$。
    *   证明：联立结点总数 $n = n_0+n_1+n_2$ 和边数 $n-1 = n_1+2n_2$。
*   **性质4**：具有 $n$ 个结点的完全二叉树的深度为 $\boxed{\lfloor \log_2 n \rfloor + 1}$。
*   **性质5 (完全二叉树)**：对具有 $n$ 个结点的完全二叉树 (按层序从 1 到 $n$ 编号)，对任一结点 $i (1 \le i \le n)$ 有：

    1.  若 $i > 1$，则 $i$ 的双亲是 $\lfloor i/2 \rfloor$；若 $i=1$，则 $i$ 是根，无双亲。
    2.  若 $2i \le n$，则 $i$ 的左孩子是 $2i$；否则，i 无左孩子。
    3.  若 $2i+1 \le n$，则 $i$ 的右孩子是 $2i+1$；否则，i 无右孩子。

*   **求解二叉树结点个数方法归纳** 💡：
    1.  **一般二叉树**：利用 $n = n_0 + n_1 + n_2$ 和 $n_0 = n_2 + 1$。
        *   度之和 $= n_1 + 2n_2 = n - 1$。
    2.  **完全二叉树**：
        *   若 $n$ 为偶数：$n_1 = 1$, $n_0 = n/2$, $n_2 = n/2 - 1$。
        *   若 $n$ 为奇数：$n_1 = 0$, $n_0 = (n+1)/2$, $n_2 = (n-1)/2$。
    3.  **满二叉树**：高度 $h$, 结点数 $n$。
        *   $h = \log_2(n+1)$
        *   $n_1 = 0$
        *   $n = 2^h - 1$
        *   $n_0 = 2^{h-1}$
        *   $n_2 = 2^{h-1} - 1$
    *   **例1**：一棵二叉树中有7个叶子 ($n_0=7$)，5个度为1的结点 ($n_1=5$)。由 $n_0 = n_2 + 1$ 得 $n_2 = n_0 - 1 = 7 - 1 = 6$。总结点数 $n = n_0 + n_1 + n_2 = 7 + 5 + 6 = \boxed{18}$ 个结点。
    *   **例2**：一棵完全二叉树共有1001个结点 ($n=1001$，奇数)。叶子数 $n_0 = (n+1)/2 = (1001+1)/2 = \boxed{501}$ 个。
    *   **例3**：一棵满二叉树共有64个叶子 ($n_0=64$)。叶子数 $n_0 = 2^{h-1}$，所以 $64 = 2^{h-1}$，即 $2^6 = 2^{h-1}$。得 $h-1=6$，所以树高 $h = \boxed{7}$。

## 6.3 二叉树的存储结构

### 🔢 顺序存储结构

*   主要适用于**完全二叉树**：按从上到下、从左到右的层次顺序 (即完全二叉树的编号顺序) 将结点存放在一维数组中。
*   **优点**：结构简单，查找结点的双亲和孩子（根据性质5的公式）非常方便。
*   **缺点**：对于非完全二叉树，特别是稀疏的二叉树，会浪费大量存储空间。
*   **特殊表示 (非主流)**：
    *   **三元组**：存储结点数据和其左右孩子在向量 (数组) 中的序号 (下标)。用 -1 表示空孩子。
    *   **双亲表示**：存储结点数据和其父结点的序号 (下标)。根节点的父结点为 -1。
![](Pic/Pasted%20image%2020250509111836.png)
### 🔗 链式存储结构

1.  **二叉链表 (Binary Linked List)**：最常用的二叉树链式存储结构。
    *   结点结构：`| lc | data | rc |`，其中 `lc` 和 `rc` 是分别指向左、右孩子结点的指针。
    *   `struct btnode { elemtype data; struct btnode *lc, *rc; }; typedef struct btnode *BiTree;`
    *   **结论** 🤔：若一个二叉树含有 $n$ 个结点，则它的二叉链表中必含有 $2n$ 个指针域，其中必有 $\boxed{n+1}$ 个空的链域 (NULL指针)。(因为有 $n-1$ 条边，每条边消耗一个入度指针，总指针 $2n$ 个，所以空指针 $2n-(n-1)=n+1$ 个)

2.  **三叉链表 (Triply Linked List)**：在二叉链表的基础上增加一个指向**双亲结点**的指针 `parent`。
    *   结点结构：`| lc | data | parent | rc |`
    *   `struct btnode { elemtype data; struct btnode *lc, *rc, *parent; }; typedef ... *BiTree;`
    *   优点：方便查找父结点。
    *   缺点：结构更复杂，占用空间更多。

### 🛠️ 从广义表创建二叉链表

*   **思路**：利用栈来保存双亲结点，用一个标志 $k$ 区分当前要创建的是左孩子 ($k=1$) 还是右孩子 ($k=2$)。
*   **步骤** (扫描广义表字符串 `ch`)：
    1.  遇到字母：创建新结点 `p`，根据 `k` 值将其连接到栈顶结点的左孩子 (`k=1`) 或右孩子 (`k=2`)。如果是第一个结点，则设为树根 T。
    2.  遇到 `(`：将刚创建的结点 `p` 作为双亲压入栈，设置 $k=1$ (准备处理左孩子)。
    3.  遇到 `,`：设置 $k=2$ (准备处理右孩子)。
    4.  遇到 `)`：表示栈顶结点的子树处理完毕，栈顶结点退栈。
*   **示例代码 (C/C++)** ：

    ```c++
    #include <stdlib.h> // for malloc
    #define MAXSIZE 100 // 假设栈大小

    typedef char elemtype; // 假设结点数据类型为字符
    typedef struct btnode {
        elemtype data;
        struct btnode *lc, *rc;
    } *BiTree;

    // 根据广义表字符串 str 创建二叉树 T
    void CreateTree(BiTree &T, char *str) {
        BiTree St[MAXSIZE];  // 栈，用于存放双亲结点指针
        int top = -1;        // 栈顶指针
        int k;               // 1表示左孩子，2表示右孩子
        int j = 0;           // 字符串扫描指针
        BiTree p = NULL;     // 当前创建的结点指针
        char ch;

        T = NULL; // 初始化树为空

        ch = str[j];
        while (ch != '\0') {
            switch(ch) {
                case '(': // 遇到左括号，栈顶指针加1，将当前结点p入栈，k=1表示接下来是左孩子
                    top++;
                    St[top] = p;
                    k = 1;
                    break;
                case ')': // 遇到右括号，栈顶指针减1，表示子树处理完毕
                    top--;
                    break;
                case ',': // 遇到逗号，k=2表示接下来是右孩子
                    k = 2;
                    break;
                default:  // 遇到结点数据
                    p = (BiTree)malloc(sizeof(struct btnode));
                    if (p == NULL) { /* 错误处理 */ exit(1); } // 省略了出错处理细节
                    p->data = ch;
                    p->lc = p->rc = NULL;
                    if (T == NULL) { // 如果树为空，当前结点是根
                        T = p;
                    } else { // 否则根据k值连接到栈顶结点的孩子
                        if (k == 1) {
                            St[top]->lc = p;
                        } else { // k == 2
                            St[top]->rc = p;
                        }
                    }
            }
            j++;
            ch = str[j]; // 移到下一个字符
        }
    }
    ```

## 6.4 二叉树的遍历

### 🎯 遍历的目的与概念

*   **目的**：将非线性结构的结点排列为一个**线性序列**，方便处理。
*   **概念**：指按某条搜索路线**走遍**二叉树的每个结点，使得树中每个结点都被**访问一次**，且**仅被访问一次**。

### 🚶 典型的遍历方法 (基于递归思想)

**回顾**：**递归 (Recursion)** 是一种算法设计技巧，一个函数直接或间接调用自身。需要包含两个要素：
1.  **基本情况 (Base Case)**：递归调用的终止条件，通常是问题规模最小的情况。
2.  **递归步骤 (Recursive Step)**：将原问题分解为规模更小的子问题，并通过调用自身来解决子问题，最终组合子问题的解得到原问题的解。对于树结构，空树通常是基本情况。

以下 D、L、R 分别代表：访问根结点 (Data)、遍历左子树 (Left)、遍历右子树 (Right)。

1.  **先(根)序遍历 (Preorder Traversal, DLR)**：
    *   若二叉树为空，则空操作。
    *   否则：① **访问根结点**； ② 先序遍历左子树； ③ 先序遍历右子树。

2.  **中(根)序遍历 (Inorder Traversal, LDR)**：
    *   若二叉树为空，则空操作。
    *   否则：① 中序遍历左子树； ② **访问根结点**； ③ 中序遍历右子树。

3.  **后(根)序遍历 (Postorder Traversal, LRD)**：
    *   若二叉树为空，则空操作。
    *   否则：① 后序遍历左子树； ② 后序遍历右子树； ③ **访问根结点**。

4.  **层序遍历 (Level Order Traversal)**：
    *   从上到下、从左到右逐层访问结点。通常使用**队列**实现。

*(逆序方式 DRL, RDL, RLD 很少使用)*
![](Pic/Pasted%20image%2020250509131731.png)
### 🔄 遍历的递归算法实现

```c++
// 假设 Printdata(data) 是访问结点的操作，例如打印结点数据
void Printdata(elemtype data) { printf("%c", data); } // 示例

// 先序遍历
void Preorder(BiTree T) {
    if (T) { // 基本情况: T == NULL (隐式)
        Printdata(T->data); // D
        Preorder(T->lc);   // L
        Preorder(T->rc);   // R
    }
}

// 中序遍历
void Inorder(BiTree T) {
    if (T) {
        Inorder(T->lc);   // L
        Printdata(T->data); // D
        Inorder(T->rc);   // R
    }
}

// 后序遍历
void Postorder(BiTree T) {
    if (T) {
        Postorder(T->lc);  // L
        Postorder(T->rc);  // R
        Printdata(T->data); // D
    }
}
```

### 🌲 利用遍历结果确定二叉树

*   已知**先序序列** 和 **中序序列** ⇒ $\boxed{唯一确定一棵二叉树}$
*   已知**后序序列** 和 **中序序列** ⇒ $\boxed{唯一确定一棵二叉树}$
*   已知**先序序列** 和 **后序序列** ⇒ $\boxed{不能唯一确定一棵二叉树}$ (除非是特殊的树，如满二叉树结构已知)
*   **思考**：层序 + 先序/中序/后序 能否唯一确定？如何做？(通常 层序+中序 可以唯一确定)

*   **重建示例** (先序 + 中序)：
    *   先序: `ABCDEFGH`
    *   中序: `BDCEAFHG`
    1.  先序第一个 `A` 是根。
    2.  在中序中找到 `A`，`A` 左边的 `BDCE` 是左子树的中序，`A` 右边的 `FHG` 是右子树的中序。
    3.  根据左子树结点数 (4个)，先序中 `A` 之后的 4 个 `BCDE` 是左子树的先序，剩下的 `FGH` 是右子树的先序。
    4.  递归处理左子树 (先序`BCDE`，中序`BDCE`) 和右子树 (先序`FGH`，中序`FHG`)。
        *   左子树：根是`B`。中序`BDCE`中 `B` 左边无，右边 `DCE`。先序 `CDE` 是右子树的。
        *   右子树 (`BCDE` 的右子树)：根是 `C`。中序 `DCE` 中 `C` 左边 `D`，右边 `E`。先序 `DE` 分别对应左右。
        *   ... 以此类推。
![](Pic/Pasted%20image%2020250509132013.png)
### 🔄 遍历的非递归算法 (使用栈)

**回顾**：**栈 (Stack)** 是一种后进先出 (LIFO) 的数据结构，主要操作是 `push` (入栈) 和 `pop` (出栈)。非递归遍历通常需要栈来模拟递归调用的过程。

1.  **先序遍历 (非递归)**

    ```c++
    #include <stack> // 使用C++ STL栈

    void Preorder_NonRecursive(BiTree T) {
        if (!T) return;
        std::stack<BiTree> s;
        s.push(T);
        while (!s.empty()) {
            BiTree p = s.top();
            s.pop();
            Printdata(p->data); // 访问根
            if (p->rc) s.push(p->rc); // 右孩子先入栈 (后访问)
            if (p->lc) s.push(p->lc); // 左孩子后入栈 (先访问)
        }
    }

    // 另一种写法 (一路向左，模拟递归更紧密)
    void Preorder_NonRecursive2(BiTree T) {
        if (!T) return;
        std::stack<BiTree> s;
        BiTree p = T;
        while (p || !s.empty()) {
            if (p) { // 当前结点不空
                Printdata(p->data); // 访问
                s.push(p);         // 入栈
                p = p->lc;         // 向左走
            } else { // 当前结点为空 (左边走到底)
                p = s.top();      // 从栈顶取出父结点
                s.pop();
                p = p->rc;         // 转向右子树
            }
        }
    }
    ```

2.  **中序遍历 (非递归)**

    ```c++
    #include <stack>

    void Inorder_NonRecursive(BiTree T) {
        if (!T) return;
        std::stack<BiTree> s;
        BiTree p = T;
        while (p || !s.empty()) {
            if (p) { // 当前结点不空，一路向左压栈
                s.push(p);
                p = p->lc;
            } else { // 左边走到底
                p = s.top();      // 弹出根结点
                s.pop();
                Printdata(p->data); // 访问根结点
                p = p->rc;         // 转向右子树
            }
        }
    }
    ```

3.  **后序遍历 (非递归)** 
	**后序遍历 (左-右-根) 的非递归实现比先序和中序复杂，关键在于：一个节点在（从左子树处理完毕后）被考虑访问时，不能立即输出。必须先确保其右子树已经被访问完毕。**
	
	*   **与先序/中序的区别**：
	    *   先序：节点第一次被处理（或出栈）即可访问。
	    *   中序：节点从左子树返回（或因左路到头而出栈）即可访问。
	    *   后序：节点必须在其左、右子树均访问完毕后才能访问。这就需要一种机制来判断右子树是否已访问。
	
	*   **常见解决思路**：
	    *   **思路1 (双栈法)**：类似先序遍历，第一个栈按“根-右-左”的顺序存储节点，然后将这些节点依次压入第二个栈。从第二个栈依次弹出即为“左-右-根”的后序序列。
	    *   **思路2 (标记法/辅助指针法)**：使用单个栈，但需要额外信息（如记录上一个访问的节点，或给节点打标记）来判断当前栈顶节点的右子树是否已经被访问过。如果右子树未访问，则先处理右子树；如果右子树已访问（或不存在），则访问当前节点。

### 📶 层序遍历 (使用队列)

**回顾**：**队列 (Queue)** 是一种先进先出 (FIFO) 的数据结构，主要操作是 `enqueue` (入队) 和 `dequeue` (出队)。

```c++
#include <queue> // 使用C++ STL队列

void LevelOrder(BiTree T) {
    if (!T) return;
    std::queue<BiTree> q;
    q.push(T); // 根结点入队
    while (!q.empty()) {
        BiTree p = q.front(); // 取出队头结点
        q.pop();
        Printdata(p->data);    // 访问
        if (p->lc) q.push(p->lc); // 左孩子入队
        if (p->rc) q.push(p->rc); // 右孩子入队
    }
}
```

### 📊 遍历、栈与树的计数

*   **栈操作序列关系**：
    *   若将**先序序列**看作入栈序列，则**中序序列**是对应合法的出栈序列之一。
    *   若将**中序序列**看作入栈序列，则**后序序列**是对应合法的出栈序列之一。
*   **树的计数 (卡特兰数)**：
    *   已知含 $n$ 个结点的二叉树的先序序列，可能的中序序列有 $\boxed{C_n = \frac{\binom{2n}{n}}{n+1} = \frac{(2n)!}{(n+1)!n!}}$ 种，对应的树型也有 $C_n$ 种。
    *   已知含 $n$ 个结点的二叉树的中序序列，可能的后序序列 (及对应树型) 也有 $C_n$ 种。
    *   **例**：对于序列 ABCD (n=4)，可能的树型有 $C_4 = \frac{\binom{8}{4}}{4+1} = \frac{70}{5} = 14$ 种。

### 💡 遍历应用示例

*   **求后序遍历第一个结点**：即树的最左下的叶子结点。
    ```c++
    BiTree firstnode(BiTree root) {
		if (!root) return NULL; // 空树
        BiTree p = root;
        // 优先向左走，直到叶子；如果左边空，再尝试向右走
        while (p->lc || p->rc) { // 只要不是叶子
            if (p->lc) {
                p = p->lc; // 向左
            } else {
                p = p->rc; // 向右 (当左子树空时)
            }
        }
        return p; // p 现在是最左下的叶子
    }
    ```
*   **查找结点值为 x 的结点 (`pre_find`)** (使用先序逻辑，需要全局变量或引用传递结果)
*   **求每个结点所处的层次 (`pre_level`)** (使用先序逻辑，传递 level 参数)
*   **求二叉树的高度 (`post_height`)** (使用后序逻辑，递归返回左右子树高度)
    ```c++
    int post_height(BiTree bt) {
        if (bt == NULL) {
            return 0; // 空树高度为0 (或-1，看定义)
        } else {
            int lh = post_height(bt->lc); // 求左子树高
            int rh = post_height(bt->rc); // 求右子树高
            return 1 + std::max(lh, rh); // 树高 = 1 + max(左右子树高)
        }
    }
    ```
*   **复制一颗二叉树 (`pre_copy`)** (使用先序逻辑)
    ```c++
    void pre_copy(BiTree bt, BiTree &q) { // q 是要创建的新树的引用
        if (bt) {
            q = (BiTree)malloc(sizeof(struct btnode)); // 创建新结点
            if (!q) exit(1); // 错误处理
            q->data = bt->data;        // 复制数据
            pre_copy(bt->lc, q->lc);   // 递归复制左子树
            pre_copy(bt->rc, q->rc);   // 递归复制右子树
        } else {
            q = NULL; // 原树空，新树也空
        }
    }
    ```
*   **求最近公共祖先 (LCA) (顺序存储)**：对于顺序存储的完全二叉树，结点 i 和 j 的 LCA 可以通过不断将较深结点的下标替换为其父结点下标 (`k = k / 2`)，直到两者下标相等为止。
    ```c++
    int forefather(int i, int j) { // 数组下标从1开始
        while (i != j) {
            if (i > j) {
                i = i / 2;
            } else {
                j = j / 2;
            }
        }
        return i; // i (或 j) 即为 LCA 的下标
    }
    ```

### ❓ 何时遍历序列相同?

*   **先序 == 后序**? $\Leftrightarrow$ 空树或只有根结点。
*   **中序 == 后序**? $\Leftrightarrow$ 空树或只有左子树 (所有结点都在左链上)。
*   **先序 == 中序**? $\Leftrightarrow$ 空树或只有右子树 (所有结点都在右链上)。
*   **中序 == 层序**? $\Leftrightarrow$ 空树或只有右子树。

## 6.5 算术表达式二叉树

### 🧮 定义与遍历关系

*   **表达式树 (Expression Tree)**：用于表示算术表达式的二叉树。
    *   **叶子结点**：操作数 (常量或变量)。
    *   **内部结点**：操作符。
*   **遍历关系**：
    *   **中序遍历** (加括号)：得到标准的**中缀表达式**。
    *   **后序遍历**：得到**后缀表达式 (逆波兰 RPN)**。
    *   **先序遍历**：得到**前缀表达式 (波兰)**。(不常用)

*   **示例**：表达式 `(a + (b * c)) + (((d * e) + f) * g)`
    *   ![](Pic/Pasted%20image%2020250509145613.png)
    *   后缀 (后序)： `abc*+de*f+g*+`
    *   前缀 (先序)： `++a*bc*+*defg`

### ⇄ 表达式转换

1.  **中缀转后缀** (栈应用)：
    *   遇到**操作数**：直接输出。
    *   遇到**操作符**：
        *   若栈空或栈顶为 `(`，直接入栈。
        *   若优先级高于栈顶操作符，直接入栈。
        *   若优先级低于或等于栈顶操作符，将栈顶操作符弹出并输出，重复比较新栈顶，直到可入栈。
    *   遇到 `(`：直接入栈。
    *   遇到 `)`：将栈内 `(` 之上的操作符依次弹出并输出，最后弹出 `(` (不输出)。
    *   表达式扫描完毕，弹出栈中所有剩余操作符。
    *（如`a+b*c+(d*e+f)*g` 转换为 `abc*+de*f+g*+`)*

2.  **后缀转表达式树** (栈应用)：
    *   遇到**操作数**：创建单结点树，将指针压入栈。
    *   遇到**操作符**：从栈中弹出两个指针 $T_1$ (先弹出的, 右操作数) 和 $T_2$ (后弹出的, 左操作数)，创建以操作符为根的新树， $T_2$ 为左子树，$T_1$ 为右子树，将新树指针压回栈。
    *   表达式扫描完毕，栈中唯一的指针即指向表达式树的根。


## 6.6 线索二叉树

### 🤔 引入意义

*   **问题**：普通二叉链表存储中存在大量的空指针域 ($n+1$ 个)。
*   **思路**：利用这些空指针域存放指向结点在某种遍历次序下的**前驱 (predecessor)** 和**后继 (successor)** 结点的指针，这些指针称为**线索 (thread)**。
*   **目的**：方便在线性序列中查找前驱/后继，加快遍历速度，尤其是在非递归遍历中。

### 💾 存储结构

*   在二叉链表结点中增加两个标志域 `ltag` 和 `rtag`：
    *   `ltag = 0`: `lc` 指向左孩子。
    *   `ltag = 1`: `lc` 指向**前驱** (线索)。
    *   `rtag = 0`: `rc` 指向右孩子。
    *   `rtag = 1`: `rc` 指向**后继** (线索)。
*   **结点结构**： `| lc | ltag | data | rtag | rc |`
*   **类型定义**：
    ```c++
    typedef enum {Link, Thread} PointerTag; // Link=0 (孩子), Thread=1 (线索)

    typedef struct BiThrNode {
        elemtype data;
        struct BiThrNode *lc, *rc;
        PointerTag ltag, rtag;
    } BiThrNode, *BiThrTree;
    ```
*   **示例**：
* ![](Pic/Pasted%20image%2020250509150349.png)

### 🔎 查找前驱/后继

*   **中序线索二叉树** (最常用) 👍：
    *   **找后继 (Successor)**：
        *   若 `p->rtag == 1`，则 `p->rc` 即为后继 (线索)。
        *   若 `p->rtag == 0`，则后继是 `p` 的右子树中进行中序遍历时的**第一个**结点 (即右子树的最左下结点)。
    *   **找前驱 (Predecessor)**：
        *   若 `p->ltag == 1`，则 `p->lc` 即为前驱 (线索)。
        *   若 `p->ltag == 0`，则前驱是 `p` 的左子树中进行中序遍历时的**最后一个**结点 (即左子树的最右下结点)。

*   **先序/后序线索二叉树** 👎：
    *   查找前驱或后继可能需要访问**双亲**信息。
    *   后序线索：找后继比较困难。
    *   先序线索：找前驱比较困难。
    *   因此，先序和后序线索化**不常用**，线索二叉树通常指**中序**线索二叉树。

### 线索化过程 (中序)

*   **思想**：在对二叉树进行中序遍历的同时，修改空指针，建立线索。需要一个全局指针 `pre` 指向**刚刚访问过**的结点。
*   **步骤** (递归 `inthread(p)`):
    1.  递归线索化左子树： `inthread(p->lc)`。
    2.  **处理当前结点 p**：
        *   检查 `p` 的左指针：若 `p->lc == NULL`，建立前驱线索 `p->ltag = Thread; p->lc = pre;`。
        *   检查 `pre` 的右指针：若 `pre != NULL` 且 `pre->rc == NULL`，建立 `pre` 的后继线索 `pre->rtag = Thread; pre->rc = p;`。
    3.  **更新 pre**: `pre = p`。
    4.  递归线索化右子树： `inthread(p->rc)`。
*   **调用**：
    ```c++
    BiThrTree pre = NULL; // 全局变量，初始为 NULL
    void InThreading(BiThrTree T) { // 主函数
        if (T) {
            inthread(T);
            // 处理最后一个结点的后继线索 (如果需要循环链表)
            if (pre->rc == NULL) {
                pre->rtag = Thread;
                // pre->rc 指向头结点或NULL，取决于是否带头结点
            }
        }
    }

    void inthread(BiThrTree p) { // 递归辅助函数
        if (p) {
            inthread(p->lc); // 1. 线索化左子树

            // 2. 处理当前结点 p 的前驱线索
            if (p->lc == NULL) {
                p->ltag = Thread;
                p->lc = pre;
            } else {
                p->ltag = Link;
            }

            // 3. 处理前驱结点 pre 的后继线索
            if (pre != NULL && pre->rc == NULL) {
                pre->rtag = Thread;
                pre->rc = p;
            }
            // pre 的 rtag 保持 Link (如果它有右孩子)

            pre = p; // 4. 更新 pre

            inthread(p->rc); // 5. 线索化右子树
        }
    }
    ```

### 🔗 带头结点的线索二叉树

*   为了方便遍历（尤其是找到序列的第一个结点和从最后一个结点回到开始），可以增加一个**头结点 (header node)**。
*   头结点的 `lc` 指向树的根，`rc` 指向中序遍历的**最后一个**结点。
*   中序遍历的**第一个**结点的 `lc` (若为线索) 指向头结点。
*   中序遍历的**最后一个**结点的 `rc` (若为线索) 指向头结点。
*   这样形成一个**双向循环链表**。

![](Pic/Pasted%20image%2020250509164720.png)

### ✏️ 线索二叉树的更新操作 (插入/删除)

*   **问题**：在插入或删除结点/子树时，不仅要修改孩子指针，还需要**维护**相关结点的线索。
*   **解决方法**：
    1.  简单方法：先将树还原为普通二叉树，执行插入/删除，然后**重新线索化**整个树。（效率低）
    2.  复杂方法：仔细分析插入/删除点**周围**的结点的前驱和后继关系的变化，**局部修改**线索。（效率高但易出错）
*   **示例**：在中序线索二叉树中，将结点 `t` 插入为结点 `s` 的右孩子。
    *   **Case 1: s 原本没有右孩子**
        *   `t` 的前驱是 `s` (`t->ltag=1, t->lc=s`)。
        *   `t` 的后继是 `s` 原来的后继 (`t->rtag=1, t->rc = s->rc`)。
        *   `s` 的后继是 `t` (`s->rtag=0, s->rc = t`)。
        *   `t` 的后继 (原 `s` 的后继) 的前驱变成 `t`。
    *   **Case 2: s 原本有右孩子 R**
        *   原右子树 `R` 成为 `t` 的右子树 (`t->rc = R, t->rtag=0`)。
        *   `t` 的前驱是 `s` (`t->ltag=1, t->lc=s`)。
        *   `t` 的后继是 `R` 的中序第一个结点。
        *   `s` 的后继是 `t` (`s->rc = t, s->rtag=0`)。
        *   原右子树 `R` 的中序第一个结点的前驱变成 `t`。

## 6.7 哈夫曼树 (Huffman Tree)

### 🏆 最优二叉树的概念

*   **背景**：考虑判定树，不同的判定树结构可能导致平均判定次数不同（如图）。目标是构建一种**平均查找长度最短**的判定树。
* ![](Pic/Pasted%20image%2020250509165201.png)
*   **树的路径长度**：从根到每个结点的路径长度之和。
*   **结点的带权路径长度**：从根到该结点的路径长度 × 该结点的**权值**。
*   **树的带权路径长度 (Weighted Path Length, WPL)**：树中**所有叶子结点**的带权路径长度之和。
    *   $\boxed{WPL = \sum_{k=1}^{n} w_k l_k}$，其中 $n$ 是叶子数，$w_k$ 是第 $k$ 个叶子的权值，$l_k$ 是第 $k$ 个叶子到根的路径长度 (深度)。
*   **哈夫曼树 (Huffman Tree) / 最优二叉树**：给定 $n$ 个权值 $\{w_1, w_2, ..., w_n\}$ 作为 $n$ 个叶子结点，构造一棵二叉树，使其**WPL 最小**。

### 🏗️ 构造方法

*   **基本思想**：**使权值大的叶子结点尽量靠近根，权值小的叶子结点尽量远离根**。采用**贪心**策略。
*   **步骤**：
    1.  根据给定的 $n$ 个权值 $\{w_1, ..., w_n\}$ 构成 $n$ 棵二叉树的森林 $F = \{T_1, ..., T_n\}$，每棵树 $T_i$ 只有一个带权 $w_i$ 的根结点，其左右子树均为空。
    2.  **重复**以下步骤 $n-1$ 次，直到 $F$ 中只剩下一棵树：
        *   在 $F$ 中选取两棵**根结点权值最小**的树，作为左右子树构造一棵**新**的二叉树。
        *   新二叉树的根结点的权值为其**左右子树根结点权值之和**。
        *   从 $F$ 中删除选出的两棵树，并将新构造的树加入 $F$。
    3.  最后剩下的那棵树即为哈夫曼树。
* ![](Pic/Pasted%20image%2020250509165532.png)
*   **特点**：
    *   哈夫曼树中**没有度为 1** 的结点，它是一棵**严格二叉树** (Full Binary Tree, 即所有非叶结点的度都为2)。
    *   构造出的哈夫曼树**形态不唯一** (当有相同最小权值时，选取次序不同可能导致左右子树交换)，但其**WPL 是唯一且最小**的。

### 💾 存储结构与实现

*   **存储**：通常采用**静态链表 (数组)** 存储。由于 $n$ 个叶子的哈夫曼树共有 $2n-1$ 个结点，可以用一个大小为 $2n-1$ 的结构数组 `ht`。
    *   结点结构 `HTNode`: `weight`, `parent`, `lc`, `rc`。
*   **实现步骤** (`HuffmanTree(w[], n)`):
    1.  初始化：分配 $2n-1$ 个单元，`0` 到 `n-1` 存放叶子结点，`n` 到 `2n-2` 存放非叶子结点。将所有单元的 `parent`, `lc`, `rc` 初始化为特定值 (如 -1)。将叶子结点的 `weight` 设为输入的权值 `w[i]`。
    2.  进行 $n-1$ 次合并：
        *   从 `0` 到 `i-1` (当前已构造结点范围) 中，选择两个**`parent` 域为 -1** (即尚未合并，是当前森林中树的根) 且 `weight` 最小的结点 `s1` 和 `s2`。
        *   将 `s1` 和 `s2` 的 `parent` 设为 `i` (新合并结点的下标)。
        *   设置新结点 `ht[i]` 的 `weight = ht[s1].weight + ht[s2].weight`, `lc = s1`, `rc = s2`, `parent = -1`。
        * 
![](Pic/Pasted%20image%2020250509170132.png)

### 应用：哈夫曼编码 (Huffman Coding)

*   **目的**：用于数据**无损压缩**，得到最短的二进制编码。
*   **方法**：
    1.  统计字符集中各字符的出现**频次 (或概率)**，作为权值。
    2.  以这些权值构造一棵哈夫曼树。
    3.  约定哈夫曼树中**左分支**代表 `0`，**右分支**代表 `1`。
    4.  从**根**到每个**叶子**结点的路径上，将经过的分支代码 (0或1) 连接起来，即为该叶子对应字符的**哈夫曼编码**。
*   **性质**：
    *   **不等长编码**：不同字符的编码长度通常不同，频次高的字符编码短，频次低的字符编码长。
    *   **前缀编码 (Prefix Code)**：任何一个字符的编码**都不是**另一个字符编码的前缀。这保证了编码数据流可以被**唯一地解码**，无需特殊分隔符。
    *   **总编码长度最短**：对于给定的字符频次，哈夫曼编码能使编码后的总比特数（即 $\sum (\text{频次}_i \times \text{编码长度}_i)$）达到最小，这等价于 WPL 最小。
*   ![](Pic/Pasted%20image%2020250509170222.png)
*   **比较**：![](Pic/Pasted%20image%2020250509170310.png) → 显著压缩！
*   **解码**：从编码串的第一个比特开始，沿着哈夫曼树的根根据 0 (左) 或 1 (右) 走，到达叶子结点即译出一个字符，然后从根重新开始处理下一个比特，直到编码串结束。

*   **总结** ✅：
    *   哈夫曼编码是不等长、前缀编码。
    *   哈夫曼树无度为1结点，结点总数 $2n-1$ (n为叶子数)。
    *   发送/编码：查表。
    *   接收/解码：遍历树。

## 6.8 树、森林与二叉树的转换

### 🌲 树 ⇌ 二叉树

1.  **树转换为二叉树 (左孩子右兄弟法)**：
    *   **规则**：
        1.  加线：在所有兄弟结点之间加一连线。
        2.  去线：对树中每个结点，只保留它与第一个孩子的连线，删去与其他孩子的连线。
        3.  旋转：以根为轴心，将树顺时针旋转一定角度 (约 45°)。
    *   **结果**：
        *   原树中的孩子结点 → 转换后二叉树结点的**左**孩子。
        *   原树中的兄弟结点 → 转换后二叉树结点的**右**孩子。
        *   转换后的二叉树，其**根结点没有右子树** (如果原结构是一棵树)。
![](Pic/Pasted%20image%2020250509170441.png)
2.  **二叉树转换为树**：(是上述过程的逆过程)
    *   若某结点 x 是其双亲 y 的左孩子，则将 x 的右孩子、右孩子的右孩子... (即右链上的所有结点) 都连接到 y。
    *   删除原二叉树中所有结点与其右孩子的连线。

### 🌳 森林 ⇌ 二叉树

1.  **森林转换为二叉树**：
    *   **步骤**：
        1.  先将森林中的**每一棵树**分别转换为二叉树。
        2.  从第二棵二叉树开始，依次将**后一棵**二叉树的根结点作为**前一棵**二叉树根结点的**右孩子**连接起来。
    *   **结果**：得到的一棵大二叉树，其左子树对应森林中第一棵树，其右子树对应森林中剩余部分转换成的二叉树。
![](Pic/Pasted%20image%2020250509170633.png)
2.  **二叉树转换为森林**：(是上述过程的逆过程)
    *   若二叉树的根结点有右孩子，则将**根与其右孩子的连线断开**，得到新的二叉树（原右子树）；重复此过程，直到根没有右孩子。
    *   对得到的所有二叉树，分别进行“二叉树转换为树”的操作。

### 树/森林的遍历

*   **树的遍历** (先根、后根)
    *   **先根遍历**：先访问根结点，然后**依次**先根遍历根的各棵子树。
        *   **关系** 💡：树的先根遍历序列 == 其对应二叉树的**先序遍历**序列。
    *   **后根遍历**：先**依次**后根遍历根的各棵子树，然后访问根结点。
        *   **关系** 💡：树的后根遍历序列 == 其对应二叉树的**中序遍历**序列。
    *   树没有直接对应的“中根”遍历。

*   **森林的遍历** (先序、中序)
    *   **先序遍历森林**：
        1.  访问森林中**第一棵树**的根结点。
        2.  先序遍历第一棵树的**子树森林**。
        3.  先序遍历**除去第一棵树**后剩余的森林。
        *   **关系** 💡：森林的先序遍历序列 == 其对应二叉树的**先序遍历**序列。
    *   **中序遍历森林**：
        1.  中序遍历森林中**第一棵树**的**子树森林**。
        2.  访问第一棵树的**根结点**。
        3.  中序遍历**除去第一棵树**后剩余的森林。
        *   **关系** 💡：森林的中序遍历序列 == 其对应二叉树的**中序遍历**序列。

### 树/森林 存储结构 (回顾 & 补充)

*   **双亲表示法**: `parent` 数组存储每个结点的父结点下标。适合快速查找父结点。
*   **孩子链表表示法**: 数组存放结点信息，每个结点通过链表指向其所有孩子。数组+单链表。
*   **孩子兄弟表示法 (CSTree)**: 即**树转换成二叉链表**的存储方式。结点包含 `firstchild` (指向第一个孩子) 和 `nextsibling` (指向下一个兄弟) 指针。这种结构本身就是一个二叉树。
    *   **类型定义：
        ```c++
        typedef struct TreeNode {
            elemtype data;
            struct TreeNode *firstchild;
            struct TreeNode *nextsibling;
        } TreeNode, *CSTree;
        ```
    *   **遍历某结点所有孩子**: 从 `firstchild` 开始，沿着 `nextsibling` 链遍历，直到 `nextsibling` 为空。

*   **应用：Unix 文件系统**：
    *   目录结构是典型的树结构。
    *   **遍历应用1**：输出目录中所有文件 (带缩进) → **先根**遍历 (`ListDir`)。
    *   **遍历应用2**：计算目录总大小 → **后根**遍历 (`SizeDirectory`)，子目录大小计算完后累加到父目录。

## 6.9 并查集 (Disjoint Set Union, DSU)

### 🤝 基本概念

*   **等价类 (Equivalence Class)**：将一个集合 S 划分为若干个互不相交的子集 $S_1, S_2, ..., S_k$，这些子集称为等价类。$S = S_1 \cup S_2 \cup ... \cup S_k$ 且 $S_i \cap S_j = \emptyset$ (当 $i \neq j$)。
*   **并查集 (Disjoint Set / Union-Find)**：一种维护若干个不相交集合（等价类）的数据结构，支持两种主要操作：
    1.  **`union(i, j)` (合并/Merge)**：将包含元素 `i` 和 元素 `j` 的两个集合合并成一个集合。
    2.  **`find(i)` (查找)**：确定元素 `i` 属于哪一个集合（通常返回该集合的代表元素，如根）。

*   **表示方法**：常用**树**的集合（即**森林**）来表示等价类。
    *   每棵树代表一个等价类 (集合)。
    *   树的**根结点**作为该集合的唯一**代表元**。
    *   树中的边通常表示**从子结点指向父结点**的关系。

### 🔗 实现与优化

1.  **简单实现 (数组)**：
    *   用一个数组 `parent[MAX_SIZE]` 表示森林。
    *   `parent[i]` 存储元素 `i` 的父结点的下标。
    *   **根结点**的 `parent` 值设为 **-1** (或其他特殊值)。
    *   **`find(i)` 操作**：从 `i` 开始，不断沿着 `parent` 指针向上查找，直到找到根 (值为 -1 的结点)。
        ```c++
        int SimpleFind(int i) {
            while (parent[i] >= 0) { // >=0 表示不是根 (根存 -1)
                i = parent[i];
            }
            return i; // 返回根节点下标
        }
        ```
    *   **`union(i, j)` (简单合并)**：先分别找到 `i` 和 `j` 的根 `root_i` 和 `root_j`。如果 `root_i != root_j`，则将一棵树的根连接到另一棵树的根（例如，简单地 `parent[root_i] = root_j;`）。
        ```c++
        void SimpleMerge(int i, int j) {
            int root_i = SimpleFind(i);
            int root_j = SimpleFind(j);
            if (root_i != root_j) {
                parent[root_i] = root_j; // 将 i 所在树合并到 j 所在树
            }
        }
        ```
    *   **复杂度问题** 😟：简单的合并可能导致树退化成一条**链**。在这种情况下，`find` 操作的时间复杂度最坏可能达到 $O(n)$。如果执行 $n-1$ 次合并和 $n$ 次查找，总时间复杂度可能高达 $O(n^2)$ 。

2.  **优化1：按秩合并 / 加权合并 (Union by Rank/Size)** 👍：
    *   **思想**：在合并时，总是将**小**的树合并到**大**的树上，以避免树的高度过高。
    *   **实现 (按大小合并)**：用根结点的 `parent` 域存储**负**的集合大小 (元素个数)。
        ```c++
        void WeightedMerge(int i, int j) {
            int root_i = SimpleFind(i); // 假设 Find 操作已存在
            int root_j = SimpleFind(j);
            if (root_i != root_j) {
                // parent[root] 存储的是大小的负数
                int size_i = -parent[root_i];
                int size_j = -parent[root_j];
                int total_size = size_i + size_j;

                if (size_i < size_j) { // i 树更小，合并到 j 树
                    parent[root_i] = root_j;
                    parent[root_j] = -total_size; // 更新 j 树的大小
                } else { // j 树更小或相等，合并到 i 树
                    parent[root_j] = root_i;
                    parent[root_i] = -total_size; // 更新 i 树的大小
                }
            }
        }
        ```
    *   **效果**：使用按秩/大小合并后，任何包含 $n$ 个元素的树的高度**不会超过** $\boxed{\lfloor \log_2 n \rfloor + 1}$。这使得 `find` 操作的时间复杂度降为 $O(\log n)$。。
    *   $u-1$ 次 `merge` 和 $f$ 次 `find` 的总复杂度为 $O(u + f \log u)$。

3.  **优化2：路径压缩 (Path Compression)** 👍：
    *   **思想**：在执行 `find(i)` 操作找到根 `root` 的同时，将从 `i` 到 `root` 路径上的所有结点的 `parent` 指针**直接指向根 `root`**。
    *   **实现**：
        ```c++
        int CollapsingFind(int i) {
            // 1. 找到根
            int root;
            for (root = i; parent[root] >= 0; root = parent[root]);

            // 2. 压缩路径
            while (i != root) {
                int s = parent[i]; // 保存 i 的父结点
                parent[i] = root; // 将 i 直接连到根
                i = s;           // 处理原父结点
            }
            return root;
        }
        ```
    *   **效果**：极大地降低后续 `find` 操作的时间。

4.  **结合使用：按秩合并 + 路径压缩** ✨✨：
    *   **复杂度**：同时使用这两种优化时，执行 $u$ 次 `union` 和 $f$ 次 `find` 操作的总时间复杂度**接近线性**，约为 $O(n + f \alpha(f+n, n))$，其中 $\alpha$ 是**反阿克曼函数 (Inverse Ackermann function)**。
    *   **反阿克曼函数 $\alpha(p, q)$** 增长极其缓慢，对于所有实际可能的 $p, q$ 值，$\alpha(p, q) \le 4$。因此，在实践中，可以认为并查集的操作**接近均摊常数时间** $O(1)$。
    *   **阿克曼函数 A(i, j)**：是一个增长非常快的函数，用于定义 $\alpha$。
    *   **空间复杂度**：$O(n)$，用于存储 `parent` 数组。