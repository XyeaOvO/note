# 📖 第十章 外部排序

## 10.1 外部排序的基本概念

### 🎯 外部排序的应用对象

*   **定义**：当待排序的数据记录数量巨大，无法一次性装入内存时，需要在**外存储器**（如磁盘、磁带）的辅助下进行的排序过程，称为外部排序。

### ↔️ 外排序与内排序的差别

*   **内部排序** ✨：
    *   充分利用内存可以**随机存取**的特点。
    *   例如：希尔排序中相隔 $d$ 的记录可比较；堆排序中父子结点可直接计算下标比较；快速排序中需正向和逆向访问序列。
*   **外部排序** 💾：
    *   外存信息的定位和存取受其**物理特性**的限制（主要是I/O时间远大于CPU计算时间）。
    *   算法设计核心在于**减少I/O次数**。

### ⚙️ 外部排序的实现手段

*   在排序过程中，进行多次**内外存之间的数据交换**。
*   通常包括两个阶段：
    1.  **初始归并段的生成**：将外存文件分块读入内存，利用内部排序方法生成若干有序的子文件（称为初始归并段），并写回外存。
    2.  **归并段的合并**：将这些初始归并段逐步合并，最终形成一个整体有序的文件。

### 💾 外部信息的存取

#### 1. 磁带信息的存取 📼

*   属于**顺序存取设备**，只适用于存储顺序文件。
*   **工作原理**：
    *   磁带是启停设备，I/O操作以**块 (Block)** 为单位。
    *   块与块之间存在**块间隙 (Inter-Block Gap, IBG)**。
    *   ![](Pic/Pasted%20image%2020250509103245_placeholder_tape.png) <!-- 占位图：磁带块结构 -->
*   **读写一块信息的时间** $T_{I/O}$：
    *   $\boxed{T_{I/O} = t_a + n \cdot t_w}$
    *   $t_a$：磁头定位到物理块起始位置的时间 (主要是启停时间)。
    *   $n$：块中的字符数 (或字节数)。
    *   $t_w$：传输一个字符的时间。

#### 2. 磁盘信息的存取 💿

*   属于**直接存取设备** (更准确地说是块设备，可随机访问块)，适用于各类存储形式的文件。
*   **工作原理**：
    *   **磁道 (Track)**：盘片上的同心圆。
    *   **柱面 (Cylinder)**：各盘面上半径相同的磁道合在一起。
    *   **扇区 (Sector)**：每个磁道等分为若干扇区 (块)。
    *   **读取信息过程**：
        1.  **寻道 (Seek)**：移动磁头到目标柱面。
        2.  **旋转延迟 (Latency)**：等待目标扇区旋转到磁头下方。
        3.  **数据传输 (Transfer)**：读取或写入数据。
    *   ![](Pic/Pasted%20image%2020250509103245_placeholder_disk.png) <!-- 占位图：磁盘结构 -->
*   **读写一块信息的时间** $T_{I/O}$：
    *   $\boxed{T_{I/O} = t_{seek} + t_{latency} + n \cdot t_w}$
    *   $t_{seek}$：磁头定位到磁道的时间 (寻道时间)。
    *   $t_{latency}$：等待时间 (旋转延迟时间)。
    *   $n \cdot t_w$：传输 $n$ 个字符的时间。

## 10.2 外部排序的基本方法——归并排序法

### 📜 [步骤]

1.  **生成若干初始归并段/顺串 (文件预处理)**
    *   把含有 $N$ 个记录的文件，按内存缓冲区大小（设能容纳 $L$ 个记录）分成若干长度为 $L$ 的子文件/段。
    *   分别调入内存，用有效的**内部排序**方法排序后送回外存，形成初始归并段。
2.  **多路合并**
    *   对初始归并串逐趟合并，直至最后在外存上得到整个有序文件为止。

### 📊 [例]

*   某文件共10000个记录，设每个物理块可以容纳200个记录，内存缓冲区可以容纳5个物理块 (即1000个记录)。
    1.  经过 $10000 / 1000 = 10$ 次内排序后得到10个初始归并段 R1~R10，每个段含1000个记录。
    2.  采用**两路归并**，需 $\lceil \log_2 10 \rceil = 4$ 趟可以得到排好序的文件。
        *   R1 R2 R3 R4 R5 R6 R7 R8 R9 R10 (各有1000)
        *   (R1,R2) (R3,R4) (R5,R6) (R7,R8) (R9,R10) (各有2000)
        *   ((1,2),(3,4)) ((5,6),(7,8)) ((9,10), 空) (各有4000, 2000)
        *   (((1-4),(5-8))) (((9,10)),空) (各有8000, 2000)
        *   ((((1-8),(9-10)))) (10000)
*   **外排序总时间** (粗略分析，忽略CPU计算时间，只关注I/O)：
    *   初始排序读写：$2 \times (10000/200) = 100$ 次块I/O。
    *   归并趟数 $s=4$。每趟归并都需要读写整个文件一次。
    *   总I/O次数 $\approx (\text{初始读写次数}) + s \times (\text{读写整个文件次数})$
    *   若 $t_{IO}$ 为读写一块的时间，则：
        *   内排序阶段I/O：$10 \times (5 \text{块读} + 5 \text{块写}) = 100 t_{IO}$。
        *   归并阶段I/O (每趟读写所有记录)：
            *   趟1：读10000，写10000 $\rightarrow (50+50)t_{IO}$
            *   趟2：读10000，写10000 $\rightarrow (50+50)t_{IO}$
            *   趟3：读10000，写10000 $\rightarrow (50+50)t_{IO}$
            *   趟4：读10000，写10000 $\rightarrow (50+50)t_{IO}$
            *   总归并I/O $= 4 \times 100 t_{IO} = 400 t_{IO}$。
            *   更精确地，每趟归并，每个记录都被读一次，写一次。总共 $N$ 个记录，进行了 $s$ 趟归并，所以归并阶段的I/O是 $2 \times N \times s$ (以记录为单位) or $2 \times (\text{总块数}) \times s$ (以块为单位)。
            *   总I/O $\approx 2 \times (\text{总块数}) \times (1+s)$。
*   **内部归并时间**：
    *   若 $t_{mg}$ 为比较移动一个记录的时间，总记录数 $N=10000$。
    *   每趟归并 $N$ 个记录。总内部归并时间 $\approx N \times s \times t_{mg}$。

### 🚀 [提高外排序效率的途径]

*   **减少合并趟数 $s$**，以减少I/O次数。
    *   $\boxed{s = \lceil \log_k m \rceil}$，其中 $m$ 是初始归并段的个数，$k$ 是归并路数。
*   **扩大初始归并段长度 $L$**，从而减少初始归并段个数 $m$。
*   **进行多路 ($k$ 路) 归并**，即增大 $k$。

## 10.3 多路(k路)平衡归并与败者树

### 🤔 [通过简单比较进行归并存在的问题]

*   设记录总数为 $N$，初始归并段的个数为 $m$。
*   从 $k$ 个记录中选择一个关键字最小的记录时的比较次数为 $C_{select}$ (若简单比较为 $k-1$)。
*   $s$ 趟内部归并总的比较次数为：
    *   $\text{TotalComparisons} = s \times C_{select} \times (N-1) \approx s \cdot (k-1) \cdot N$
    *   $s = \lceil \log_k m \rceil = \lceil \frac{\log_2 m}{\log_2 k} \rceil$
    *   $\text{TotalComparisons} \approx \lceil \frac{\log_2 m}{\log_2 k} \rceil \cdot (k-1) \cdot N$
*   **矛盾** ⚔️：
    *   $k \uparrow \implies s \downarrow \implies$ I/O次数减少 (好)。
    *   $k \uparrow \implies (k-1) \uparrow \implies$ 内部归并时选最小关键字的比较次数增加，归并效率降低 (不好)。

### 💡 [解决矛盾的方法——败者树]

*   利用 **败者树 (Loser Tree)** 或 **胜者树 (Winner Tree)** 从 $k$ 个当前记录中选出关键字最小的记录。
*   使用树形选择，每次选最小的比较次数为 $C_{select} = O(\log_2 k)$。
*   则总比较次数 $\text{TotalComparisons} \approx \lceil \log_k m \rceil \cdot (\log_2 k) \cdot N = \lceil \frac{\log_2 m}{\log_2 k} \rceil \cdot (\log_2 k) \cdot N \approx \lceil \log_2 m \rceil \cdot N$。
*   $\boxed{\text{此时总比较次数与 } k \text{ 无关 (或弱相关)，主要由 } m \text{ 决定。}}$
    这使得我们可以增大 $k$ 来减少I/O次数，而内部比较开销增长较慢。

### 🌲 胜者树 (树形选择排序)

*   一种完全二叉树，叶子结点存放当前参与比较的记录，内部结点存放其子结点中的“胜者”（关键字较小者）。根结点即为所有记录中的最终胜者。
*   ![](Pic/Pasted%20image%2020250509103245_placeholder_winner_tree.png) <!-- 占位图：胜者树 -->
*   **⚠️ 缺陷**：
    *   当一个叶子结点记录更新后（例如，输出一个记录，从其对应归并段取入下一个记录），需要从该叶子到根的路径上所有结点都可能需要更新，以确定新的胜者。重构胜者树时，涉及较多结点比较。

### 🌳 败者树 (Loser Tree)

*   也是一种完全二叉树，但内部结点记录的是其子结点比较时的“败者”（关键字较大者）的**来源归并段的编号** (或指针)。胜者继续向上传递参与比较。树根的父结点 (通常用一个附加单元 `ls[0]` 存储) 记录的是最终胜者所在的归并段编号。
*   ![](Pic/Pasted%20image%2020250509103245_placeholder_loser_tree.png) <!-- 占位图：败者树 -->
*   **✨ 特点与优点**：
    *   记录败者编号，胜者参加下一轮比赛。
    *   **重构时修改结点较少**：当一个叶子结点记录更新后，该记录从叶子开始向上与其父结点中记录的“败者”进行比较，新的败者留在该父结点，胜者继续向上比较，直到树根的父结点。调整路径通常更短或比较次数更少。

### 📝 [数据结构] (败者树为完全二叉树，用数组存储)

*   **主数组 `b[0...k]`**:
    *   `b[0...k-1]`：$k$ 个叶子结点，存放 $k$ 个输入归并段中当前参加归并的记录。
    *   `b[k]`：一个虚拟记录，其关键字取可能的最小值 `MINKEY` (用于初始化比较)。
*   **辅数组 `ls[0...k-1]`**:
    *   不含叶结点的败者树，共 $k-1$ 个内部结点，若从1开始编号则为 `ls[1...k-1]`。
    *   `ls[i]` 存放第 $i$ 个内部结点处比赛的败者的**来源归并段编号**。
    *   `ls[0]`：存放最终胜出记录的**来源归并段编号**。

### ⚙️ [处理步骤] (使用败者树进行 $k$ 路归并)

1.  **建败者树 `ls[0...k-1]`**：
    *   从 $k$ 个归并段各读入一个记录到 `b[0...k-1]`。
    *   初始化败者树：从叶结点开始，两两比较，败者编号存入父结点，胜者向上传递，直到确定 `ls[0]`。
2.  **重复直至 $k$ 路归并完毕**：
    1.  将 `b[ls[0]]` (最终胜者记录) 写至输出归并段。
    2.  从编号为 `ls[0]` 的输入归并段中读入下一个记录到 `b[ls[0]]`。若该段已空，则将 `b[ls[0]]` 的关键字设为无穷大 `MAXKEY` (或一个特殊标记)。
    3.  **调整败者树**：从 `b[ls[0]]` 对应的叶子结点开始，沿着到根的路径，与其路径上的父结点中记录的败者进行比较，更新败者树。

### 🔄 调整败者树的方法示例 (以在b[i]补充新记录为例)

*   新补充记录的来源为第 $s = \text{sourc-idx}$ 段。
*   从叶子 $s$ 开始，当前胜者为 $s$。
*   与其父结点 $p = \lfloor (s+k)/2 \rfloor$ (假设叶子编号0 to k-1, 内部节点 ls[1] to ls[k-1]) 中记录的败者 `ls[p]` 进行比较。
    *   若 $b[s]$ 的关键字 < $b[ls[p]]$ 的关键字，则 $s$ 胜出，`ls[p]` 保持不变。$s$ 继续作为胜者向 $p$ 的父结点比较。
    *   若 $b[s]$ 的关键字 > $b[ls[p]]$ 的关键字，则 $b[ls[p]]$ 胜出，将原胜者 $s$ 记录为新的败者（即 `temp = ls[p]; ls[p] = s; s = temp;`），$s$ (现在是原`ls[p]`) 作为胜者向 $p$ 的父结点比较。
*   重复此过程，直到到达根的“外部”结点 `ls[0]`，将最终胜者的编号存入 `ls[0]`。

### 🧠 [k-路归并对内存的要求]

*   至少要有 $k$ 个**输入缓冲区**和一个**输出缓冲区**。
*   为了提高效率，实现I/O与内部处理的并行：
    *   若只有一个输出缓冲区，当输出缓存写磁盘时，内部归并须暂停。
    *   若只有 $k$ 个输入缓冲区，当某个输入缓冲区数据用完需从磁盘读时，内部归并也可能暂停。
    *   **理想情况**：通常设置 $2k$ 个输入缓冲区 (每路一个主缓冲区，一个备用缓冲区) 和 $2$ 个输出缓冲区 (一个满时写入磁盘，另一个可继续接收数据)，以实现输入、处理、输出三者之间的最大并行。但 $2k$ 个输入缓存也不足以完全保证输入输出并行。

## 10.4 置换-选择排序 (Replacement Selection)

### 🎯 [目标]

*   **扩大初始归并段长度**，使其平均长度大于内存工作区容量 (设为 $w$ 个记录)，从而减少初始归并段的个数 $m$，进而减少归并趟数 $s$。

### 📜 [置换-选择排序原理]

*   维护一个大小为 $w$ 的内存**工作区 (WA)**，其中记录保持某种“最小堆”的性质 (通过败者树实现)。
*   **输入文件 (FI)**，**输出文件 (FO)**。
### 📊 [示例] (WA能装4个记录, FI: 36,21,33,87,23,7,62,16,54,43,29,...)

| FO (当前归并段)     | WA (4个记录)     | FI (下一个) | minimax | 备注                                      |
| :------------------ | :--------------- | :---------- | :------ | :---------------------------------------- |
| (段1开始)           | `_` `_` `_` `_`  | 36          |         | Fill WA                                   |
|                     | 36 21 33 87      | 23          |         |                                           |
| 21                  | 36 **23** 33 87  | 7           | 21      | Output 21, Read 23                        |
| 21, 23              | 36 **7** 33 87   | 62          | 23      | Output 23, Read 7 (7<23, 7属下一段，暂不可选) |
| 21, 23, 33          | 36 7 **62** 87   | 16          | 33      | Output 33, Read 62 (62>33)                |
| 21, 23, 33, 36      | **16** 7 62 87   | 54          | 36      | Output 36, Read 16 (16<36, 16属下一段)    |
| 21, 23, 33, 36, 62  | 16 7 **54** 87   | 43          | 62      | Output 62, Read 54 (54<62, 54属下一段)    |
| 21, 23, 33, 36, 62, 87 | 16 7 54 **43**   | 29          | 87      | Output 87, Read 43 (43<87, 43属下一段)    |
| (段1结束) (段2开始) | 16 7 54 43       | 29          |         | WA中无记录 > 87，段1结束。新段从WA中选最小。 |
| 7                   | 16 **29** 54 43  | ...         | 7       | Output 7, Read 29 (29>7)                  |
| ...                 | ...              | ...         | ...     | ...                                       |

*   **核心**：新读入的记录，如果其关键字小于刚输出的 `minimax`，则它不能加入当前归并段，会被“冻结”或标记为属于下一个归并段。

### 🛠️ [置换-选择排序的实现] (利用败者树)

*   **数据结构**：
    *   败者树 (`ls`, `b`) 用于从 WA 中选择最小的、属于当前段的记录。
    *   `runNum[i]`：记录 `b[i]` 所属的归并段号。
    *   `currentNum`：当前正在生成的归并段的段号。
    *   `minimax`：上一个输出到 FO 的记录的关键字。
    *   `winner`：败者树选出的胜者在 `b` 中的下标。
    *   `winnerRun`：`b[winner]` 所属的段号。
    *   `maxRun`：当前已知的最大段号 (用于给新来的“小”记录分配段号)。
*   **调整败者树原则 (选最小规则)**：
    *   $\boxed{\text{段号不相同，段号小者为胜者；段号相同，关键字小者为胜者。}}$
*   **处理步骤**：
    1.  **初始化败者树**:
        *   所有外部结点 (WA 中的记录 `b[i]`) 置最小值；所有内部结点置最小值。
        *   对外部结点从编号 $w-1$ 至 $0$：从外存 FI 读入记录，置段号 `runNum[i]=1`，并调整败者树。
    2.  置当前段号 `currentRun = 1`。
    3.  **循环**：
        *   获取胜者 `winner = ls[0]`，胜者段号 `winnerRun = runNum[winner]`。
        *   **判断是否换段**：
            *   若 `winnerRun > currentRun` (即胜者属于未来段，当前段已无可选记录)：
                *   输出段结束标记。
                *   `currentRun = winnerRun` (更新当前段号)。
                *   输出新段开始标记 (如果需要)。
            *   (若 `winnerRun < currentRun` 是不可能的，因为旧段记录已输出)
        *   输出 `b[winner]` 到 FO，并记录其关键字为 `minimax`。
        *   **补充记录**：若 FI 未空，从 FI 补充记录到 `b[winner]`：
            *   若新记录关键字 `< minimax`，则 `runNum[winner] = maxRun + 1` (属于更新的段)，并更新 `maxRun` (如果 `maxRun+1` 比当前 `maxRun` 大)。
            *   否则 (新记录关键字 $\ge minimax$)，`runNum[winner] = currentRun` (属于当前段)。
        *   若 FI 已空，则将 `b[winner]` 设为虚记录 (关键字 $\infty$)，`runNum[winner] = maxRun + 1`。
        *   **调整败者树** (根据上述段号和关键字的比较规则)。
    4.  **循环终止**：直至所有记录被输出 (例如，当 `winnerRun` 超过 `maxRun` 且 FI 已空，表示所有实际数据都已处理)。

### 💡 初始归并段长度分析

*   所得初始归并段的**长度不等**。
*   设内存工作区 (缓冲区) 大小为 $m$ (即 $w$)。
*   **最短长度**：至少为 $m$。当FI中后续读入的记录关键字均小于当前段已输出的`minimax`时，WA中原有 $m$ 个记录会被逐个输出。
*   **最长长度**：可以是整个文件长度 $N$，如果文件已完全有序。
*   **平均长度**：$\boxed{L_{avg} \approx 2m}$ (或 $2w$)
    *   推导概要：初始 $m$ 个记录入WA，均属第一段。之后每输出一个，从FI读入一个。若FI随机，新读入记录约有1/2概率大于`minimax` (可留当前段)。当WA中充满小于`minimax`的记录时，此段结束。平均而言，一个大小为 $m$ 的WA，在“装满-清空”一个段的过程中，大约能处理 $2m$ 个记录。
    *   $m + m/2 + m/4 + \dots = 2m$ (这是一个理想模型下的级数和，近似解释)。

## 10.5 最佳归并树 (Optimal Merge Tree)

### 🤔 [最佳归并树的引入]

*   在进行 $k$ 路归并时，如果初始归并段的**长度不同**，那么不同的归并段组合方式（即归并树的形态）会导致归并过程中总的 **I/O 次数（或读写记录总数）不同**。
*   目标是找到一种归并顺序，使得总的I/O代价最小。
*   **代价衡量**：通常用 $\sum (\text{归并段长度} \times \text{其在归并树中的路径长度})$ 来衡量，因为每个记录每向上一层表示被读写一次。
*   实际 I/O 次数是所有叶子结点（初始归并段）的**带权外部路径长度 (Weighted External Path Length, WEPL)** 的2倍 (一次读，一次写)。WEPL = $\sum L_i \cdot E_i$，其中 $L_i$ 是叶子 $i$ 的权值（段长度），$E_i$ 是其在 $k$ 叉归并树中的深度。
*   ![](Pic/Pasted%20image%2020250509103245_placeholder_merge_tree_compare.png) <!-- 占位图：不同归并树代价比较 -->

### 🏗️ [最佳归并树的构造]

*   $\boxed{\text{最佳归并树即 } k \text{ 叉哈夫曼树 (k-ary Huffman Tree)。}}$
*   **构造原则**：权值越小的结点（段长度短的归并段）离根结点越远。
*   **步骤** (设初始归并段为 $m$ 个，进行 $k$ 路归并)：
    1.  **处理虚段 (Dummy Runs)**：为了保证每次合并都是 $k$ 个段合并成一个段 (即构造一棵严格的 $k$ 叉树)，可能需要加入若干长度为 0 的“虚段”。
        *   若 $(m-1) \pmod{(k-1)} \neq 0$，则需附加虚段的个数为：
            $\boxed{d = (k-1) - ((m-1) \pmod{(k-1)})}$
        *   **思考：为什么？如何求得的？** (见下节证明)
    2.  **构造 $k$ 叉哈夫曼树**：
        *   将 $m$ 个初始归并段（包括可能的虚段）作为叶子结点，其权值为段长度。
        *   重复以下操作，直到只剩一个结点（树根）：
            *   选取当前权值最小的 $k$ 个结点。
            *   构造一个新的父结点，其权值为这 $k$ 个子结点权值之和。
            *   这 $k$ 个结点成为新父结点的子结点。

### 🧾 虚段的补法的证明

*   在 $k$ 路平衡归并中，归并树是一棵度为 $k$ 的树 (更准确地说，内部结点的度恰好为 $k$，叶子结点度为0)。
*   设叶子结点 (初始归并段) 个数为 $m$，具有 $k$ 个孩子的内部结点 (代表一次 $k$ 路合并操作) 个数为 $n_k$。
*   树中总结点数 $N = n_k + m$。
*   树中总边数：从每个内部结点出发有 $k$ 条边，共 $k \times n_k$ 条边。从另一个角度看，除根结点外，每个结点都有唯一一条入边，所以总边数也为 $N-1 = n_k + m - 1$。
*   因此，$k \times n_k = n_k + m - 1 \implies (k-1)n_k = m-1 \implies n_k = (m-1)/(k-1)$。
*   为了使 $n_k$ 为整数 (即每次合并都能凑齐 $k$ 个段)，$(m-1)$ 必须是 $(k-1)$ 的倍数。
*   若 $(m-1) \pmod{(k-1)} = r \neq 0$，则说明 $m-1 = q(k-1) + r$。我们需要增加 $d$ 个虚段，使得新的叶子数 $m' = m+d$，且 $(m'-1)$ 是 $(k-1)$ 的倍数。
    即 $(m+d-1) \pmod{(k-1)} = 0$。
    $( (m-1) + d ) \pmod{(k-1)} = 0 \implies (r+d)$ 必须是 $(k-1)$ 的倍数。
    最少需要 $d = (k-1) - r = (k-1) - ((m-1) \pmod{(k-1)})$ 个虚段。

### 📊 [示例] (PDF P28)

*   长度分别为 2, 3, 6, 9, 12, 17, 18, 24 的 8 个初始归并段，进行 3 路归并，求最佳归并树。
    *   $m=8, k=3$.
    *   $(m-1) \pmod{(k-1)} = (8-1) \pmod{(3-1)} = 7 \pmod 2 = 1 \neq 0$.
    *   需加虚段数 $d = (3-1) - 1 = 1$ 个。虚段长度为 0。
    *   现在的权值集合 (叶子)：{0, 2, 3, 6, 9, 12, 17, 18, 24} (共9个)。
    *   构造3叉哈夫曼树：
        1.  选最小3个：0, 2, 3 $\rightarrow$ 合并成父结点 5。 剩余：{5, 6, 9, 12, 17, 18, 24} (7个)
        2.  选最小3个：5, 6, 9 $\rightarrow$ 合并成父结点 20。 剩余：{12, 17, 18, 20, 24} (5个)
        3.  选最小3个：12, 17, 18 $\rightarrow$ 合并成父结点 47。 剩余：{20, 24, 47} (3个)
        4.  选最小3个：20, 24, 47 $\rightarrow$ 合并成父结点 91 (根)。
    *   树形结构：(91 ( (20 ( (5 (0,2,3)), 6, 9) ), 24, (47 (12,17,18) ) ) )
    *   I/O次数 (记录读写总数) = $2 \times WEPL = 2 \times (\sum L_i \cdot E_i)$
        *   路径长度：
            *   0,2,3: 深度3
            *   6,9: 深度2
            *   12,17,18: 深度2
            *   24: 深度1
        *   $WEPL = (0+2+3)\times3 + (6+9)\times2 + (12+17+18)\times2 + 24\times1$
        *   $WEPL = 5\times3 + 15\times2 + 47\times2 + 24\times1 = 15 + 30 + 94 + 24 = 163$.
        *   I/O记录数 = $2 \times 163 = 326$. 
## 10.6 磁带排序 📼

*   **基本考虑**：
    *   磁带是顺序存取设备，其效能只有在顺序读写数据时才能充分发挥。
    *   关键在于如何合理地在磁带上**分布初始归并段**和**组织归并过程**，以减少磁带的卷绕、启停次数。
    *   “一条带的情况”：通常指初始归并段在一个输入带上，通过内存归并后结果写到另一个输出带上。

### ⚙️ 两种常用的磁带文件排序法

#### 1. 多路平衡归并排序

*   **特点**：每一趟归并都是文件中的**全部记录**参加。
*   **方法 (使用 $2k$ 条磁带进行 $k$ 路归并)**：
    1.  将 $m$ 个初始归并段**均匀地分布**在 $k$ 条输入磁带上。
    2.  从这 $k$ 条输入带上各取一个归并段进行 $k$ 路归并，归并后的较长段轮流、均匀地写到另外 $k$ 条输出磁带上。
    3.  下一趟，原输出带变成输入带，原输入带变成输出带（清空或可覆盖）。
    4.  重复此过程，直到所有记录合并成一个归并段。
*   **示例**：$N=4500$记录, 块=250记录, WA=750记录 (3块), $k=2$路归并, 使用4台磁带机 T1,T2,T3,T4。原数据在T4。
    1.  **内排序**：生成 $4500/750 = 6$ 个初始归并段。假设轮流写在T1和T2上 (各3段)。
        *   T1: R1, R3, R5
        *   T2: R2, R4, R6
        *   T3, T4: 空
    2.  **第一趟归并** (T1,T2作输入；T3,T4作输出)：
        *   (R1,R2) $\rightarrow$ R1' (写到T3)
        *   (R3,R4) $\rightarrow$ R2' (写到T4)
        *   (R5,R6) $\rightarrow$ R3' (写到T3)
        *   T1,T2: 空
        *   T3: R1', R3'
        *   T4: R2'
    3.  **第二趟归并** (T3,T4作输入；T1,T2作输出)：
        *   (R1',R2') $\rightarrow$ R1'' (写到T1)
        *   (R3', 空) $\rightarrow$ R2'' (写到T2, R3'直接拷贝)
        *   T1: R1''
        *   T2: R2''
        *   T3,T4: 空
    4.  **第三趟归并** (T1,T2作输入；T3作输出)：
        *   (R1'',R2'') $\rightarrow$ Final (写到T3)
*   **$k+1$ 条磁带上的实现方法** ($k$ 条作输入，1 条作输出)：
    1.  初始归并段均匀地写到前 $k$ 条磁带上。
    2.  进行 $k$ 路归并后的归并段全部写到第 $k+1$ 条磁带上。
    3.  将第 $k+1$ 条磁带上的归并段再均衡地分配到前 $k$ 条磁带上 (需要额外的I/O来分配)。
    4.  转到步骤 2) 进行下一趟合并，直到只有一个归并段为止。

#### 2. 多步归并排序 (Polyphase Merge Sort)

*   **特点**：每一步归并并**不一定**需要文件中的全部记录都参加。
*   **方法** (使用 $k+1$ 条磁带进行 $k$ 路归并)：
    *   巧妙地进行初始归并段在 $k$ 条带上的**不均匀分布**，使得任何一步 $k$ 路归并开始的时候，总有 $k$ 条带上有数据作为输入，且**恰好有一条磁带是空着的**，可以用它作为本步的输出带。
    *   当某一条输入带读完后，它就变成本轮的输出带，而原输出带（已写满归并结果）则成为下一轮的输入带之一。
*   **如何使初始归并段合理分布？**
    *   **倒推分析**
		**核心思想：** 我们从最终状态（所有记录合并为1个段）开始，一步步往回推，看在前一步需要什么样的段分布才能达到当前状态，同时保证每一步都满足多步归并的条件（k个输入带，1个空输出带，合并后一个输入带变空）。
		
		**以 k=3 (3路归并，需要 3+1=4 条磁带) 为例：**
		
		我们用 T1, T2, T3 作为潜在的输入带，T4 作为初始的空输出带。但实际上，在每一轮归并中，任何一条带都可能成为输出带。为了方便描述，我们假设每一“层”的分布是针对一个特定的输出带。
		
		**斐波那契序列 (k=3):**
		先列出3阶广义斐波那契数列（按你的定义 $F_j^{(k)} = 1, \text{for } 0 \le j \le k-1$）：
		*   $F_0^{(3)} = 1$
		*   $F_1^{(3)} = 1$
		*   $F_2^{(3)} = 1$
		*   $F_3^{(3)} = F_2 + F_1 + F_0 = 1+1+1 = 3$
		*   $F_4^{(3)} = F_3 + F_2 + F_1 = 3+1+1 = 5$
		*   $F_5^{(3)} = F_4 + F_3 + F_2 = 5+3+1 = 9$
		*   $F_6^{(3)} = F_5 + F_4 + F_3 = 9+5+3 = 17$
		*   ...以此类推
		
		**倒推过程：**
		
		我们用 `(t1, t2, t3, t4)` 表示四条磁带上的段数。星号 `*` 表示该磁带是本轮的输出带。
		
		*   **目标状态 (最终态 - 总段数 1，对应 $F_0^{(3)}$ 或某个初始斐波那契数，取决于如何定义级别)：**
		    *   假设最终归并段在 T1 上：`(1, 0, 0, 0*)` (T4碰巧是最后一次的输出带，但数据在T1)
		    *   或者更规范地，我们说在某一次归并后，只剩下1个段。
		
		*   **第 1 层 (倒数第1次归并 - 总段数 3，对应 $F_3^{(3)}$)：**
		    *   为了得到最终的 1 个段（比如在 T1 上），前一步必定是 T2, T3, T4 各有 1 个段，通过 3 路归并到 T1 上。
		    *   分布：`(0*, 1, 1, 1)`
		    *   这里，T1 是输出带。T2, T3, T4 各有1个段。合并1个新段到T1。T2, T3, T4 都变空。
		    *   该层合并了 `m_1 = 1` 个段。
		
		*   **第 2 层 (倒数第2次归并 - 总段数 5，对应 $F_4^{(3)}$)：**
		    *   目标是达到上一层的分布 `(0*, 1, 1, 1)`，其中 T1 是输出带。
		    *   现在假设这一轮 T2 是输出带 `( , 0*, , )`。
		    *   T1, T3, T4 是输入带。它们合并 `m_2` 个段到 T2。
		    *   合并后，T1 的段数要变成 0 (上一层 T1 作输出带时的状态)。所以合并前 T1 有 `0 + m_2` 个段。
		    *   合并后，T3 的段数要变成 1。所以合并前 T3 有 `1 + m_2` 个段。
		    *   合并后，T4 的段数要变成 1。所以合并前 T4 有 `1 + m_2` 个段。
		    *   而 `m_2` 的值等于上一层中，本轮输出带 T2 所需的段数，即 1。所以 `m_2 = 1`。
		    *   分布：T1 有 `0+1=1` 段, T3 有 `1+1=2` 段, T4 有 `1+1=2` 段。T2 是输出带。
		    *   即：`(1, 0*, 2, 2)`
		    *   该层合并了 `m_2 = 1` 个段。
		
		*   **第 3 层 (倒数第3次归并 - 总段数 9，对应 $F_5^{(3)}$)：**
		    *   目标是达到上一层的分布 `(1, 0*, 2, 2)`，其中 T2 是输出带。
		    *   现在假设这一轮 T3 是输出带 `( , , 0*, )`。
		    *   T1, T2, T4 是输入带。它们合并 `m_3` 个段到 T3。
		    *   合并后，T1 的段数要变成 1。所以合并前 T1 有 `1 + m_3` 个段。
		    *   合并后，T2 的段数要变成 0 (上一层 T2 作输出带时的状态)。所以合并前 T2 有 `0 + m_3` 个段。
		    *   合并后，T4 的段数要变成 2。所以合并前 T4 有 `2 + m_3` 个段。
		    *   `m_3` 等于上一层中，本轮输出带 T3 所需的段数，即 2。所以 `m_3 = 2`。
		    *   分布：T1 有 `1+2=3` 段, T2 有 `0+2=2` 段, T4 有 `2+2=4` 段。T3 是输出带。
		    *   即：`(3, 2, 0*, 4)`
		    *   该层合并了 `m_3 = 2` 个段。
		
		*   **第 4 层 (倒数第4次归并 - 总段数 17，对应 $F_6^{(3)}$)：**
		    *   目标是达到上一层的分布 `(3, 2, 0*, 4)`，其中 T3 是输出带。
		    *   现在假设这一轮 T4 是输出带 `( , , , 0*)`。
		    *   T1, T2, T3 是输入带。它们合并 `m_4` 个段到 T4。
		    *   合并后，T1 的段数要变成 3。所以合并前 T1 有 `3 + m_4` 个段。
		    *   合并后，T2 的段数要变成 2。所以合并前 T2 有 `2 + m_4` 个段。
		    *   合并后，T3 的段数要变成 0 (上一层 T3 作输出带时的状态)。所以合并前 T3 有 `0 + m_4` 个段。
		    *   `m_4` 等于上一层中，本轮输出带 T4 所需的段数，即 4。所以 `m_4 = 4`。
		    *   分布：T1 有 `3+4=7` 段, T2 有 `2+4=6` 段, T3 有 `0+4=4` 段。T4 是输出带。
		    *   即：`(7, 6, 4, 0*)`
		    *   该层合并了 `m_4 = 4` 个段。

		**总结与规律：**

		**所以，如果你有 17 个初始归并段 (即 $F_6^{(3)}$)，并且你想进行 3 路归并 (k=3)，那么一个理想的初始分布就是：**
		
		*   **磁带 T1：7 个段**
		*   **磁带 T2：6 个段**
		*   **磁带 T3：4 个段**
		*   **磁带 T4：0 个段 (作为第一个输出带)**
		
		这个分布 (7, 6, 4) 就是我们通过倒推得到的。这个过程保证了：
		1.  总是有 k=3 条带上有数据作为输入。
		2.  总是有 1 条磁带是空着的作为输出带。
		3.  当某一条输入带读完后（例如，在第一轮中，T3 上的 4 个段被读完），它就成为下一轮的输出带。而原输出带（T4，此时有4个新段）则成为下一轮的输入带之一。

		
| 层数 (L) | 输出带 | 输入带上的目标分布 (合并后)    | 本轮合并段数 (m_L)       | 输入带的初始分布 (合并前)             | 总段数 $F_{L+c}^{(3)}$ |
| :----- | :-- | :----------------- | :----------------- | :------------------------- | :------------------ |
| 1 (末态) | T1  | (T2:1, T3:1, T4:1) | $m_1=1$            | (T1:0\*, T2:1, T3:1, T4:1) | 3 ($F_3^{(3)}$)     |
| 2      | T2  | (T1:0, T3:1, T4:1) | $m_2=1$ (T2在L1的段数) | (T1:1, T2:0\*, T3:2, T4:2) | 5 ($F_4^{(3)}$)     |
| 3      | T3  | (T1:1, T2:0, T4:2) | $m_3=2$ (T3在L2的段数) | (T1:3, T2:2, T3:0\*, T4:4) | 9 ($F_5^{(3)}$)     |
| 4      | T4  | (T1:3, T2:2, T3:0) | $m_4=4$ (T4在L3的段数) | (T1:7, T2:6, T3:4, T4:0\*) | 17 ($F_6^{(3)}$)    |
        *   **注**：若由内部排序得到的初始归并段的总数不足 $F_j^{(k)}$，需加 **“虚段”** 补充。虚段可以集中在一条带上，也可以分布在多条带上。