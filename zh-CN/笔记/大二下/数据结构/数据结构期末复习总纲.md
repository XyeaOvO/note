### **数据结构期末复习总纲**

**总体复习建议：**

1.  **概念为本**：数据结构不仅仅是写代码，更重要的是理解每种结构的定义、特性以及它适用的场景。是什么？为什么？用在哪？
2.  **算法为核**：对于核心算法（如KMP、快排、Dijkstra等），不仅要理解其思想，还要能够**徒手写出伪代码**，并能**手动模拟执行过程**。考试很可能出大题让你模拟算法流程。
3.  **时空分析**：务必掌握所有主要算法的**时间复杂度**和**空间复杂度**（最好、最坏、平均情况）。这是衡量算法优劣的关键，也是必考点。
4.  **融会贯通**：学会比较不同数据结构的优劣。例如，顺序表与链表的对比，各种排序算法的对比，邻接矩阵与邻接表的对比等，这些都是常考的综合题。
5.  **真题演练**：找一些往年的题目或者课后作业题进行练习，尤其是算法设计题和综合应用题。

---

### **分章节重点复习大纲**

#### **第一章：绪论**

*   **核心概念**：
    *   数据、数据元素、数据项、数据结构的定义。
    *   **逻辑结构**与**物理结构（存储结构）** 的区别与联系。这是基础中的基础。
        *   逻辑结构：集合、线性、树形、图形。
        *   存储结构：顺序、链式、索引、散列。
*   **算法分析**：
    *   算法的五个基本特性：有穷性、确定性、可行性、输入、输出。
    *   **时间复杂度**和**空间复杂度**的计算。
        *   重点理解**大O表示法 (O)** 的含义。
        *   掌握基本语句、循环语句（特别是嵌套循环）的时间复杂度分析方法。PPT中的矩阵乘法例子是经典。

#### **第二章：线性表**

*   **核心概念**：线性表的定义和基本操作。
*   **两大实现方式的对比（重中之重）**：
    *   **顺序存储 (顺序表)**：
        *   **优点**：支持随机存取（`O(1)`）。
        *   **缺点**：插入和删除操作慢（平均`O(n)`），需要移动大量元素；空间需要预分配。
        *   重点：插入、删除操作的实现逻辑。
    *   **链式存储 (链表)**：
        *   **优点**：插入和删除操作快（`O(1)`），空间动态分配。
        *   **缺点**：只能顺序存取（`O(n)`），需要额外指针空间。
        *   **必会操作**：
            *   **单链表**：头插法、尾插法创建链表；按值/按位查找；在指定节点前后插入/删除节点。务必理解**头结点**的作用。
            *   **循环链表**和**双向链表**：理解其结构特点和相比单链表的优势。

#### **第三章：栈和队列**

*   **核心概念**：
    *   **栈 (Stack)**：后进先出 (LIFO)。理解栈顶、栈底，以及`push`、`pop`操作。
    *   **队列 (Queue)**：先进先出 (FIFO)。理解队头、队尾，以及`enqueue`、`dequeue`操作。
*   **重点实现**：
    *   **顺序栈/队列**：用数组实现，注意栈满和队空的判断条件。
    *   **循环队列 (Circular Queue)**：**高频考点！** 为什么需要循环队列（解决“假溢出”）？如何用数组和`front`、`rear`指针实现？队空和队满的判断条件（牺牲一个单元或设置`size`/`tag`标志位）必须熟练掌握。
    *   **链栈/链队**：理解其实现，特别是链队列需要同时有头尾指针，方便`O(1)`的入队和出队操作。
*   **应用**：
    *   栈的应用：表达式求值、括号匹配、**递归的实现原理**（系统栈的作用）。
    *   队列的应用：层序遍历、解决需要“先来先服务”的问题。

#### **第四章：串**

*   **核心概念**：串的定义，子串，主串。
*   **核心算法：模式匹配（重中之重）**
    *   **BF算法 (Brute-Force)**：理解其朴素思想，掌握其执行过程和`O(m*n)`的复杂度。
    *   **KMP算法**：**必考重点！**
        *   **思想**：主串指针`i`不回溯，通过移动模式串指针`j`来提高效率。
        *   **`next`数组**：核心！必须理解其定义，并能为一个给定的模式串**手动计算出next数组**。
        *   **`nextval`数组**：`next`数组的改进，理解其改进点和计算方法。
        *   掌握KMP算法的执行流程和`O(m+n)`的复杂度。

#### **第五章：数组和广义表**

*   **数组**：
    *   **地址计算**：重点掌握多维数组（特别是二维）按行优先或列优先存储时的地址计算公式。
    *   **矩阵压缩存储**：针对特殊矩阵（对称矩阵、三角矩阵、带状矩阵）的存储优化。
    *   **稀疏矩阵**：
        *   **三元组表**：理解其存储方式。
        *   **快速转置算法**：**高频考点**。理解其`O(n+t)`的复杂度，以及如何利用辅助数组实现。
        *   **十字链表**：理解其结构，如何方便地找到行和列的后继。
*   **广义表**：了解其定义、表头、表尾、深度的概念即可。

#### **第六章：树与二叉树**

*   **核心概念**：
    *   树的各种术语：结点、度、深度、森林等。
    *   **二叉树**：定义、五种基本形态。
    *   **满二叉树**与**完全二叉树**：**高频考点**，必须能准确区分。
    *   二叉树的性质：`n0 = n2 + 1`，深度与结点数的关系等。
*   **二叉树的遍历（重中之重）**：
    *   **先序、中序、后序、层序遍历**：必须能对给定的二叉树，徒手写出四种遍历序列。
    *   **递归与非递归实现**：理解递归的自然实现，同时掌握非递归（用栈实现前中后序，用队列实现层序）的算法思想。
    *   **由遍历序列确定二叉树**：**必考题型**。已知（先序+中序）或（后序+中序），能够唯一确定一棵二叉树。
*   **线索二叉树**：
    *   **目的**：利用空指针域存放前驱/后继信息。
    *   **概念**：理解ltag/rtag的含义，以及如何在中序线索树中找前驱和后继。
*   **哈夫曼树 (Huffman Tree)**：
    *   **概念**：最优二叉树，带权路径长度（WPL）最小。
    *   **构造算法**：**必须掌握**。每次选取权值最小的两棵树合并。
    *   **哈夫曼编码**：理解其是前缀编码，会为字符集构造哈夫曼编码。
*   **并查集 (Union-Find Sets)**：
    *   **应用**：判断等价类、连通性问题。
    *   **优化**：理解**按秩合并（或按大小合并）**和**路径压缩**这两种优化策略如何极大地提高了`Find`操作的效率。

#### **第七章：图**

*   **核心概念**：
    *   图的各种术语：顶点、边、有向/无向、权、网、度（入度/出度）、路径、环、连通图/强连通图、连通分量等。
*   **图的存储（重点）**：
    *   **邻接矩阵**：优缺点，适用于稠密图。
    *   **邻接表**：优缺点，适用于稀疏图。
    *   能够根据给定的图，画出其邻接矩阵和邻接表。
*   **图的遍历（重中之重）**：
    *   **深度优先搜索 (DFS)**：类似树的先序遍历，**需要用栈**（或递归）。
    *   **广度优先搜索 (BFS)**：类似树的层序遍历，**需要用队列**。
    *   必须能对给定的图，从指定顶点出发，手动模拟DFS和BFS的过程，并写出遍历序列。
*   **核心应用算法（必考大题）**：
    *   **最小生成树 (MST)**：
        *   **Prim算法**：从顶点出发，不断加点。理解其“加点”思想。
        *   **Kruskal算法**：按边权从小到大，不断加边。理解其“加边”思想和用**并查集**判断是否形成环路。
    *   **最短路径**：
        *   **Dijkstra算法**：单源最短路径，**不能处理负权边**。理解其每次选择“未访问集合”中路径最短的顶点进行扩展的贪心思想。
        *   **Floyd算法**：所有顶点对之间的最短路径，可以处理负权边（但不能有负权环），动态规划思想。
    *   **拓扑排序**：
        *   **应用**：AOV网，判断有向无环图(DAG)中活动的可行序列。
        *   **算法**：不断找出并删除入度为0的顶点。
    *   **关键路径**：
        *   **应用**：AOE网，估算工程最短时间。
        *   **概念**：事件最早/最晚发生时间(ve/vl)，活动最早/最晚开始时间(e/l)。
        *   **计算**：会根据公式计算这些值，并找出关键活动和关键路径。

#### **第八章：查找**

*   **线性结构查找**：顺序查找、折半查找（二分查找）。
*   **树形结构查找**：
    *   **二叉排序树 (BST)**：定义、查找、插入、删除操作。**删除操作是难点**，要分情况（叶子、单分支、双分支）。
    *   **平衡二叉树 (AVL树)**：**高频考点**。
        *   **目的**：解决BST退化问题。
        *   **平衡因子(BF)** 的概念。
        *   **四种旋转调整**：**LL、RR、LR、RL**。必须掌握如何判断失衡类型，并进行正确的旋转操作来恢复平衡。
    *   **B-树 / B+树**：
        *   **目的**：用于外存查找，减少I/O次数。
        *   理解m阶B-树的定义、查找、插入（结点分裂）、删除（结点合并/借位）的过程。
*   **散列表 (Hash Table)（重中之重）**：
    *   **思想**：通过散列函数直接计算存储地址。
    *   **散列函数构造**：除留余数法是重点。
    *   **冲突处理方法**：**必考**。
        *   **开放定址法**（线性探测、二次探测）。理解线性探测的“聚集”问题。
        *   **链地址法（拉链法）**。
    *   **查找性能**：理解平均查找长度(ASL)与**装填因子(α)** 的关系。

#### **第九、十章：排序**

*   **内部排序（重中之重）**：
    *   对以下每一种排序，都要掌握：**算法思想、复杂度（最好/最坏/平均）、稳定性、空间复杂度**。
    *   **插入排序**：直接插入、希尔排序。希尔排序是重点，理解其增量分组的思想。
    *   **交换排序**：冒泡排序、**快速排序**。
        *   **快速排序**：**必考算法**。分治思想的体现。核心是`Partition`（划分）操作。能手动模拟一趟划分。理解其复杂度为何平均是`O(n log n)`而最坏是`O(n²)`。
    *   **选择排序**：简单选择、**堆排序**。
        *   **堆排序**：**必考算法**。理解堆的定义（大顶堆/小顶堆）。掌握两个核心操作：**建堆**和**调整堆**。
    *   **归并排序**：分治思想，稳定，时间复杂度总是`O(n log n)`，但空间复杂度是`O(n)`。
    *   **基数排序**：非比较排序，桶排序思想，空间换时间。
*   **外部排序**：
    *   **核心思想**：多路归并排序，目标是**减少I/O次数**。
    *   **过程**：
        1.  **生成初始归并段**：利用内存进行内部排序，生成有序的子文件（顺串）。理解**置换-选择排序**如何能生成平均长度为2倍内存大小的归并段。
        2.  **多路归并**：将初始归并段进行合并。理解**败者树**在k路归并中的作用，是为高效地选出当前所有归并段中的最小（大）值。
        3.  **最佳归并树**：**哈夫曼树的应用**。为减少总的I/O，应使归并树的带权路径长度（WPL）最小。权为每个归并段的长度。

---

祝你期末考试顺利，取得好成绩！加油！