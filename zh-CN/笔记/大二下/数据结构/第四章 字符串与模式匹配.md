# 第四章 字符串与模式匹配

## 4.1 串的概念和基本操作

### 📜 基本概念

*   **串 (字符串 String)**：是由零个或多个字符组成的**有限序列**。通常记为 $s = 'a_1 a_2 \dots a_n'$ ($n \ge 0$)。
    *   串中的字符数目 $n$ 称为串的**长度 (Length)**。
    *   $n=0$ 时的串称为**空串 (Empty String)**，通常用 $\Phi$ 或 `""` 表示。
    *   由一个或多个空格组成的串称为**空格串 (Space String)**, 例如 `' '`, `'   '`。
*   **串的逻辑结构**：与线性表相似，区别在于串的数据对象限定为**字符**。
    *   $\boxed{串是特殊的线性表，其数据元素是单个字符。}$
*   **子串 (Substring) 与主串 (Main String)**：串中任意个**连续**的字符组成的子序列称为该串的**子串**。包含子串的串相应地称为**主串**。
    *   子串在主串中的**位置**通常是指子串的第一个字符在主串中的序号。
*   **串相等 (String Equality)**：当且仅当两个串的长度相等，并且它们对应位置的字符都相同时，这两个串才相等。

### 🧱 顺序串的定义 (C/C++ & 教材约定)

*   **C语言中**：通常用一个以 `\0` 结尾的字符数组来表示字符串。
*   **C++语言中**：除了C语言的数组方式外，还提供了 `std::string` 类来方便地操作字符串。
*   **教材约定 (顺序串 `SqString`)**：通常使用一个结构体来存储串，其中包含一个字符数组和一个表示串长度的整型变量。
    *   为了描述算法，有时会假设串的字符从数组下标 1 开始存储，而下标 0 用于存放串的当前长度（这是一种较老的约定，现代常用单独的 `length` 成员）。
    *   本章后续讨论的 `SqString` 结构定义通常如下：
        ```c
        #define MAX_STR_LEN 255 // 假设静态分配的最大长度
        typedef struct {
            char ch[MAX_STR_LEN + 1]; // 存储串字符，若用0号单元存长度，则+1；或字符从0开始存
            int length;               // 串的实际长度
        } SqString; // 顺序串类型
        ```

### ⚙️ 串的基本操作

串的操作通常以**整个串**作为操作对象。

1.  **赋值操作 `StrAssign(&T, chars)`**：将字符串常量 `chars` 赋值给串 `T`。
2.  **复制操作 `StrCopy(&T, S)`**：由串 `S` 复制得到串 `T`。
3.  **判空操作 `StrEmpty(S)`**：若 `S` 为空串，则返回 `true`，否则返回 `false`。
4.  **比较操作 `StrCompare(S, T)`**：若 `S > T`，则返回值 `>0`；若 `S = T`，则返回值 `=0`；若 `S < T`，则返回值 `<0`。(比较规则通常是字典序)
5.  **求串长操作 `StrLength(S)`**：返回串 `S` 的元素个数。
6.  **清空操作 `ClearString(&S)`**：将 `S`清为空串。
7.  **连接操作 `Concat(&T, S1, S2)`**：用 `T` 返回由 `S1` 和 `S2` 连接而成的新串。
8.  **求子串操作 `SubString(&Sub, S, pos, len)`**：用 `Sub` 返回串 `S` 的第 `pos` 个字符起长度为 `len` 的子串。
9.  **定位操作 `Index(S, T, pos)` (模式匹配)**：若主串 `S` 中存在与串 `T` 值相同的子串，则返回它在主串 `S` 中第 `pos` 个字符之后第一次出现的位置；否则函数值为0。
10. **替换操作 `Replace(&S, T, V)`**：用串 `V` 替换主串 `S` 中出现的所有与 `T` 相等的不重叠的子串。
11. **插入操作 `StrInsert(&S, pos, T)`**：在串 `S` 的第 `pos` 个字符之前插入串 `T`。
12. **删除操作 `StrDelete(&S, pos, len)`**：从串 `S` 中删除第 `pos` 个字符起长度为 `len` 的子串。

*   ✨ **核心区别**：
    *   线性表的基本操作通常以**单个元素**作为操作对象，如存取、插入、删除一个元素。
    *   串的基本操作通常以**串的整体**作为操作对象，如查找子串、连接串等。

## 4.2 串的存储结构

### 🔢 4.2.1 静态存储结构 (定长顺序存储)

即用一组地址连续的存储单元来存储串的字符序列。通常使用固定长度的数组。

1.  **非紧缩格式 (串空间 + 串长)**
    *   **定义**：如 `struct { char data[MAX_LEN_WORDS]; int length; }`，其中 `data` 数组的每个单元可能只存一个字符，但单元本身较大 (如一个机器字长16bit或32bit)。
    *   **特点**：当机器采用字编址（如16位或32位为一个单位）而一个字符只占8位时，这种方式会造成**空间浪费较多**。

2.  **紧缩格式 (串空间 + 串长)**
    *   **定义**：如 `typedef struct { char ch[MAX_STR_LEN]; int length; } SqString;`
        *   字符实际存储在 `ch[0]` 到 `ch[length-1]`。
    *   **特点**：存储器采用字节编址时，每个字符占用一个字节，**节省空间且操作方便**。若必须按字存取字符，则从一个字中分离出多个字符或合并多个字符到一个字中会增加时间开销。这是最常用的静态存储方式。

### 🔗 4.2.2 动态存储结构

1.  **块链存储方式 (Linked Chunks)** 👍
    *   **定义**：将串的字符序列存储在若干个不连续的存储块（结点）中，通过指针链接起来。每个结点可以存放一个或多个字符。
        ```c
        #define CHUNK_SIZE 4 // 每个块可以存放的字符数
        typedef struct ChunkNode {
            char ch[CHUNK_SIZE];
            struct ChunkNode *next;
        } ChunkNode;
        typedef struct {
            ChunkNode *head, *tail; // 指向链表的头和尾
            int curlength;          // 串的当前长度
        } LString; // 字符串的块链结构
        ```
    *   **特点**：
        *   操作灵活，串长可以动态变化。
        *   `CHUNK_SIZE` 的大小会影响存储效率和操作效率：
            *   `CHUNK_SIZE` 小：类似普通链表，指针域开销大，存储密度低。
            *   `CHUNK_SIZE` 大：分配大块内存可能困难，若串不满块则有空间浪费。
    *   **思考**：最后一个块可能不会存满。

2.  **堆结构存储方式 (Heap Allocation)** 👍
    *   **定义**：串值存储在程序可动态分配和释放的**堆存储区 (Heap)**。系统通常会维护一个大的连续存储空间作为串值的可利用空间。每个串通过一个指针指向其在堆中实际存储的字符序列。
    *   通常会有一个**符号表 (Symbol Table)** 或目录，记录串名、实际长度、以及在堆中的起始地址。
        ```
        // 概念性表示
        // 符号表 (String Descriptor Table)
        // | 串名 (ID) | 长度 (length) | 起始地址 (stadr) |
        // |-----------|---------------|-----------------|
        // |   "a"     |       8       |    address_A    |
        // |   "b"     |       6       |    address_B    |
        ```
        堆区 (Heap Memory):
        `... [A B O O K ...] ... [S T R I N G ...] ...`
        `    ^address_A         ^address_B`
    *   **特点**：
        *   通过串名（或描述符）存储映象访问串值。
        *   **动态分配存储空间**，对串长没有固定限制（受限于堆大小）。
        *   需要有效的**动态存储管理**机制，以回收废弃的旧串空间（垃圾回收）和为新串分配空间，避免内存碎片。

## 4.3 串的模式匹配 (Pattern Matching)

*   **定义**：
    在主串 $S$ 中寻找子串 $T$ (模式串) 第一次出现的位置。若找到，返回其在 $S$ 中的起始位置 (通常是第一个字符的序号，从1开始计数)；若未找到，返回0或一个特殊值。
*   **术语**：
    *   **主串 (Main String / Text)**: 通常用 `S` 或 `t` 表示，例如 $t = t_1 t_2 \dots t_n$。
    *   **模式串 (Pattern String / Pattern)**: 通常用 `P` 或 `p` 表示，例如 $p = p_1 p_2 \dots p_m$。
*   **约定**：在本节算法描述中，若无特别说明，字符串的**下标均从1开始**。

### 🐢 4.3.1 Brute-Force (BF) 算法 (朴素/蛮力算法)

*   **思想**：
    1.  从主串 `t` 的第一个字符开始 (`i=1`)，取出长度为 `m` (模式串 `p` 的长度) 的子串。
    2.  与模式串 `p` 进行逐个字符比较。
    3.  若完全匹配，则成功，返回 `i`。
    4.  若不匹配，则从主串 `t` 的下一个字符开始 (`i` 变为 `i+1`)，重复步骤 1-3。
    5.  直到主串 `t` 扫描完毕或找到匹配。

*   **算法描述 (1-based indexing)**：
    设主串 `t` 长度为 `n`，模式串 `p` 长度为 `m`。
    指针 `i` 扫描主串 `t` (从1到 `n-m+1`)，指针 `j` 扫描模式串 `p` (从1到 `m`)。
    ```
    function BF_Index(t, p):
      i = 1, j = 1
      n = length(t), m = length(p)
      while i <= n-m+1 AND j <= m:
        if t[i+j-1] == p[j]: // 字符匹配
          j = j + 1           // 继续比较下一个字符
        else:                 // 字符失配
          i = i + 1           // 主串指针后移一位，开始新一轮匹配
          j = 1               // 模式串指针回到开头
      if j > m:              // 匹配成功 (模式串所有字符都已比较完)
        return i              // 返回模式串在主串中的起始位置
      else:
        return 0              // 匹配失败
    ``` 
*   **复杂度分析** ⏱️：
    *   **最坏情况**：每次比较都在模式串的最后一个字符处失败（如主串 `aaaaaaaaab`，模式串 `aaab`）。
        比较次数约为 $(n-m+1) \times m$。
        时间复杂度为 $\boxed{O(n \times m)}$。
    *   **平均情况**：$O(n \times m)$。
    *   **缺点**：效率较低，主串指针 `i` 在失配时会进行**回溯**，导致重复比较。

## 🚀 4.4 KMP 算法 (Knuth-Morris-Pratt 算法)

*   **改进之处** ✨：
    在模式匹配过程中，主串的指针 $i$ 始终不回溯 ($i++$)，仅通过改变模式串的指针 $j$ 来使模式串向右“滑动”到一个合适的位置继续比较。
    算法复杂度可提高到 $\boxed{O(n+m)}$。

*   **核心思想**：当发生失配 `t[i] != p[j]` 时，我们希望利用已经匹配过的前缀 `p[1...j-1]` 的信息，找出这个前缀自身的一个**最长的真前缀**，这个真前缀同时也是 `p[1...j-1]` 的一个**后缀**。然后，将模式串向右滑动，使得这个最长真前缀与主串中刚匹配过的后缀对齐，模式串从该真前缀的下一个字符 (`p[k]`) 开始与 `t[i]` 进行比较。

*   **举例**：
    主串 `t`: `a b c d a b c d a b e g h` ($t_1 \dots t_{13}$)
    模式串 `p`: `a b c d a b e` ($p_1 \dots p_7$)
    假设在 `t[7]` (`c`) 与 `p[7]` (`e`) 比较时失配。
    已匹配部分是 `t[1...6]` == `p[1...6]` == `a b c d a b`。
    我们需要在 `p[1...6]` (`abcdab`) 中找最长相等的前后缀。
    `p[1...6]` 的前缀有: `a`, `ab`, `abc`, `abcd`, `abcda`
    `p[1...6]` 的后缀有: `b`, `ab`, `dab`, `cdab`, `bcdab`
    最长相等的是 `ab`，其长度为 2。
    所以，下次模式串应该滑动到 `p[1...2]` 对齐主串中已匹配的后缀 `t[5...6]` (也是 `ab`)。
    然后从 `p[2+1] = p[3]` (`c`) 开始与主串的 `t[7]` (`c`) 继续比较。此时 `i` (主串指针) 不变，`j` (模式串指针) 变为 `3`。

### 🔢 4.4.1 `next` 数组

*   `next` 数组是 KMP 算法的关键，它预处理模式串 `p`，记录了当 `p[j]` 与主串字符失配时，模式串指针 `j` 应该回溯到的下一个位置 `k`。
*   $\boxed{ \text{next}[j] = k }$ 的含义：
    当模式串中第 `j` 个字符 `p[j]` 与主串当前字符 `t[i]` 失配时，模式串应该向右滑动，使得模式串的第 `k` 个字符 `p[k]` 与 `t[i]` 对齐进行下一次比较。
    `k` 的值是这样确定的：在 `p[1 \dots j-1]` 中，存在一个最长的字符串 $S$，使得 $S$ 既是 `p[1 \dots j-1]` 的真前缀，又是 `p[1 \dots j-1]` 的后缀。`k` 就是这个字符串 $S$ 的长度加 1。(如果用 $k'$ 表示该长度，则 $k=k'+1$。或者，若 $k$ 直接表示新下标，则 $k$ 就是满足 $p_1 \dots p_{k-1} = p_{j-k+1} \dots p_{j-1}$ 的最大 $k$ 值。)

*   **幻灯片P19 `next[j]` 定义 (1起始下标 `j`, `next` 值为新的1起始下标 `k`)**:
    $\boxed{ \text{next}[j] = \begin{cases} 0 & \text{若 } j=1 \quad \text{(特殊标记, 表示p[1]失配, 主串指针i后移, j重置为1)} \\ \max \{k \mid 1 < k < j \text{ 且 } 'p_1 \dots p_{k-1}' = 'p_{j-k+1} \dots p_{j-1}' \} & \text{若这样的 } k \text{ 存在 (k是新j的值)} \\ 1 & \text{其他情况 (表示p[1...j-1]无相等前后缀, j重置为1与t[i]比较)} \end{cases} }$
    *   `p_1 \dots p_{k-1}` 是长度为 `k-1` 的前缀。
    *   `p_{j-k+1} \dots p_{j-1}` 是长度为 `k-1` 的后缀。
    *   `next[j]`的值 `k` 是下次比较时模式串 `p` 中应当对准主串 `t[i]` 的字符 `p[k]` 的下标。

*   **求 `next` 数组的算法 (`get_next`) (1起始下标 `p`, `next`)**:
    ```c
    void get_next(char p[], int m, int next[]) { // m 是 p 的长度
        int j = 1; // 当前正在处理其 next 值的 p中字符的下标
        int k = 0; // next[j] 的候选值, 也是当前匹配的前后缀的长度减1
                   // k 也指向前缀中可能与 p[j-1] 匹配的字符 p[k]
        next[1] = 0; // 第一个字符的 next 值总是 0

        while (j < m) { // 迭代计算 next[2] 到 next[m]
            if (k == 0 || p[j] == p[k]) { // 情况1: p[j] 与 p[k] 匹配, 或 k 为0
                j++;
                k++;
                next[j] = k; // p[1..j-1] 的最长相等前后缀长度为 k-1。所以 next 值是 k。
            } else { // 情况2: p[j] 与 p[k] 不匹配
                k = next[k]; // k 回溯到其自身的 next 值
            }
        }
    }
    ```
    *   此 `get_next` 计算的 `next[j]` 使得 `p[1...next[j]-1]` 是 `p[1...j-1]` 的最长真前缀且也是其后缀。当 `p[j]` 失配时，新的 `j` 变为 `next[j]`。
    *   **示例: `p = abab` (m=4)**
        1.  `j=1, k=0, next[1]=0`
        2.  `j=1 < 4`。 `k=0`。 `j++ (2), k++ (1)`。 `next[2]=1`。
        3.  `j=2 < 4`。 `p[2]='b'`, `p[k=1]='a'`。不匹配。 `k = next[k=1] = 0`。
        4.  `j=2 < 4`。 `k=0`。 `j++ (3), k++ (1)`。 `next[3]=1`。
        5.  `j=3 < 4`。 `p[3]='a'`, `p[k=1]='a'`。匹配。 `j++ (4), k++ (2)`。 `next[4]=2`。
        结果: `next` 数组 (1起始下标) 为 `next[1]=0, next[2]=1, next[3]=1, next[4]=2`。

### 🧩 4.4.2 KMP 算法描述

*   **算法流程 (1起始下标 `t`, `p`, `next`)**:
    `i` 是 `t` 的下标, `j` 是 `p` 的下标。
    `n` = `t` 的长度, `m` = `p` 的长度。
    ```c
    int KMP_Index(char t[], char p[], int next[]) {
        int i = 1, j = 1;
        int n_t = strlen_1_based(t); // 假设的1起始长度函数
        int m_p = strlen_1_based(p); // 假设的1起始长度函数

        while (i <= n_t && j <= m_p) {
            // j==0 是来自 next[1]=0 的特殊标记; 表示p[1]失配, 主串指针i前进, j尝试p[1]。
            // 或者, 当前 t[i] 与 p[j] 匹配。
            if (j == 0 || t[i] == p[j]) {
                i++;
                j++;
            } else { // 不匹配
                j = next[j]; // j 跳转到 next 数组指示的下一个候选位置
            }
        }

        if (j > m_p) { // 模式串 p 已完全匹配
            return (i - m_p); // 返回在 t 中的起始位置
        } else {
            return 0; // 未找到匹配
        }
    }
    ```

### 🔧 4.4.3 `nextval` 数组 (改进的 `next` 数组)

*   **`next` 数组的缺陷**：
    如果 `p[j]` 与 `t[i]` 失配，`j` 变为 `next[j]`。若此时 `p[next[j]]` 恰好等于 `p[j]`，那么 `p[next[j]]` 必然也与 `t[i]` 失配，这次比较就是多余的。
    *   例如: `p = aaaab`, `t = aaacaaaab`
        计算的 `next` 数组 (1起始): `next[1]=0, next[2]=1, next[3]=2, next[4]=3, next[5]=4`。
        目标 `nextval` (1起始): `nextval[1]=0, nextval[2]=0, nextval[3]=0, nextval[4]=0, nextval[5]=4`。

*   **`nextval` 数组**：是对 `next` 数组的优化。
    $\boxed{ \text{nextval}[j] = \begin{cases} 0 & \text{若 } j=1 \\ \text{nextval}[\text{next}[j]] & \text{若 } p[j] = p[\text{next}[j]] \\ \text{next}[j] & \text{若 } p[j] \neq p[\text{next}[j]] \end{cases} }$
    (这是一种从已求得的 `next` 数组推导 `nextval` 的方法)。

*   **求 `nextval` 数组的算法 (`get_nextval`)**:
    此算法直接计算 `nextval`，集成了“跳过冗余比较”的逻辑。
    ```c
    void get_nextval(char p[], int m, int nextval[]) { // m 是 p 的长度
        int j = 1; // 当前正在处理的 p中字符的下标
        int k = 0; // nextval[j] 的候选值, 也指向 p[k]
        nextval[1] = 0;

        while (j < m) {
            if (k == 0 || p[j] == p[k]) { // p[j] 与 p[k] 匹配, 或 k 为0
                j++;
                k++;
                if (p[j] != p[k]) { // 如果下一个字符 p[j] 与 p[k] 不同
                    nextval[j] = k;
                } else { // 如果 p[j] 与 p[k] 相同, 则跳过 k, 使用 nextval[k]
                    nextval[j] = nextval[k]; // 优化点
                }
            } else { // p[j] 与 p[k] 不匹配
                k = nextval[k]; // k 回溯到其自身的 nextval 值
            }
        }
    }
    ```

### 🚀 4.4.4 改进的 KMP 算法描述

*   与 4.4.2 中的 KMP 算法描述完全相同，只是将传入的 `next[]` 数组替换为 `nextval[]` 数组。
    ```c
    int KMP_Index_Improved(char t[], char p[], int nextval[]) {
        int i = 1, j = 1;
        int n_t = strlen_1_based(t); // 假设的1起始长度函数
        int m_p = strlen_1_based(p); // 假设的1起始长度函数
        while (i <= n_t && j <= m_p) {
            if (j == 0 || t[i] == p[j]) {
                i++; j++;
            } else {
                j = nextval[j]; // 此处使用 nextval
            }
        }
        if (j > m_p) return (i - m_p);
        else return 0;
    }
    ```

### ⏱️ 4.4.5 KMP 算法复杂度分析

*   **求 `next` 或 `nextval` 数组**：
    `get_next` / `get_nextval` 算法中，指针 `j` 从1到 `m-1` 单调递增。`k` 的增加次数不超过 `m-1` 次。`k` 的减少是通过 `k = next[k]` (或 `nextval[k]`)，每次减少都会使 `k` 变小，总的减少量不会超过总的增加量。因此，时间复杂度为 $\boxed{O(m)}$。
*   **模式匹配过程**：
    主串指针 `i` 不回溯，最多从1到 `n` 移动 `n` 次。模式串指针 `j` 的移动分为两种：
    1.  匹配成功 (`t[i] == p[j]`)：`j++`。`j` 的总增加次数不超过 `n` 次。
    2.  失配 (`t[i] != p[j]`)：`j = next[j]` (或 `nextval[j]`)。`j` 的值减小。`j` 的总减少量不会超过总的增加量。
    因此，匹配过程的时间复杂度为 $\boxed{O(n)}$。
*   **总时间复杂度**：$\boxed{O(n+m)}$。

### 📝 作业 (示例)

1.  分别求出下列模式串的 `next` 和 `nextval` 数组值：
    *   `t1 = 'aaab'`
    *   `t2 = 'abcabaa'`
    *   `t3 = 'adabbadada'`
2.  **重复子串问题**：重复子串的含义是由一个或多个连续相等的字符组成的子串 (不重叠)。现有某个串用一维字符数组 `s` 存储，长度为 `n`，设计算法求 `s` 的最长重复子串的长度。
    `int LongestString(char s[], int n)` // 函数返回所求长度