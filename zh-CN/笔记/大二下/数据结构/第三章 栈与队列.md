# 第三章 栈与队列

## 第一部分：栈 (Stack)

### 3.1 栈的定义与特性

*   **定义** 🧐：
    栈（Stack）是一种特殊的线性表，其插入和删除操作被限定在表的同一端进行，该端被称为栈顶（Top），另一端则被称为栈底（Bottom）。
    栈中的数据元素遵循**后进先出 (Last-In, First-Out, LIFO)** 的原则。
*   **逻辑结构图**：
    *   **入栈 (Push)**：向栈顶添加元素。
    *   **出栈 (Pop)**：从栈顶移除元素。
    *   **栈顶 (Top)**：允许进行插入和删除操作的一端。
    *   **栈底 (Bottom)**：固定的一端。
*   **基本术语**：
    *   **空栈 (Empty Stack)**：不含任何数据元素的栈。

### 3.2 栈的基本运算

对栈的主要操作包括：

1.  `InitStack(&S)`: 构造一个空栈 S。
2.  `StackEmpty(S)`: 判断栈 S 是否为空。若为空，返回 `true`；否则返回 `false`。
3.  `Push(&S, x)`: 入栈操作。若栈 S 未满，则将元素 `x` 压入栈顶。
4.  `Pop(&S, &x)`: 出栈操作。若栈 S 非空，则将栈顶元素弹出，并用 `x` 返回其值。
5.  `GetTop(S, &x)`: 取栈顶元素。若栈 S 非空，则用 `x` 返回栈顶元素，栈顶指针不变。
6.  `ClearStack(&S)`: 置空栈操作。将栈 S 置为空栈。
7.  `StackLength(S)`: 求栈中元素个数。

### 3.3 顺序栈 (Sequential Stack)

*   **3.3.1 存储结构**
    *   定义：顺序栈是利用一组地址连续的存储单元（通常是数组）来依次存放从栈底到栈顶的数据元素，同时附设一个指针 `top` 指示栈顶元素在数组中的位置。
    *   `top` 指针约定：
        *   通常，`top` 指示当前栈顶元素的数组下标。
        *   栈空条件：$\boxed{top == -1}$。(此时若执行退栈操作，则发生**下溢 (Underflow)**)
        *   栈满条件：$\boxed{top == MaxSize - 1}$ (设数组大小为 `MaxSize`)。(此时若执行进栈操作，则发生**上溢 (Overflow)**)
    *   图示：
        ```
          S (array)
        | a0 | a1 | ... | ai | ... | max-1 |
          ^    ^          ^
          0    1          i (top)
        栈底            栈顶
        ```

*   **3.3.2 实现方式**
    *   **方式一 (简单数组和top变量)**：
        ```c++
        #define MaxSize 100 // 假设栈的最大容量
        typedef int ElemType; // 假设元素类型为int
        ElemType S[MaxSize];
        int top = -1;
        ```
    *   **方式二 (结构体封装)**：
        ```c++
        typedef int ElemType; // 假设元素类型为int
        typedef struct {
            ElemType *Array; // 动态分配的数组基址
            int top;         // 栈顶指针
            int capacity;    // 栈的容量
        } StackRecord, *Stack;
        ```

*   **3.3.3 基本运算实现 (基于结构体封装)**
    *   **初始化 (`CreateStack`)**：
        ```c++
        Stack CreateStack(int max) {
            Stack S = (Stack)malloc(sizeof(StackRecord));
            if (S == NULL) { /* exit("out of space"); */ return NULL; }
            S->Array = (ElemType*)malloc(sizeof(ElemType) * max);
            if (S->Array == NULL) { /* exit("out of space"); */ free(S); return NULL; }
            S->capacity = max;
            S->top = -1;
            return S;
        }
        ```
    *   **入栈 (`Push`)**：
        ```c++
        void Push(Stack S, ElemType X) {
            if (S->top == S->capacity - 1) {
                /* exit("Full!"); 处理栈满 */
                return;
            }
            S->Array[++(S->top)] = X; // top先加1，再存入元素
        }
        ```
    *   **出栈 (`Pop`)**：
        ```c++
        ElemType Pop(Stack S) { // 通常Pop会返回元素值
            if (S->top == -1) {
                /* exit("empty!"); 处理栈空 */
                return /* 错误标记 */;
            }
            return S->Array[(S->top)--]; // 先取元素，top再减1
        }
        ```
    *   **销毁 (`DisposeStack`)**：
        ```c++
        void DisposeStack(Stack S) {
            if (S != NULL) {
                free(S->Array);
                free(S);
            }
        }
        ```

*   **3.3.4 共享栈 (两栈共享空间)** 👍
    *   思想：利用一个数组的两端作为两个栈的栈底，两个栈顶指针相向增长。
    *   存储结构图：
        ```
        Array: | S0_base ... S0_top | <-- gap --> | S1_top ... S1_base |
               0                  top[0]       top[1]               m-1
        ```
    *   栈0：`top[0]` 从 -1 开始向右增长。
    *   栈1：`top[1]` 从 m (数组末端) 开始向左增长。
    *   栈0空：`s.top[0] == -1`
    *   栈1空：`s.top[1] == m` (m为数组上界加1, 即如果数组下标0到m-1, 则m是容量)
    *   栈满条件：$\boxed{s.top[0] + 1 == s.top[1]}$ (两个栈顶相遇)
    *   优点：提高了存储空间的利用率，只有在整个数组空间都被占满时才发生上溢。

*   **3.3.5 多栈共享与栈溢出处理 (栈浮动技术 - 概述)**
    *   思想：当多个栈共享一个连续存储空间时，若某个栈发生上溢，而整个存储空间尚有空闲，则可以通过移动其他栈来为溢出的栈腾出空间。这称为“栈浮动技术”。
    *   涉及为每个栈维护栈底指针 `b[i]` 和栈顶指针 `t[i]`。
    *   当第 `i` 个栈满 (`t[i] == b[i+1]`) 时，调用 `StackFull(i)` 尝试重新分配空间。
    *   这种技术较为复杂，需要动态调整各栈的边界。

### 3.4 链栈 (Linked Stack)

*   **3.4.1 存储结构**
    *   定义：链栈是采用链式存储结构实现的栈。通常用单链表表示，以链表的**头端作为栈顶**。
    *   结点结构：
        ```c++
        typedef int ElemType; // 假设元素类型为int
        typedef struct SNode {
            ElemType data;
            struct SNode *next;
        } SNode, *LinkStack; // LinkStack 通常是指向栈顶结点的指针
        ```
        如果使用头结点，则 `LinkStack` 是指向头结点的指针，栈顶元素是头结点的后继。
        *   `top` 指针（即链栈指针）始终指向栈顶元素结点。
    *   栈顶：链表的第一个实际数据结点（或头结点之后一个结点）。
    *   栈空条件：`top == NULL` (不带头结点) 或 `S->next == NULL` (带头结点 `S`)。
    *   一般**无栈满问题**，空间可动态扩展。

*   **3.4.2 基本运算实现 (带头结点的单链栈)**
    *   **入栈 (`Push`)** (头插法)：
        ```c++
        // S 是指向头结点的指针
        void Push(LinkStack S, ElemType X) {
            SNode *tmp = (SNode*)malloc(sizeof(SNode));
            if (tmp == NULL) { /* exit("out of space"); */ return; }
            tmp->data = X;
            tmp->next = S->next; // 新结点指向原栈顶
            S->next = tmp;       // 头结点指向新栈顶
        }
        ```
    *   **出栈 (`Pop`)** (头删法)：
        ```c++
        // S 是指向头结点的指针
        ElemType Pop(LinkStack S) { // 通常Pop会返回元素值
            SNode *firstCell;
            ElemType topElem;
            if (S->next == NULL) { /* exit("empty!"); */ return /* 错误标记 */; }
            firstCell = S->next;
            topElem = firstCell->data;
            S->next = firstCell->next; // 头结点指向新的栈顶 (原第二个元素)
            free(firstCell);
            return topElem;
        }
        ```

### 3.5 栈的应用

*   **3.5.1 递归的实现** (重要) 🧠
    *   **递归定义**：一个函数、过程或数据结构在其定义或说明中直接或间接调用自身。
    *   **适合递归的场合**：
        1.  问题定义是递归的 (如阶乘、斐波那契数列)。
        2.  问题解法按递归方式描述 (如 Hanoi 塔)。
        3.  数据结构是递归定义的 (如树、广义表)。
    *   **递归要素**：
        1.  **基本项 (Base Case)**：递归调用的出口，不再需要递归就能直接求解。
        2.  **归纳项 (Recursive Step)**：将问题分解为规模更小的、与原问题具有相同性质的子问题，并通过递归调用来解决。
    *   **递归工作原理 (系统栈)**：函数调用时，系统会使用一个称为“调用栈”或“系统栈”的内存区域来管理函数调用的信息。每次函数调用（包括递归调用）会在栈中创建一个**栈帧 (Stack Frame)** 或**活动记录 (Activation Record)**，用于存储：
        1.  **返回地址**：调用结束后应返回到主调函数中的位置。
        2.  **实在参数 (Actual Parameters)**：传递给被调函数的值。
        3.  **局部变量 (Local Variables)**：被调函数内部定义的变量。
        4.  **寄存器状态** (有时)：需要保存的CPU寄存器内容。
        当函数返回时，其对应的栈帧从栈中弹出，控制权交还给主调函数。
    *   **递归转非递归**：
        1.  **简单迭代**：对于某些简单的递归（如求阶乘），可以直接用循环结构代替。
            ```c++
            // 递归求阶乘
            int Factorial_rec(int n) {
                if (n == 0) return 1;
                else return n * Factorial_rec(n - 1);
            }
            // 非递归求阶乘
            int Factorial_iter(int n) {
                int result = 1;
                for (int i = 1; i <= n; i++) result *= i;
                return result;
            }
            ```
        2.  **消除尾递归**：尾递归是指递归调用是函数体中最后执行的操作。尾递归可以较容易地转换为迭代形式，通常用循环代替递归调用，参数更新模拟递归参数变化。
        3.  **用栈模拟递归 (通用方法)** ✨：
            *   当一个递归过程比较复杂，或不是尾递归时，可以使用一个用户定义的栈来模拟系统调用栈的行为。
            *   **基本思想**：
                *   在模拟的递归调用前，将必要的信息（如参数、局部变量的当前状态、下一步应执行的代码位置/返回点）压入用户栈。
                *   进入“被调用”部分。
                *   当模拟的递归调用返回时，从用户栈中弹出信息，恢复现场，并根据返回点继续执行。

*   **3.5.2 表达式求值**
    *   **前提假设**：表达式语法正确，结束符为 `#`。
    *   **算法思想**：使用两个栈：
        *   `OPTR` 栈：存放运算符。
        *   `OPND` 栈：存放操作数或运算中间结果。
    *   **步骤概述 (中缀表达式求值)**：
        1.  `OPTR` 栈底放入 `#` (最低优先级)。
        2.  依次读入表达式字符：
            *   **操作数**：直接压入 `OPND` 栈。
            *   **运算符**：
                *   与 `OPTR` 栈顶运算符比较优先级。
                *   若当前运算符优先级 > `OPTR.top` 优先级，则当前运算符入 `OPTR` 栈。
                *   若当前运算符优先级 <= `OPTR.top` 优先级，则从 `OPTR` 弹出栈顶运算符，从 `OPND` 弹出两个操作数进行运算，结果压回 `OPND` 栈；然后再次比较当前运算符与新的 `OPTR.top`。
                *   `(` 优先级最高入栈，但与其他运算符比较时优先级最低。
                *   `)` 遇到它时，将 `OPTR` 栈中 `(` 之上的运算符依次弹出运算，直到 `(` 出栈。
        3.  当读到 `#` 且 `OPTR` 栈只剩 `#` 时，`OPND` 栈中唯一元素即为结果。
    *   **示例**：`5+3*(7-2)+11#`

*   **3.5.3 括号匹配** ✅
    *   应用：检验表达式中的括号是否配对出现。
    *   算法：遍历表达式，遇到左括号 (`(`, `[`, `{`) 则入栈；遇到右括号则检查栈顶：
        *   若栈空或栈顶不是对应的左括号，则不匹配。
        *   若匹配，则栈顶左括号出栈。
    *   表达式遍历完后，若栈为空，则匹配成功；否则不匹配。

*   **3.5.4 函数调用** (已在递归中说明，系统栈实现)

*   **3.5.5 合法的出栈序列 (卡特兰数 Catalan's Number)** ❔
    *   问题：对于 $n$ 个不同元素按固定顺序（如 $1, 2, ..., n$）入栈，有多少种不同的合法出栈序列？
    *   结论：共有 $\boxed{C_n = \frac{1}{n+1}\binom{2n}{n} = \frac{(2n)!}{n!(n+1)!}}$ 种。
    *   这是组合数学中的一个著名序列。
    *   **出栈序列的性质**：若 $P_1, P_2, ..., P_n$ 是一个合法的出栈序列，则不可能存在 $i < j < k$ 使得 $P_j < P_k < P_i$。

## 第二部分：队列 (Queue)

### 3.6 队列的定义与特性

*   **定义** 🧐：
    队列（Queue）是一种特殊的线性表，它只允许在表的一端进行插入操作（称为队尾 Rear），而在表的另一端进行删除操作（称为队头 Front）。
    队列中的数据元素遵循**先进先出 (First-In, First-Out, FIFO)** 的原则。
*   **逻辑结构图**：
    ```
    <-- 出队 (Dequeue) -- [a0, a1, ..., an-1] <-- 入队 (Enqueue) --
                          ^                   ^
                         队头 (Front)        队尾 (Rear)
    ```

*   **基本术语**：
    *   **队头 (Front)**：允许删除元素的一端。
    *   **队尾 (Rear)**：允许插入元素的一端。
    *   **空队列 (Empty Queue)**：不含任何数据元素的队列。

### 3.7 队列的基本运算

对队列的主要操作包括：

1.  `InitQueue(&Q)`: 构造一个空队列 Q。
2.  `QueueEmpty(Q)`: 判断队列 Q 是否为空。若为空，返回 `true`；否则返回 `false`。
3.  `EnQueue(&Q, x)`: 入队操作。若队列 Q 未满，则将元素 `x` 加入队尾。
4.  `DeQueue(&Q, &x)`: 出队操作。若队列 Q 非空，则将队头元素删除，并用 `x` 返回其值。
5.  `GetHead(Q, &x)`: 取队头元素。若队列 Q 非空，则用 `x` 返回队头元素，队头指针不变。
6.  `ClearQueue(&Q)`: 置空队列操作。
7.  `QueueLength(Q)`: 求队列中元素个数。


### 3.8 顺序队列 (Sequential Queue)

*   **3.8.1 存储结构与 "假溢出" 问题**
    *   定义：用一组地址连续的存储单元（数组）存放队列中的元素，并设两个指针 `front` 和 `rear` 分别指示队头元素和队尾元素的位置。
    *   约定：
        *   `front` 指向队头元素。
        *   `rear` 指向队尾元素的**下一个**位置（或队尾元素本身，约定不同实现略有差异）。
    *   **"假溢出" (False Overflow)**：当 `rear` 指针到达数组上界后，即使数组中仍有空闲空间（因 `front` 指针已前移），也无法再入队。

*   **3.8.2 循环队列 (Circular Queue)** 👍
    *   **目的**：为了克服顺序队列的“假溢出”现象，将数组看作首尾相接的环形空间。
    *   **存储结构**：一维数组 `Q.Array`，队头指针 `Q.front`，队尾指针 `Q.rear`。
    *   **指针约定**：
        *   `Q.front`：指向队头元素的**前一个**位置。
        *   `Q.rear`：指向队尾元素的位置。
        *   `Q.size`：记录队列中元素个数。
        *   `Q.Capacity`：队列的总容量 (数组大小)。
    *   **队空条件**：$\boxed{Q.front == Q.rear}$ 或 $\boxed{Q.size == 0}$。
    *   **队满条件** (牺牲一个单元)：$\boxed{(Q.rear + 1) \% Q.Capacity == Q.front}$。
        *   或者使用 `Q.size` 辅助判断：队满时 $\boxed{Q.size == Q.Capacity}$。
    *   **入队操作**：
        1.  判断是否队满。
        2.  `Q.rear = (Q.rear + 1) % Q.Capacity;`
        3.  `Q.Array[Q.rear] = x;`
        4.  `Q.size++;` (如果使用 size)
    *   **出队操作**：
        1.  判断是否队空。
        2.  `Q.front = (Q.front + 1) % Q.Capacity;`
        3.  `x = Q.Array[Q.front];`
        4.  `Q.size--;` (如果使用 size)
    *   **计算队列长度** (不使用 `size` 字段，且牺牲一个单元时)：
        $\boxed{(Q.rear - Q.front + Q.Capacity) \% Q.Capacity}$
    *   **优点**：有效地利用了存储空间，避免了“假溢出”。

### 3.9 链队列 (Linked Queue)

*   **3.9.1 存储结构**
    *   定义：链队列是采用链式存储结构实现的队列。通常用单链表表示，需要两个指针：`front` 指向队头结点，`rear` 指向队尾结点。
    *   结点结构：
        ```c++
        typedef int ElemType;
        typedef struct QNode {
            ElemType data;
            struct QNode *next;
        } QNode, *QueuePtr;

        typedef struct {
            QueuePtr front; // 队头指针
            QueuePtr rear;  // 队尾指针
        } LinkQueue;
        ```
    *   **带头结点 vs 不带头结点**：
        *   **带头结点**：`front` 指向头结点，`rear` 指向链表的最后一个数据结点（队尾）。队空时 `front == rear`。
        *   **不带头结点**：`front` 指向第一个数据结点，`rear` 指向最后一个数据结点。队空时 `front == NULL` (且 `rear == NULL`)。
    *   队空条件 (带头结点时)：`Q.front == Q.rear`。
    *   一般**无队满问题**。

*   **3.9.2 基本运算实现 (带头结点的链队列)**
    *   **初始化**：
        ```c++
        void InitQueue(LinkQueue &Q) {
            Q.front = Q.rear = (QueuePtr)malloc(sizeof(QNode)); // 创建头结点
            if (!Q.front) { /* exit error */ }
            Q.front->next = NULL;
        }
        ```
    *   **入队 (`EnQueue`)** (尾插法)：
        ```c++
        void EnQueue(LinkQueue &Q, ElemType x) {
            QueuePtr s = (QueuePtr)malloc(sizeof(QNode));
            if (!s) { /* exit error */ }
            s->data = x;
            s->next = NULL;
            Q.rear->next = s; // 新结点链到原队尾之后
            Q.rear = s;       // rear 指向新的队尾
        }
        ```
    *   **出队 (`DeQueue`)** (头删法)：
        ```c++
        ElemType DeQueue(LinkQueue &Q, ElemType &x) {
            if (Q.front == Q.rear) { /* return error QueueEmpty */ return /*错误标记*/; }
            QueuePtr p = Q.front->next; // p 指向第一个数据结点
            x = p->data;
            Q.front->next = p->next;   // 头结点指向原第二个数据结点
            if (Q.rear == p) {         // 若队列中只有一个元素，删除后变空
                Q.rear = Q.front;
            }
            free(p);
            return x;
        }
        ```

*   **3.9.3 仅用尾指针的循环链队列**
    *   思想：使用一个**循环单链表**表示队列，只用一个指针 `rear` 指向队尾元素。
    *   队头元素：`rear->next` (如果链表非空)。
    *   入队：在 `rear` 之后插入新元素，并更新 `rear` 指向新元素。
    *   出队：删除 `rear->next` 所指的元素。
    *   这种结构巧妙地利用了循环特性。

### 3.10 队列的应用

*   **3.10.1 广度优先搜索 (Breadth-First Search, BFS)** 🗺️
    *   图和树的遍历算法，从起始点开始，逐层向外扩展访问。队列用于存储待访问的邻接点。
*   **3.10.2 操作系统中的应用** 💻
    *   **作业调度**：管理等待CPU的进程队列。
    *   **缓冲区管理**：如打印队列，数据在发送和接收速度不匹配时暂存。
*   **3.10.3 用两个栈实现一个队列** 🤔
    *   需要两个栈：`stack1` (用于入队) 和 `stack2` (用于出队)。
    *   **入队 (`EnQueue(x)`)**：
        1.  直接将 `x` 压入 `stack1`。
    *   **出队 (`DeQueue()`)**：
        1.  如果 `stack2` 为空，则将 `stack1` 中的所有元素依次弹出并压入 `stack2`。
        2.  如果 `stack2` 仍为空（说明原队列为空），则队列空。
        3.  否则，从 `stack2` 弹出一个元素。
    *   这样，`stack1` 相当于输入缓冲区，`stack2` 相当于输出缓冲区，元素的顺序在从 `stack1` 到 `stack2` 的过程中被反转，从而实现了 FIFO。
        *(参考 OCR Page 37 问题, Page 38 解答)*

### 3.11 双端队列 (Deque)

*   **3.11.1 定义**
    *   $\boxed{双端队列（Double-Ended Queue, Deque）是一种允许在两端进行插入和删除操作的线性表。}$
    *   即队头和队尾均可进行入队和出队操作。
        *(参考 OCR Page 46)*
*   **3.11.2 类型**
    *   **输入受限的双端队列**：一端允许插入和删除，另一端只允许删除 (或只允许插入，视具体限制)。
    *   **输出受限的双端队列**：一端允许插入和删除，另一端只允许插入 (或只允许删除)。
        *(参考 OCR Page 47)*
    *   若限定双端队列从某个端点插入的元素只能从该端点删除，则双端队列蜕变为两个栈底相邻接的栈。
*   **3.11.3 实现 (基于循环数组)**
    *   类似于循环队列，但需要支持四种操作：队头入队、队头出队、队尾入队、队尾出队。
    *   例如，从队尾删除 (`delqueue (cycqueue Q)` - OCR Page 49)：
        *   若队空 (`Q.front == Q.rear`)，出错。
        *   `temp = Q.data[Q.rear];` (假设 `rear` 指向队尾元素)
        *   `Q.rear = (Q.rear - 1 + MAX) % MAX;` (队尾指针前移)
    *   例如，从队头插入 (`enqueue (cycqueue Q, elemtp x)` - OCR Page 50)：
        *   若队满 (`(Q.front - 1 + M) % M == Q.rear` - 假设`front`指向队头前一位置)，出错。
        *   `Q.data[Q.front] = x;`
        *   `Q.front = (Q.front - 1 + M) % M;` (队头指针前移)