---
create: 2025-04-12 18:54
---
# 第五章 数组和广义表 📚

本章主要介绍两种重要的数据结构：数组和广义表。我们将探讨它们与线性表的关系、存储方式、基本运算以及一些特殊应用（如矩阵压缩）。

## 5.1 数组与线性表的关系及运算 🔗

### 数组作为线性表的推广

*   **核心思想**：任何数组 `A` 都可以看作一个线性表 $\boxed{A = (a_1, a_2, \dots, a_i, \dots, a_n)}$。
*   **维度扩展**：
    *   对于**二维数组**（例如 $m \times n$），可以看作一个线性表，其每个元素 $a_i$ (代表第 $i$ 行) 本身是一个一维数组。
    *   对于**三维数组**，可以看作一个线性表，其每个元素是一个二维数组。
    *   推广到 **n 维数组**，可以看作一个线性表，其每个元素是一个 $(n-1)$ 维数组。

**示例 (二维数组)**：
$$ A_{m \times n} = \begin{pmatrix} a_{11} & a_{12} & \dots & a_{1n} \\ a_{21} & a_{22} & \dots & a_{2n} \\ \vdots & \vdots & \ddots & \vdots \\ a_{m1} & a_{m2} & \dots & a_{mn} \end{pmatrix} $$
可以视为 $m$ 个行向量（一维数组）组成的线性表。

### 数组的特点

1.  **数据类型统一**：数组中各元素都具有统一的数据类型。
2.  **邻接关系**：可以认为，一个 $d$ 维数组的非边界元素具有 $d$ 个直接前趋和 $d$ 个直接后继。
3.  **结构固定**： $\boxed{\text{数组维数和各维度的界限一旦确定，数据元素的个数和元素之间的关系就不再改变}}$。这使得数组特别适合于**顺序存储**。
4.  **索引确定**：每组（有效的）下标都唯一确定数组中的一个元素值。

### 数组的基本操作

数组上的基本操作相对简单：

1.  **存取（读/写）**： $\boxed{\text{给定一组下标，取得或修改相应的数据元素值}}$。这是数组最核心的操作，由于顺序存储结构的存在，可以实现随机存取。
2.  （通常不涉及结构修改，如插入删除，因为这会破坏结构固定性）

## 5.2 数组的顺序存储结构 💾

由于数组结构固定，最常用且最自然的存储方式是**顺序存储**，即用一组地址连续的存储单元存放数组元素。

### 一维数组的存储

假设一维数组定义为 `元素类型 a[L_1 .. U_1]`（这里使用教材的 1 基址示例 `a[1..n]`），基地址（第一个元素的地址）为 $b$，每个元素占用 $c$ 个存储单元。

*   元素 $a[i]$ 的存储地址计算公式：
    $$ \boxed{ \text{loc}(a[i]) = b + (i - 1) \times c } $$
*   **线性地址公式**：可以写成 $\text{loc}(a[i]) = C_0 + C_1 \times i$，其中 $C_1 = c$，$C_0 = b - c$。

### 二维数组的存储

对于二维数组 `元素类型 a[L_1..U_1][L_2..U_2]`（教材示例 `a[1..m][1..n]`），内存中元素排列通常有两种方式：

1.  **行优先存储 (Row-Major Order)**：按行的顺序依次存储元素。先存第 1 行，再存第 2 行，以此类推。这是 **C/C++/Pascal** 等语言采用的方式。
    *   元素 $a[i, j]$ 的地址计算公式 ($1 \le i \le m, 1 \le j \le n$)：
        $$ \boxed{ \text{loc}(a[i, j]) = b + [(i - 1) \times n + (j - 1)] \times c } $$
    *   **线性地址公式**：$\text{loc}(a[i, j]) = C_0 + C_1 \times i + C_2 \times j$，其中 $C_2 = c$, $C_1 = n \times c$, $C_0 = b - n \times c - c$。

2.  **列优先存储 (Column-Major Order)**：按列的顺序依次存储元素。先存第 1 列，再存第 2 列，以此类推。这是 **Fortran** 语言采用的方式。
    *   元素 $a[i, j]$ 的地址计算公式 ($1 \le i \le m, 1 \le j \le n$)：
        $$ \text{loc}(a[i, j]) = b + [(j - 1) \times m + (i - 1)] \times c $$

### 多维数组的存储

以**三维数组** `元素类型 A[L_1..U_1][L_2..U_2][L_3..U_3]`（教材示例 `A[1..r][1..m][1..n]`）按**行优先**存储为例：

*   元素 $A[i, j, k]$ 的地址计算公式 ($1 \le i \le r, 1 \le j \le m, 1 \le k \le n$)：
    $$ \boxed{ \text{Loc}[i, j, k] = b + [(i-1) \times m \times n + (j-1) \times n + (k-1)] \times c } $$

推广到 **d 维数组** `元素类型 a[L_1..U_1]...[L_d..U_d]`，按行优先存储（即下标从右向左变化最快）：

*   令每一维的长度为 $n_k = U_k - L_k + 1$。
*   元素 $a[i_1, i_2, \dots, i_d]$ 的地址计算公式（以 1 为基址简化，实际需考虑下界 $L_k$）：
    $$ \text{loc}(a[i_1, \dots, i_d]) = b + \left[ (i_1-1) \prod_{k=2}^d n_k + (i_2-1) \prod_{k=3}^d n_k + \dots + (i_{d-1}-1) n_d + (i_d-1) \right] \times c $$
*   **通用线性地址公式**：
    $$ \boxed{ \text{loc}(a[i_1, \dots, i_d]) = C_0 + C_1 i_1 + C_2 i_2 + \dots + C_d i_d } $$
    其中系数 $C_k$ 可以根据存储顺序和各维长度计算得出。例如，对于行优先存储（1基址）：
    $C_d = c$
    $C_{t-1} = C_t \times n_t \quad (1 < t \le d)$
    $C_0 = b - \sum_{k=1}^d C_k$ （如果基址是1）
    （更通用的 $C_0$ 需要考虑各维下界 $L_k$）

**重要特性**： $\boxed{\text{数组是一种随机存取结构}}$，因为任何元素的地址都可以通过下标直接计算得出，访问时间与元素位置无关，为 $O(1)$。

**例题**：`元素类型 a[3..7][0..9][1..6][5..10]`，每个元素占 8 单元，求行优先下 `loc(a[6, 3, 3, 7])`？
*   维数 $d=4$。
*   下界 $L_1=3, L_2=0, L_3=1, L_4=5$。
*   上界 $U_1=7, U_2=9, U_3=6, U_4=10$。
*   各维长度 $n_1=5, n_2=10, n_3=6, n_4=6$。
*   元素大小 $c=8$。
*   基地址 $b = \text{loc}(a[3, 0, 1, 5])$。
*   目标下标 $i_1=6, i_2=3, i_3=3, i_4=7$。
*   地址计算（行优先，考虑下界）：
    $$ \text{loc}(a[i_1, i_2, i_3, i_4]) = b + \left[ (i_1-L_1) n_2 n_3 n_4 + (i_2-L_2) n_3 n_4 + (i_3-L_3) n_4 + (i_4-L_4) \right] \times c $$
    $$ \text{loc}(a[6, 3, 3, 7]) = b + \left[ (6-3) \times 10 \times 6 \times 6 + (3-0) \times 6 \times 6 + (3-1) \times 6 + (7-5) \right] \times 8 $$
    $$ = b + [ 3 \times 360 + 3 \times 36 + 2 \times 6 + 2 ] \times 8 $$
    $$ = b + [ 1080 + 108 + 12 + 2 ] \times 8 $$
    $$ = b + [ 1202 ] \times 8 = b + 9616 $$

### C语言中的多维数组

1.  **本质**：C 语言的多维数组本质上是“数组的数组”。例如 `char carrot[10][20]` 是一个包含 10 个元素的数组，每个元素是 `char[20]` 类型的数组。
2.  **存储**：C 语言采用 $\boxed{\text{行优先顺序}}$ 存储。
3.  **访问**：访问 `carrot[i][j]` 时，编译器解释为指针运算 `*(*(carrot + i) + j)`。
4.  **函数传递**：
    *   一维数组可直接作为实参。
    *   传递多维数组给函数时， $\boxed{\text{必须提供除第一维之外的所有维度的长度}}$，以便编译器能正确计算地址。例如，形参可以是 `int a[][3][5]`，但不能是 `int a[][][]`。

### 示例：数组循环右移

**问题**：将 $n$ 个元素的数组 $A[0.. n-1]$ 循环右移 $m$ 位 ($1 \le m \le n$)，要求空间复杂度 $O(1)$。
**例如**：`A = [1, 2, 3, 4, 5, 6]`，右移 2 位，变为 `[5, 6, 1, 2, 3, 4]`。

**思路 (三次反转法)**：
1.  将数组看作两部分：前 $n-m$ 个元素 $X = A[0.. n-m-1]$，后 $m$ 个元素 $Y = A[n-m.. n-1]$。数组表示为 $XY$。
2.  目标是得到 $YX$。
3.  利用字符串反转性质 $(XY)^R = Y^R X^R$，其中 $R$ 表示反转。
4.  我们可以通过 $(X^R Y^R)^R = (Y^R)^R (X^R)^R = YX$ 来实现。
5.  **算法步骤**：
    *   ① 反转 $X$ 部分：`Reverse(A, 0, n-m-1)` 得到 $X^R Y$。
    *   ② 反转 $Y$ 部分：`Reverse(A, n-m, n-1)` 得到 $X^R Y^R$。
    *   ③ 整体反转数组：`Reverse(A, 0, n-1)` 得到 $(X^R Y^R)^R = YX$。

**反转函数 `Reverse(数组 A, 起始下标 i, 结束下标 j)`**：
```
过程 Reverse (数组 A, 整数 i, 整数 j)
  整数 k, 临时变量 tmp;
  对于 k 从 0 到 (j - i + 1) / 2 - 1 // 注意整除
    tmp = A[i + k];
    A[i + k] = A[j - k];
    A[j - k] = tmp;
  结束对于
结束过程
```
$\boxed{\text{空间复杂度为 } O(1)}$，因为只使用了常数个额外变量。时间复杂度为 $O(n)$。

## 5.3 矩阵的压缩存储 🤏

对于一些具有特殊分布规律的矩阵（如大量元素相同或为零），为了节省存储空间，可以采用**压缩存储**。压缩存储的基本思想是： $\boxed{\text{只存储矩阵中特定的（通常是非零或关键）元素}}$，并建立这些元素与其在原矩阵中下标 $(i, j)$ 之间的映射关系。

### 对称矩阵

*   **特点**：$n \times n$ 方阵 $A$，满足 $a_{ij} = a_{ji}$ ($1 \le i, j \le n$)。
*   **存储方法**：只需存储主对角线及其以下（或以上）的元素，即下三角区（或上三角区）。
*   **存储空间**：共需存储 $\boxed{\frac{n(n+1)}{2}}$ 个元素。
*   **映射关系 (以存储下三角区按行优先为例)**：将下三角区的元素 $a_{ij}$ ($i \ge j$) 存入一维数组 `sa[0..n(n+1)/2 - 1]`（假设 0 基址）或 `sa[1..n(n+1)/2]`（1基址）。
    *   对于 $a_{ij}$ ($i \ge j$)，其前面有 $i-1$ 行，这些行共有 $1+2+\dots+(i-1) = \frac{(i-1)i}{2}$ 个元素。在第 $i$ 行中，它是第 $j$ 个元素（因为 $j$ 从 1 开始）。
    *   所以，以 **1 基址** 的 `sa` 数组存储 $a_{ij}$ ($i \ge j$) 的下标 $k$ 为：
        $$ \boxed{ k = \frac{i(i-1)}{2} + j } $$
    *   访问元素时：若 $i \ge j$，用上述公式计算 $k$；若 $i < j$，则访问 $a_{ji}$，即计算 $k = \frac{j(j-1)}{2} + i$。

### 三角矩阵

*   **特点**：对角线以下（或以上）的所有元素均为**常数** $C$。
    *   **下三角矩阵**：$i < j$ 时 $a_{ij} = C$。
    *   **上三角矩阵**：$i > j$ 时 $a_{ij} = C$。
*   **存储方法**：存储对角线及非 $C$ 部分的元素，再加上一个共享的常数 $C$。
*   **存储空间**：共需存储 $\boxed{\frac{n(n+1)}{2} + 1}$ 个元素。
*   **映射关系 (以存储下三角矩阵 $a_{ij}$ ($i \ge j$) + 一个 $C$ 为例，1基址)**：将 $a_{ij}$ ($i \ge j$) 按行优先存入 `sa[1..n(n+1)/2]`，将常数 $C$ 存入 `sa[n(n+1)/2 + 1]`。
    *   访问 $a_{ij}$：若 $i \ge j$，计算 $k = \frac{i(i-1)}{2} + j$，访问 `sa[k]`。
    *   若 $i < j$，访问 `sa[n(n+1)/2 + 1]` (即常数 $C$ 的位置)。

好的，我们来修正关于“按行存储”部分的描述，保持前半部分不变：

### 带状矩阵

*   **特点**：$n \times n$ 方阵，所有非零元素都集中在以主对角线为中心的带状区域内。设**带宽**为 $L$（通常为奇数），即 $a_{ij} \ne 0$ 仅当 $|i-j| \le p = (L-1)/2$。例如：
* ![](Pic/Pasted%20image%2020250414115802.png)
*   **存储方法**：只存储带状区域内的元素。
    1.  **按对角线存储**：将从左上到右下的各条对角线依次存储。共需约 $n \times L$ 个空间。
        *   设对角线编号 $il = i - j$，范围从 $-p$ 到 $p$。
        *   设列索引 $jl = j$ (或行索引 $i$ 作为第二个维度)。
        *   可以将二维下标 $(i, j)$ 映射到存储数组 $(il, jl)$ 或 $(il, i)$。
        *   例如，使用二维数组 `D[0..L-1][0..n-1]`，将 $a_{ij}$ 存入 `D[i-j+p][j-1]`。
    2.  **按行存储 (Row Storage)**：
        *   **思想**: 将每一行 $i$ 中，位于带状区域内的元素 $a_{ij}$（即满足 $|i-j| \le p$ 且 $1 \le j \le n$ 的元素）紧凑地存储。
        *   **常用存储结构**: 使用一个固定的 $n \times L$ 的二维数组（例如 `B[0..n-1][0..L-1]`）。`B` 的第 `i-1` 行用于存储原矩阵第 $i$ 行带内的元素。对于行 $i$ 来说，即使其带内的某些列 $j$ (如 $j=i-p$) 超出矩阵边界 ($j<1$ 或 $j>n$)，对应的存储位置仍然被分配，但可以填充特殊值（如0）或在计算时通过检查 $j$ 的范围来跳过。
        *   **空间复杂度**:
            *   采用 $n \times L$ 数组时，空间复杂度为 $O(nL)$。
            *   精确存储带内元素所需的空间量为 $\sum_{i=1}^{n} (\min(n, i+p) - \max(1, i-p) + 1)$，这个值通常小于 $nL$，尤其当 $L$ 相对 $n$ 较大时。
        *   **映射公式 (对应 $n \times L$ 存储)**: 假设使用 $n \times L$ 的空间，并按行优先将其视为一维数组，则元素 $a_{ij}$ (1-based) 的**1-based** 索引 $k$ 为：
            $$ k = (i-1)L + (j - i + p) + 1 $$
            *   这里 $p=(L-1)/2$ 是半带宽。

### 稀疏矩阵

*   **特点**：矩阵中绝大多数元素为零（或同一个常数）。
*   **压缩存储原则**： $\boxed{\text{只存储非零元素的值及其位置（行、列下标）}}$。
*   **缺点**：通常会 $\boxed{\text{丧失随机存取功能}}$。

#### 5.3.4.1 三元组顺序表

*   **思想**：用一个线性表（顺序表）存储所有非零元素的**三元组 (行号, 列号, 值)**。
*   **结构定义**：
    ```
    常量 u = {矩阵中非零元素最大个数}; // 预估容量

    结构体 元组节点 (TupleNode) {
      整数 i, j; // 行号, 列号 (1基址)
      元素类型 v; // 非零元素值
    };

    结构体 稀疏矩阵 (sparmattp / TSMatrix) {
      整数 m, n, t; // 矩阵总行数, 总列数, 非零元个数
      元组节点 data[1..u]; // 存储三元组的数组 (通常按行号优先，同行号按列号排序)
    };
    ```
*   **优点**：简单，节省大量空间。
*   **缺点**：存取元素需要查找（通常是顺序查找或二分查找，如果已排序），失去 $O(1)$ 随机访问。矩阵运算（如转置、加法、乘法）效率不高。

**示例：矩阵转置**

*   **算法1 (普通转置)**：$O(n \times t)$
    *   创建新的转置矩阵结构 `b`（行列数互换）。
    *   遍历原矩阵 `a` 的每一列 `col` (从 1 到 `a.n`)。
    *   对于每一列 `col`，再遍历 `a` 的三元组表 `a.data` (从 1 到 `a.t`)。
    *   如果找到 `a.data[p].j == col`，则将 `(a.data[p].j, a.data[p].i, a.data[p].v)` 加入 `b` 的三元组表。
    *   效率低，因为对 `a.data` 进行了 `a.n` 次扫描。

*   **算法2 (快速转置)**：$\boxed{O(n + t)}$
    *   **核心思想**：一次遍历 `a.data`，直接确定每个元素在转置矩阵 `b.data` 中的最终位置。
    *   **辅助数组**：
        *   `num[1..a.n]`：记录 `a` 中每一列的非零元素个数。
        *   `cpot[1..a.n]`：记录 `a` 中每一列的第一个非零元素在 `b.data` 中的应有的起始位置 (1基址)。
    *   **步骤**：
        1.  **计算 `num`**：遍历 `a.data` 一次，统计每列非零元个数。时间 $O(t)$。
        2.  **计算 `cpot`**：根据 `num` 数组计算每列在 `b.data` 中的起始位置。`cpot[1] = 1`；`cpot[col] = cpot[col-1] + num[col-1]` ($2 \le \text{col} \le a.n$)。时间 $O(n)$。
        3.  **放置元素**：再次遍历 `a.data` (设当前元素为 `a.data[p]`)。
            *   找到它所属的列 `col = a.data[p].j`。
            *   它在 `b.data` 中的位置是 `q = cpot[col]`。
            *   将转置后的三元组 `(col, a.data[p].i, a.data[p].v)` 存入 `b.data[q]`。
            *   更新该列的下一个可用位置：`cpot[col] = cpot[col] + 1`。
            *   时间 $O(t)$。

#### 5.3.4.2 十字链表

*   **思想**：为每个非零元素创建一个结点，同时将**同一行**的非零元链接成一个链表，将**同一列**的非零元链接成另一个链表。是一种**邻接表**的变形。
*   **优点**：方便矩阵的运算（如乘法），插入删除操作比三元组表灵活。
*   **结构**：
    *   **元素结点 (OLNode)**：
        *   `行号 (row)`, `列号 (col)`
        *   `值 (value)`
        *   `指向同行下一个非零元的指针 (right)`
        *   `指向同列下一个非零元的指针 (down)`
    *   **头结点数组**：需要两个头结点数组（或一个统一的）。
        *   **行头指针数组 `rhead[1..m]`**：`rhead[i]` 指向第 $i$ 行的第一个非零元结点。
        *   **列头指针数组 `chead[1..n]`**：`chead[j]` 指向第 $j$ 列的第一个非零元结点。
        *   所有行头指针构成一个链表，所有列头指针构成一个链表。通常设置一个总的**矩阵头结点 `Hm`** 来统一管理行列头指针。
    *   **头结点结构**：可以复用元素结点结构，或者专门设计。通常包含指向下一个头结点的指针（形成循环链表）。
![](Pic/Pasted%20image%2020250426213728.png)
*   **建立十字链表算法思想**：
    1.  读入矩阵行数 $m$ 和列数 $n$。
    2.  创建总头结点 `hm`，创建 $2 * max(m, n)$ 个行/列头结点 H（或分开创建 $m$ 个行头、$n$ 个列头），并将它们链接成循环链表（例如通过头结点的 `next` 指针）。
    3.  循环读入非零元素的三元组 $(r, c, v)$。
    4.  为 $(r, c, v)$ 创建一个新的元素结点 `p`。
    5.  在第 $r$ 行的链表中找到合适的插入位置（按列号升序），将 `p` 插入。需要找到前驱结点 `q`，使得 `q->col < c` 且 `q->right->col > c`（或 `q->right` 为空）。然后 `p->right = q->right`, `q->right = p`。
    6.  在第 $c$ 列的链表中找到合适的插入位置（按行号升序），将 `p` 插入。需要找到前驱结点 `q`，使得 `q->row < r` 且 `q->down->row > r`（或 `q->down` 为空）。然后 `p->down = q->down`, `q->down = p`。
    7.  重复步骤 3-6 直到所有非零元处理完毕。

## 5.4 广义表的定义和表示方法 📜

### 基本概念

*   **定义**： $\boxed{\text{广义表（Generalized List, GList）是由 n (n ≥ 0) 个元素组成的有限序列}}$。
    $$ LS = (d_1, d_2, \dots, d_n) $$
*   **元素类型**：广义表的元素可以是 **原子 (Atom)** 或 **子表 (Sublist)**。
    *   **原子**： $\boxed{\text{逻辑上不可再分解的数据元素}}$（如整数、字符等）。
    *   **子表**： $\boxed{\text{本身也是一个广义表}}$。
*   **递归定义**：广义表是递归定义的。

### 与线性表的关系

1.  $\boxed{\text{若广义表 LS 中的元素全为原子，则 LS 退化为一个线性表}}$。
2.  线性表是广义表的**特例**。
3.  广义表是线性表的**推广**，允许元素本身也是一个列表结构。

### 相关术语

*   **表长 (Length)**： $\boxed{\text{广义表中所含第一层元素的个数}}$。
    *   `A = ()` 的长度为 0。
    *   `B = (a, ())` 的长度为 2 (元素 `a` 和 `()` )。
    *   `C = ((a,b), c, d)` 的长度为 3 (元素 `(a,b)`, `c`, `d`)。
    *   `D = (a, (a, (a, ...)))` 的长度为 2 (元素 `a` 和 `(a, (...))` )。
*   **表深度 (Depth)**： $\boxed{\text{广义表中括号嵌套的最大层数}}$。原子深度为 0，空表 `()` 深度为 1。
    *   `A = ()` 的深度为 1。
    *   `B = (a, ())` 的深度为 2 (因为 `()` 深度为 1)。
    *   `C = ((a,b), c, d)` 的深度为 2 (因为 `(a,b)` 深度为 1)。
    *   `D = (a, D)` 递归表的深度为 $\boxed{\infty}$ (无穷)。
*   **表头 (Head)**： $\boxed{\text{非空广义表的第一个元素}}$。可以是原子或子表。
    *   `Head(B)` 是 `a`。
    *   `Head(C)` 是 `(a,b)`。
    *   `Head(D)` 是 `a`。
*   **表尾 (Tail)**： $\boxed{\text{非空广义表中除第一个元素外，由其余元素构成的（子）广义表}}$。表尾**必定**是一个广义表（可能是空表）。
    *   `Tail(B)` 是 `(())`。
    *   `Tail(C)` 是 `(c, d)`。
    *   `Tail(D)` 是 `(D)` 即 `((a, (a, ...)))`。

### 重要性质：头尾分解

$\boxed{\text{任何一个非空广义表 } LS = (a_1, a_2, \dots, a_n) \text{ 均可唯一地分解为表头 } Head(LS) = a_1 \text{ 和表尾 } Tail(LS) = (a_2, \dots, a_n)}$。

**示例**：`D = (E, F)` where `E = ((a, b, c))` and `F` is an atom/list.
*   `Head(D) = E = ((a, b, c))`
*   `Tail(D) = (F)`
*   `Head(E) = (a, b, c)`
*   `Tail(E) = ()`
*   `Head((a, b, c)) = a`
*   `Tail((a, b, c)) = (b, c)`
*   ... and so on.

### 图形表示

![](Pic/Pasted%20image%2020250426151334.png)
*   用 $\boxed{\bigcirc}$ (圆圈) 表示**表结点** (代表一个广义表)。
*   用 $\boxed{\square}$ (方块) 表示**原子结点**。
*   **表结点** 引出的指针指向构成该表（第一层）的各个元素（原子或子表）。
*   **递归表** 在图形上表现为**有环**结构，例如 `D = (a, D)`。
*   **共享子表** (再入表) 在图形上表现为**有结点被多个指针指向**，例如 `L = (A, B)` 如果 A 和 B 共享某个子表。

### 广义表结构的分类

1.  **纯表 (Pure List)**：不存在共享子表，也不存在递归。其图形表示为**树**结构。
2.  **再入表 (Re-entrant List)**：允许结点共享（即存在子表被多个表引用）。其图形表示为**有向无环图 (DAG)**。
3.  **递归表 (Recursive List)**：允许递归定义（即表中包含指向自身的引用）。其图形表示为**有向有环图**。

$\boxed{\text{关系：递归表 } \supset \text{ 再入表 } \supset \text{ 纯表 } \supset \text{ 线性表}}$

## 5.5 广义表的存储结构 🏗️

广义表的元素类型不统一（原子或子表），且长度和深度可变，不适合用简单的顺序存储。通常采用**链式存储**。

### 5.5.1 头尾链表形式

*   **思想**：直接利用广义表的 `Head` 和 `Tail` 递归性质来设计存储结构。
*   **结点结构 (GNode)**：
    *   **标志域 `tag`**：区分是原子结点还是表结点。
        *   $\boxed{\text{tag = 0 (ATOM): 原子结点}}$
        *   $\boxed{\text{tag = 1 (LIST): 表结点}}$
    *   **值域 `union`**：
        *   若 `tag == ATOM`：存储原子值的 `data` 域。
        *   若 `tag == LIST`：存储两个指针的 `ptr` 域：
            *   `hp` (Head Pointer)： $\boxed{\text{指向表示表头的广义表的指针}}$。
            *   `tp` (Tail Pointer)： $\boxed{\text{指向表示表尾的广义表的指针}}$。

```
类型定义枚举 {原子=0, 列表=1} 元素标记类型;

结构体广义表结点 (GLNode) {
  元素标记类型 tag;
  联合体 {
    元素类型 data;                 // 原子结点的值域
    结构体 {                       // 表结点的值域 (指针域)
      指向 GLNode 的指针 hp, tp;
    } ptr;
  } // 结束联合体
};

类型定义指向 GLNode 的指针 GList; // GList 是指向结点的指针
```

*   **存储表示**：
    *   空表 `()` 表示为 `NULL` 指针。
    *   非空表由一个 `tag=1` 的表结点表示，其 `hp` 指向表头结构，`tp` 指向表尾结构。
    *   原子由一个 `tag=0` 的原子结点表示。
*   **特点**：
    *   容易区分原子和子表。
    *   容易实现 `Head` 和 `Tail` 操作。
    *   能清晰反映表的层次结构。
    *   表的长度等于顶层通过 `tp` 指针串联起来的表结点数量。

### 5.5.2 扩展的线性链表形式（孩子兄弟表示法）

*   **思想**：将广义表的树形（或图形）结构用类似**树的孩子兄弟表示法**来存储。
*   **结点结构 (GNode)**：
    *   **标志域 `tag`**：同上（ATOM=0, LIST=1）。
    *   **值域 `union`**：
        *   若 `tag == ATOM`：存储原子值的 `data` 域。
        *   若 `tag == LIST`：存储一个指针 `hp` (Head Pointer)。 $\boxed{hp \text{ 指向该子表的第一个元素}}$。
    *   **指针域 `tp` (Tail Pointer / Next Pointer)**： $\boxed{\text{指向同一层次的下一个元素结点}}$（即兄弟结点）。

```
类型定义枚举 {原子=0, 列表=1} 元素标记类型;

结构体广义表结点 (GLNode) {
  元素标记类型 tag;
  联合体 {
    原子类型 data;                 // 原子结点的值域
    指向 GLNode 的指针 hp;           // 表结点的指针域，指向子表第一个元素
  } // 结束联合体
  指向 GLNode 的指针 tp;           // 指向同一层的下一个元素 (兄弟)
};

类型定义指向 GLNode 的指针 GList;
```

*   **存储表示**：
    *   通常带有一个**头结点**（`tag=1` 的表结点），其 `hp` 指向广义表的第一个元素，`tp` 通常为 `NULL`（或者用于链接其他列表）。
    *   子表的存储：表结点的 `hp` 指向子表的第一个元素结点。
    *   同一层元素通过 `tp` 指针链接起来。
*   **特点**：
    *   与树的孩子兄弟表示法直接对应。
    *   `hp` 指针相当于指向**孩子**，`tp` 指针相当于指向**兄弟**。
    *   原子结点对应**叶子结点**，表结点对应**非叶子结点**。
    *   存储密度可能比头尾链表形式更高（少用一个指针域，但在表结点处值域被指针占用）。

## 5.6 广义表的递归算法 🔄

广义表的递归定义使其非常适合使用**递归算法**来处理。处理广义表问题的基本思路通常是：

1.  **分解**：将问题分解为对表头和表尾的操作。
2.  **递归**：对表头（如果它是子表）和表尾（它总是子表）递归地解决子问题。
3.  **合并/处理**：合并子问题的结果或在递归过程中进行处理。
4.  **基准情况**：确定递归的终止条件（通常是处理空表或原子）。

**约定**：以下示例假设处理的广义表是**非递归**且**无共享子表**（即纯表/树形结构）。

### 示例一：求广义表的深度

*   **思路**：
    1.  分解：一个非空广义表的深度，取决于其所有第一层元素（原子或子表）的最大深度。
    2.  递归：
        *   如果元素是原子，其深度为 0。
        *   如果元素是子表，递归求该子表的深度。
    3.  合并：广义表的深度 = $\max(\text{所有第一层元素的深度}) + 1$。
    4.  基准情况：
        *   $\boxed{\text{空表 } () \text{ 的深度为 1}}$。
        *   $\boxed{\text{原子 的深度为 0}}$。

*   **算法实现 (头尾链表形式)**：
    ```
    函数 GlistDepth(列表 L) 返回 整数 {
      如果 L 为空 则 返回 1; // 空表深度为 1
      如果 L->tag == 原子 则 返回 0; // 原子深度为 0

      整数 max_dep = 0; // 记录子表深度的最大值
      指向结点类型的指针 pp = L; // 从表头开始遍历

      // 遍历表L的所有元素 (通过表尾指针 tp)
      循环 当 pp 不为空 {
        // 取当前元素的表头 (L->ptr.hp) 进行递归
        // 注意：实际应是 pp->ptr.hp
        整数 dep = GlistDepth(pp->ptr.hp);
        如果 dep > max_dep 则 max_dep = dep;

        // 移动到下一个元素 (通过表尾指针)
        pp = pp->ptr.tp;
      } 结束循环

      返回 max_dep + 1; // 列表深度 = max(子表深度) + 1
    }
    ```

*   **算法实现 (扩展线性链表形式带头结点)**：
    ```
    函数 GLDepth(指向结点指针 g) 返回 整数 { // g 是指向头结点的指针
      // 注意: 此实现假设 g 初始指向头结点, 且原子作为参数传入时返回 0
      // 更好的实现应区分头结点和普通结点

      如果 g->tag == 原子 则 返回 0; // 如果传入原子，返回 0

      整数 max_dep = 0, dep;
      指向结点指针 p = g->hp; // p 指向第一个元素

      如果 p == 空 则 返回 1; // 空表深度为 1

      循环 当 p != 空 { // 遍历所有兄弟元素
        如果 p->tag == 列表 { // 如果当前元素是子表
          dep = GLDepth(p); // 递归求子表深度 (传入子表结点)
          如果 dep > max_dep 则 max_dep = dep;
        }
        // 如果是原子，其深度贡献为 0，无需更新 max_dep
        p = p->tp; // 移动到下一个兄弟元素
      } 结束循环

      返回 max_dep + 1; // 列表深度 = max(子表深度) + 1
    }
    ```

### 示例二：复制广义表

*   **思路**：
    1.  分解：复制一个广义表需要复制它的表头和表尾。
    2.  递归：
        *   如果表头是原子，直接复制原子值。
        *   如果表头是子表，递归复制该子表。
        *   递归复制表尾（表尾总是一个广义表）。
    3.  合并：创建一个新的表结点，将其 `hp` 指向复制好的表头，`tp` 指向复制好的表尾。
    4.  基准情况：
        *   $\boxed{\text{复制空表 } () \text{ 得到的结果是空表 } NULL}$。
        *   $\boxed{\text{复制原子：创建一个新的原子结点并复制其值}}$。

*   **算法实现 (头尾链表形式)**：
    ```
    过程 CopyGList(引用 目标列表 T, 源列表 L) 返回 布尔值 {
      如果 L 为空 {
        T = 空; // 复制空表
        返回 真;
      } 否则 {
        // 创建新结点 T
        申请内存给 T;
        如果 内存申请失败 则 返回 假;

        T->tag = L->tag; // 复制标志

        如果 L->tag == 原子 {
          T->data = L->data; // 复制原子值
        } 否则 { // L 是表结点
          // 递归复制表头
          布尔值 head_ok = CopyGList(T->ptr.hp, L->ptr.hp);
          如果 head_ok 为假 则 { 释放 T 内存; 返回 假; }

          // 递归复制表尾
          布尔值 tail_ok = CopyGList(T->ptr.tp, L->ptr.tp);
          如果 tail_ok 为假 则 {
            // 注意：需要递归释放已复制的 T->ptr.hp
            // 简单的处理是假设内存总是足够，或者增加错误处理
            释放 T 内存; // 简化处理
            返回 假;
          }
        }
        返回 真;
      }
    }
    ```
