---
create: 2025-03-11 22:42
---
#  3.5 DFT 的应用：用 DFT 计算线性卷积 🚀

#### 1. 背景：线性时不变（LTI）系统与线性卷积

对于一个 LTI 系统，其输出 $y(n)$ 是输入信号 $x(n)$ 与系统单位冲激响应 $h(n)$ 的**线性卷积**：

$$ y(n) = x(n) * h(n) = \sum_{k=-\infty}^{\infty} x(k)h(n-k) $$

如果 $x(n)$ 和 $h(n)$ 是有限长序列，例如 $x(n)$ 长度为 N，$h(n)$ 长度为 M，则线性卷积定义为：

$$ y_l(n) = x(n) * h(n) = \sum_{k=0}^{N-1} x(k)h(n-k) $$

线性卷积结果 $y_l(n)$ 的长度为 $L_{out} = N + M - 1$。

**挑战**：当序列长度 N 和 M 很大时，直接计算线性卷积的运算量非常大（大约需要 $N \times M$ 次乘法和加法）。我们需要更快速的计算方法！

#### 2. DFT 与循环卷积的关系

我们知道，两个序列的 DFT 乘积对应于它们时域的**循环卷积**，而不是线性卷积。

设 $X(k)$ 和 $H(k)$ 分别是 $x(n)$ 和 $h(n)$ 的 N 点 DFT。则：

$$ \text{IDFT}[X(k)H(k)] = x(n) \circledast_N h(n) $$

其中 $\circledast_N$ 表示 N 点循环卷积，周期序列卷积后取主值，定义为：

$$ x(n) \circledast_N h(n) = \sum_{m=0}^{N-1} x(m) h((n-m) \pmod N) = \left[ \sum_{m=0}^{N-1} x(m) h((n-m))_N \right] R_N(n) $$

这里的 $(n-m) \pmod N$ 表示取模运算，体现了循环移位的特性。

**关键思想**：我们能否利用 DFT/FFT 的高效计算能力（FFT 算法可以将 DFT 的计算复杂度从 $O(N^2)$ 降低到 $O(N \log N)$）来计算**线性卷积**？答案是可以的，但需要理解线性卷积和循环卷积的关系。

#### 3. 线性卷积与循环卷积的关系 🔗

假设序列 $x(n)$ 长度为 N，$h(n)$ 长度为 M。它们的线性卷积结果为 $y_l(n)$，长度为 $N+M-1$。

如果我们计算 $x(n)$ 和 $h(n)$ 的 L 点循环卷积 $y_c(n)$ （通常需要先将 $x(n)$ 和 $h(n)$ **补零**到长度 L），那么 $y_c(n)$ 和 $y_l(n)$ 之间存在以下关系：

$$ y_c(n) = \sum_{r=-\infty}^{\infty} y_l(n + rL) R_L(n) $$

其中 $R_L(n)$ 是一个长度为 L 的矩形窗，表示结果只在 $0 \le n \le L-1$ 范围内有效。

这个公式表明：**L 点循环卷积是线性卷积以 L 为周期进行周期延拓，然后取主值序列 ( $0 \le n \le L-1$ ) 的结果。** 也就是说，循环卷积会产生**时域混叠 (Time Aliasing)**。

![Pasted image 20250408233133](../Pic/Pasted%20image%2020250408233133.png)
*(图示：当循环卷积长度 L =N 时，线性卷积的“尾部”会混叠到循环卷积的“头部”)*

#### 4. 用 DFT 计算线性卷积的条件 ✨

如何避免循环卷积的时域混叠，使得循环卷积的结果等于线性卷积的结果？

**条件**：选择循环卷积（也就是 DFT/IDFT）的长度 L，使其**大于等于**线性卷积结果的长度。

$$ L \ge N + M - 1 $$

当满足这个条件时，线性卷积 $y_l(n)$ 在一个周期 L 内不会发生混叠。此时，在 $0 \le n \le N+M-2$ 的范围内：

$$ y_c(n) = y_l(n) $$

#### 5. 快速计算线性卷积的步骤 (基于 FFT) ⚡

1.  **确定长度**：计算线性卷积所需的最小长度 $L_{min} = N + M - 1$。选择 DFT/FFT 的长度 $L \ge L_{min}$ (通常选择 $L$ 为大于等于 $L_{min}$ 的最小 2 的幂次方，以最大化 FFT 效率)。
2.  **补零 (Zero Padding)**：将序列 $x(n)$ (长度 N) 和 $h(n)$ (长度 M) 分别用零填充到长度 L。
    *   $x_p(n) = [x(0), x(1), ..., x(N-1), \underbrace{0, ..., 0}_{L-N \text{ zeros}}]$
    *   $h_p(n) = [h(0), h(1), ..., h(M-1), \underbrace{0, ..., 0}_{L-M \text{ zeros}}]$
3.  **计算 FFT**：计算补零后序列的 L 点 FFT。
    *   $X_p(k) = \text{FFT}[x_p(n)]$
    *   $H_p(k) = \text{FFT}[h_p(n)]$
4.  **频域相乘**：在频域将两个变换结果相乘。
    *   $Y_p(k) = X_p(k) H_p(k)$
5.  **计算 IFFT**：计算乘积结果的 L 点 IFFT。
    *   $y_c(n) = \text{IFFT}[Y_p(k)]$

由于 $L \ge N + M - 1$，此时得到的 L 点循环卷积 $y_c(n)$ 的前 $N+M-1$ 个点就等于 $x(n)$ 和 $h(n)$ 的线性卷积 $y_l(n)$。

$$ y_l(n) = y_c(n), \quad \text{for } 0 \le n \le N+M-2 $$

**框图总结**:

![Pasted image 20250408233346](../Pic/Pasted%20image%2020250408233346.png)

### 线性卷积的分段计算法 🧩

#### 1. 动机

当输入序列 $x(n)$ 非常长，而 $h(n)$ 相对较短时，如果直接采用上述 FFT 方法：
*   需要对非常长的 $x(n)$ 进行补零和 FFT，需要巨大的内存和计算量。
*   FFT 的效率优势在 $N_1 \gg N_2$ 时会减弱。

**解决方案**：将长序列 $x(n)$ 分割成若干**较短的段 (segments)**，分别计算每一段与 $h(n)$ 的卷积（使用 FFT 方法），然后将各段结果正确地**组合**起来得到最终的线性卷积结果。

主要有两种分段计算方法：**重叠相加法 (Overlap-Add)** 和 **重叠保留法 (Overlap-Save)**。

#### 2. 重叠相加法 (Overlap-Add Method) ➕

**核心思想**：
1.  **输入分段**：将长序列 $x(n)$ 分成**不重叠**的段 $x_i(n)$，每段长度为 $N_1$。
    *   $x(n) = \sum_i x_i(n)$
2.  **分段卷积**：计算每一段 $x_i(n)$ （长度 $N_1$）与 $h(n)$ （长度 M）的**线性卷积** $y_i(n)$。
    *   $y_i(n) = x_i(n) * h(n)$
    *   每个 $y_i(n)$ 的长度为 $N = N_1 + M - 1$。
    *   这一步通常使用 FFT 计算：补零 $x_i(n)$ 和 $h(n)$ 到长度 N，进行 FFT、频域相乘、IFFT。
3.  **输出组合**：由于 $y_i(n)$ 的长度 $N_1+M-1$ 比输入段 $x_i(n)$ 的长度 $N_1$ 长了 $M-1$ 个点，相邻分段卷积结果 $y_i(n)$ 和 $y_{i+1}(n)$ 在时间上会发生**重叠**。将这些**重叠部分相加**。
    *   $y(n) = \sum_i y_i(n)$

**图解**：
![Pasted image 20250409005201](../Pic/Pasted%20image%2020250409005201.png)

**重叠细节**：
*   $y_k(n)$ 的范围大致在 $k N_1$ 到 $k N_1 + N_1 + M - 2$。
*   $y_{k+1}(n)$ 的范围大致在 $(k+1) N_1$ 到 $(k+1) N_1 + N_1 + M - 2$。
*   $y_k(n)$ 的**最后 M-1 个点** (相对索引为 $N_1$ 到 $N_1+M-2$) 与 $y_{k+1}(n)$ 的**前 M-1 个点** (相对索引为 $0$ 到 $M-2$) 在**全局时间轴**（时间索引从 $(k+1)N_1$ 到 $(k+1)N_1 + M-2$）上重叠。
*   因此，需要将 $y_k(n)$ 的后 $M-1$ 个点与 $y_{k+1}(n)$ 的前 $M-1$ 个点对应相加。

**Overlap-Add 步骤 (使用 FFT)**:
1.  选择分段长度 $N_1$ (通常 $N_1 > M$)。计算 FFT 长度 $N = N_1 + M - 1$。
2.  预计算 $H(k) = \text{FFT}[h(n), N]$ (将 $h(n)$ 补零到 N 点)。
3.  将 $x(n)$ 分成长度为 $N_1$ 的不重叠段 $x_i(n)$ (最后一段可能需要补零以达到 $N_1$)。
4.  对每一段 $x_i(n)$:
    a.  将 $x_i(n)$ 补 $M-1$ 个零得到长度为 N 的 $x_{ip}(n)$。
    b.  计算 $X_i(k) = \text{FFT}[x_{ip}(n), N]$。
    c.  计算 $Y_i(k) = X_i(k) H(k)$。
    d.  计算 $y_i(n) = \text{IFFT}[Y_i(k), N]$。 (得到长度为 N 的第 i 段线性卷积结果)
5.  组合结果：将 $y_i(n)$ 的最后 $M-1$ 个点加到 $y_{i+1}(n)$ 的前 $M-1$ 个点上，然后将各段（处理重叠后）拼接起来。更形象地说：
    *   输出缓冲区初始化为 0。
    *   将 $y_0(n)$ 放入缓冲区从 0 开始的位置。
    *   将 $y_1(n)$ 放入缓冲区从 $N_1$ 开始的位置，与已有的 $y_0$ 的尾部相加。
    *   将 $y_2(n)$ 放入缓冲区从 $2N_1$ 开始的位置，与已有的 $y_1$ 的尾部相加... 以此类推。

#### 3. 重叠保留法 (Overlap-Save Method) 💾

**核心思想**：
1.  **输入分段**：将长序列 $x(n)$ 分成**相互重叠**的段 $x_i(n)$。每段长度为 $N$ (这是 FFT 的长度，与 OA 的 N 不同)。每段包含 $M-1$ 个**来自上一段末尾**的点和 $N_1 = N - M + 1$ 个**新的数据点**。
    *   需要先在 $x(n)$ 的**开头**补 $M-1$ 个零。
    *   第一段 $x_0(n)$ 包含 $M-1$ 个前导零和前 $N_1$ 个 $x(n)$ 数据点。
    *   第二段 $x_1(n)$ 包含 $x_0(n)$ 的最后 $M-1$ 个点 (即 $x(n)$ 的 $N_1-M+2$ 到 $N_1$ 点) 和接下来的 $N_1$ 个 $x(n)$ 新数据点。
    *   以此类推...
2.  **分段卷积**：计算每一段 $x_i(n)$ （长度 N）与 $h(n)$ （补零到长度 N）的 **N 点循环卷积** $y_{ci}(n)$。
    *   $y_{ci}(n) = x_i(n) \circledast_N h_p(n)$ (其中 $h_p(n)$ 是 $h(n)$ 补零到 N 点)。
    *   这一步使用 FFT 计算：$\text{IFFT}[\text{FFT}[x_i(n)] \cdot \text{FFT}[h_p(n)]]$。
3.  **输出组合**：N 点循环卷积结果 $y_{ci}(n)$ 的**前 M-1 个点**是由于循环卷积的混叠效应以及输入段人为重叠造成的，是**无效**的，需要**丢弃 (Discard)**。只**保留 (Save)** 每段结果的**后 $N_1 = N - M + 1$ 个点**。
4.  将所有保留下来的 $N_1$ 点长的有效数据段直接**拼接**起来，即得到最终的线性卷积结果 $y(n)$。

**为什么前 M-1 点无效？**
进行 N 点循环卷积时，计算 $y_{ci}(n)$ 的每个点都需要用到 $h(n)$ 的所有 M 个点。对于输出点 $y_{ci}(n)$ （其中 $0 \le n \le M-2$），计算时会 "循环地" 用到输入段 $x_i(n)$ 结尾处的点。由于 $x_i(n)$ 的前 $M-1$ 个点是来自上一段的 "旧" 数据，这些点的引入是为了让当前段的卷积在计算 "新" 数据点对应的输出时，拥有正确的 "历史状态"。这些前 $M-1$ 个点本身参与计算得到的输出 $y_{ci}(0)$ 到 $y_{ci}(M-2)$ 并不代表当前 $N_1$ 个新数据点产生的正确线性卷积结果。只有当计算进行到第 $M-1$ 个输出点时（即 $y_{ci}(M-1)$），卷积运算才完全作用在 "新" 数据点和必要的 "旧" 数据点上，得到第一个有效的线性卷积输出。因此，前 $M-1$ 个点 ($n=0$ 到 $n=M-2$) 需要丢弃。

**图解**：
![](Pic/Pasted%20image%2020250422071634.png)

**Overlap-Save 步骤 (使用 FFT)**:
1.  选择 FFT 长度 $N$ (通常 $N>M$，且常选 2 的幂次方)。确定新数据点的数量 $N_1 = N - M + 1$。
2.  预计算 $H(k) = \text{FFT}[h(n), N]$ (将 $h(n)$ 补零到 N 点)。
3.  在 $x(n)$ 前面补 $M-1$ 个零。维护一个包含 $M-1$ 个点的重叠缓冲区 (overlap buffer)，初始为零。
4.  从补零后的 $x(n)$ 中每次取 $N_1$ 个新数据点。
5.  构造长度为 N 的输入段 $x_i(n)$：将重叠缓冲区的 $M-1$ 个点放在前面，然后接上 $N_1$ 个新数据点。
6.  计算 N 点循环卷积：
    a.  $X_i(k) = \text{FFT}[x_i(n), N]$。
    b.  $Y_i(k) = X_i(k) H(k)$。
    c.  $y_{ci}(n) = \text{IFFT}[Y_i(k), N]$。
7.  **保留** $y_{ci}(n)$ 的**后 $N_1$ 个点** (即 $n = M-1$ 到 $n=N-1$) 作为有效输出段。
8.  **更新**重叠缓冲区：用当前输入段 $x_i(n)$ 的**最后 $M-1$ 个点** 替换缓冲区内容，为下一段做准备。
9.  重复步骤 4-8，直到处理完所有输入数据。将所有保留的 $N_1$ 点输出段依次拼接。


#### 4. 重叠相加法 vs 重叠保留法 🤔

| 特点         | 重叠相加法 (Overlap-Add)                     | 重叠保留法 (Overlap-Save)                      |
| :----------- | :------------------------------------------- | :--------------------------------------------- |
| **输入分段** | 不重叠，长度 $N_1$                           | 重叠 $M-1$ 点，总长 $N = N_1 + M - 1$         |
| **卷积类型** | 线性卷积 (用 N 点 FFT 实现)                  | N 点循环卷积                                   |
| **FFT 长度** | $N = N_1 + M - 1$                             | $N$ (通常选 $2^k > M$)，$N_1 = N - M + 1$      |
| **输出处理** | 相邻段结果的后 $M-1$ 点与前 $M-1$ 点**相加** | 每段结果的**前 $M-1$ 点丢弃**，后 $N_1$ 点保留 |
| **实现细节** | 最后一段输入可能需补零到 $N_1$               | 输入前端需补 $M-1$ 个零，维护重叠输入缓冲      |
| **适用性**   | 两者效率相当，选择取决于具体实现偏好和平台。 | OS 在某些实时流处理中因无需输出累加可能略方便。 |

**总结**：两种方法都能有效地利用 FFT 计算长序列与短序列的线性卷积。它们通过不同的输入分段和输出组合策略来处理卷积运算带来的长度增加问题。