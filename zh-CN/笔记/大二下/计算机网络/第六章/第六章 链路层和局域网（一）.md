# 第六章 链路层和局域网

你好！欢迎来到第六章的学习。在之前的章节中，我们已经自顶向下地探索了应用层、运输层和网络层。现在，我们的旅程将深入到协议栈的更底层——**链路层** 🖥️↔️🖥️。这一层虽然“深藏不露”，但它却是实现相邻节点间可靠、高效通信的基石。你可能会想，我们已经有了网络层的 IP 地址进行全局寻址，有了运输层的 TCP/UDP 进行端到端通信，为什么还需要链路层呢？这一章，我们将一起揭开链路层的神秘面纱！

---

**【阅读第六章之前：一点小小的“剧透”与学习导航】**

在正式开始第六章的探索之前，我想给你一个小小的“导航”：链路层位于网络层之下，物理层之上。它的核心任务是负责将网络层交下来的数据报（`datagram`）封装成**帧** (`frame`)，并在**一条链路上的相邻节点之间**（例如，主机到路由器，路由器到路由器，主机到主机）进行传输。

你将会看到，链路层需要解决许多实际问题：

1.**如何标识链路上的设备？** 这就是 `MAC` 地址的用武之地。
2.**多个设备共享同一条链路（比如WiFi）时，如何协调避免冲突？** 这就是各种**多路访问协议**（如 `CSMA/CD`, `CSMA/CA`）要解决的问题。
3.**传输过程中出现比特错误怎么办？** 链路层需要**差错检测**，有时甚至是**差错纠正**机制。
4.**局域网（`LAN`）是如何构建和工作的？** 我们会重点学习以太网（`Ethernet`）技术，包括交换机（`switch`）的工作原理。

与网络层关注的是**端到端**的路径选择（路由）不同，链路层更关注的是**点到点**（或者说一跳一跳）的可靠数据传输。理解这一点，将帮助你更好地把握本章的知识脉络。

祝你学习愉快！🚀

---

### 1. 引言：链路层，我们身边的“快递员” 🚚

想象一下，你要从北京寄一个包裹到纽约。网络层（IP协议）就像是规划了整个跨国运输路线的“总调度”，决定了包裹要经过哪些城市（路由器）。而链路层，则像是负责**每一个城市内部**或者**两个相邻城市之间**具体运输任务的“本地快递员”或“货运卡车司机”。它不关心包裹的最终目的地是纽约，只关心如何把包裹从当前节点准确无误地送到这条链路上的下一个节点。

* **核心术语定义** 💡：
    * **节点 (Nodes)**: 链路层语境下的节点通常指主机（`hosts`）和路由器（`routers`）。
    * **链路 (Links)**: 连接相邻节点的通信信道。这些链路可以是：
        * **有线的 (Wired)**: 如以太网线、光纤。
        * **无线的 (Wireless)**: 如 `WiFi`、蜂窝网络。
        * **局域网 (LANs)**: 本身也构成一种链路环境。
    * **帧 (Frame)**: 链路层的协议数据单元（`PDU`）。网络层递交下来的 `IP数据报` 在链路层会被封装成帧，添加上链路层头部（可能还有尾部）信息。
        $\boxed{ \text{链路层的核心职责：将数据报从一个节点通过一条物理链路传输到相邻的下一个节点} }$
        (见Slide 6-4)

#### 1.1 链路层的“上下文”：它在协议栈中的位置与作用

* **不同链路，不同协议**：一个 `IP数据报` 在从源主机到目标主机的整个路径中，可能会经过许多不同类型的链路（例如，从你的电脑到家庭路由器可能是 `WiFi`，路由器到 `ISP` 可能是光纤以太网）。每一段链路可能使用不同的链路层协议。
* **多样化的服务**：不同的链路层协议提供的服务也可能不同。
    *   例如：某些链路层协议可能提供可靠数据传输（通过确认和重传），而另一些则不提供。
#### 1.2 链路层提供的服务 🛠️

链路层可以提供多种服务来支持网络层数据报的传输：

1.**成帧 (Framing) 与链路接入 (Link Access)**:
    *   将网络层数据报封装成帧，添加头部和尾部（尾部通常用于差错校验）。
    *   如果链路是共享介质（例如，早期的总线型以太网或无线 `LAN`），则需要介质访问控制（`Medium Access Control, MAC`）协议来协调多个节点的发送。
    *   帧头部通常包含**源 `MAC` 地址**和**目的 `MAC` 地址**。注意，这与 `IP` 地址是不同的！`MAC` 地址用于在**本地链路**上标识设备。

2.**相邻节点间的可靠交付 (Reliable Delivery)**:
    *   虽然 `TCP` 在运输层提供了端到端的可靠交付，但链路层也可以在**相邻节点间**提供可靠性。这是通过确认（`ACK`）和重传机制实现的。
	*   $\boxed{ Q: \text{为何同时需要链路级和端到端可靠性？}}$
		* **端到端原则**: 某些功能（如可靠性）只有在通信的两个端点处完整实现才能真正得到保证。中间链路的可靠性不能替代端到端的可靠性，因为数据可能在路由器内部（处理过程中）丢失，而不是在链路上。
		* **性能优化**: 在高误码率链路上，链路级的重传可以快速恢复错误，防止错误传播，减少端到端重传的延迟和开销。

3.**流量控制 (Flow Control)**:
    *   协调相邻的发送节点和接收节点之间的发送速率，防止快速的发送方淹没慢速的接收方。

4.**差错检测 (Error Detection)**:
    *   由于信号在物理介质上传输时可能会受到噪声、衰减等因素的影响，导致比特错误。
    *   链路层通过在帧中加入差错检测比特（`Error Detection Code, EDC`），使接收方能够检测出帧中是否发生了错误。
    *   如果检测到错误，接收方可能会通知发送方重传（如果提供了可靠交付服务），或者简单地丢弃该帧。

5.**差错纠正 (Error Correction)**:
    *   比差错检测更进一步，接收方不仅能检测到错误，还能**纠正**一定范围内的比特错误，而无需请求重传。

6.**半双工与全双工 (Half-duplex and Full-duplex)**:
    * **半双工**: 链路两端的节点都可以发送和接收，但不能同时进行。就像对讲机。
    * **全双工**: 链路两端的节点可以同时发送和接收。就像电话。

#### 1.3 链路层在哪里实现？ 🤔

*   链路层功能通常实现在每个主机的**网络接口卡 (Network Interface Card, NIC)** 中，也称为网络适配器。例如，以太网卡、`WiFi` 网卡。
*   `NIC` 通常是一个独立的硬件设备，但也可能集成在主板芯片上。
*   它负责实现链路层协议和物理层协议。
*   `NIC` 通过主机的系统总线（如 `PCI`）与主机 `CPU` 和内存交互。
*   链路层的实现是硬件、软件和固件（`firmware`）的结合。
    *   例如，`MAC` 地址通常烧录在 `NIC` 的 `ROM` 中。帧的封装、差错检测计算、介质访问控制等可能由 `NIC` 上的专用芯片和固件执行。驱动程序（软件）则负责操作系统与 `NIC` 硬件之间的交互。
* **图示：主机内部的网络接口**
    *   应用程序数据 -> 运输层 -> 网络层 ->**链路层 (在 `CPU` 和 `NIC` 协同下完成)** -> 物理层 (在 `NIC` 上)。
    *   `NIC` 控制器（`controller`）处理链路层逻辑，物理层（`physical`）组件负责信号的发送和接收。
    ![](Pic/Pasted%20image%2020250524140542.png)
    (图示简化了OS内核协议栈与NIC的交互，但核心思想是链路层主要在NIC上实现)

#### 1.4 适配器（NIC）之间的通信过程

* **发送端**:
    1.  `NIC` 从内存中获取由网络层传来的数据报。
    2.**封装 (Encapsulates)** 数据报到链路层帧中（添加帧头、帧尾）。
    2.  根据链路层协议，可能还会添加差错检测比特（如 `CRC`）、实现可靠数据传输的序列号、实现流量控制的信息等。
    3.  将帧传递给物理层，转换为电信号/光信号/电磁波在链路上发送出去。
* **接收端 (Receiving side)**:
    1.  物理层从链路接收信号，转换为比特流，传递给 `NIC`。
    2.  `NIC` 检查帧中的差错检测比特，判断是否出错。
    3.  如果协议支持可靠传输和流量控制，`NIC` 会进行相应的处理（如发送确认帧、控制发送方速率）。
    4.  如果帧没有错误（或者错误已被纠正）并且是发往本节点的（通过检查目的 `MAC` 地址），则**提取 (Extracts)** 出其中的数据报。
    5.  将数据报传递给网络层进行后续处理。

---
### 2. 差错检测与纠正技术：火眼金睛辨真伪 ✨

在数据传输过程中，由于噪声等因素，0 可能变成 1，1 也可能变成 0。链路层的一项重要任务就是检测（甚至纠正）这些错误。

* **基本原理** :
    *   发送方：对要发送的数据 `D` (Data)，通过某种算法计算出差错检测和纠正比特 `EDC` (Error Detection and Correction bits)，并将 `EDC` 附加到 `D` 之后一起发送。`EDC` 也被称为冗余比特 。
    *   接收方：接收到可能含有错误的数据 `D'` 和 `EDC'`。
        1.  对 `D'` 使用与发送方相同的算法重新计算 `EDC_new`。
        2.  比较 `EDC_new` 和接收到的 `EDC'`。
            *   如果一致，则认为数据 `D'` 没有错误（或者错误恰好没有被检测出来，但这概率很小）。
            *   如果不一致，则检测到错误。
* **重要提示：差错检测并非100%可靠！** ☠️
    *   任何差错检测算法都可能漏掉某些特定的错误模式（即错误发生了，但算法未能检测出来）。
    *   但是，设计良好的 `EDC` 算法可以使这种漏检的概率非常非常低。
    *   一般来说，`EDC` 字段越长，包含的冗余信息越多，差错检测（和纠正）的能力就越强，但开销也越大。

#### 2.1 奇偶校验

这是最简单的一种差错检测方法。

* **单位比特奇偶校验**:
    *   原理：在数据 `D` 后面附加一位**奇偶校验位**。
    * **偶校验 (Even parity)**: 设置奇偶校验位，使得整个数据（包括校验位本身）中 ‘1’ 的个数为偶数。
    * **奇校验 (Odd parity)**: 设置奇偶校验位，使得整个数据中 ‘1’ 的个数为奇数。
    *   能力：只能检测出**奇数个比特错误**。如果发生偶数个比特错误（例如2个比特翻转），则校验结果依然“正确”，无法检测出错误。
    *   示例：数据 `1` (1个1)，如果采用偶校验，校验位应为 `1`。发送 `11`。

* **二维奇偶校验 (Two-Dimensional Bit Parity)**:
    *   原理：将数据 `D` 排列成一个 $i$ 行 $j$ 列的矩阵。
        *   为每一行计算一个行奇偶校验位。
        *   为每一列计算一个列奇偶校验位。
        *   （可选）还可以为所有行校验位（或列校验位）再计算一个总校验位。
    *   能力：
        * **可以检测并纠正单个比特错误**。如果只有一个比特出错，那么该比特所在的行和列的奇偶校验都会出错，交叉点就是错误比特的位置，将其翻转即可纠正。
        *   可以检测出大多数2比特、3比特错误，以及许多4比特错误（特别是当它们分布在不同行不同列时）。但某些特定模式的偶数个错误（如形成矩形的4个错误）可能无法检测或无法正确纠正。
    *   示例 (假设偶校验):
		![](Pic/Pasted%20image%2020250524140910.png)

#### 2.2 因特网校验和(回顾)

这个我们在运输层（如 `UDP`、`TCP` 头部校验和）和网络层（`IP` 头部校验和）已经遇到过了。

* **目标**: 检测传输段（如 `UDP` 段、`IP` 头部）中发生的比特错误（翻转）。
* **发送方**:
    1.  将要校验的数据（例如，`UDP` 头部、伪头部和数据）看作是一系列16比特整数的序列。
    2.  对这些16比特整数进行**反码算术加法**。
        *   反码加法：二进制相加，如果最高位有进位，则将进位加到最低位（称为回卷）。
    3.  将最终得到的和按位取反，得到的就是校验和。
    4.  将此校验和值放入 `UDP/TCP/IP` 报头的校验和字段。
* **接收方 (Receiver)**:
    1.  将接收到的报头中的校验和字段取出。
    2.  将其余部分（与发送方校验范围相同的部分）同样视为16比特整数序列。
    3.  对这些整数（包括发送方计算出的校验和，但通常是将接收到的校验和字段视为0，然后计算新校验和；或者将所有部分包括校验和本身一起求和）进行反码算术加法。
    4.**检查**:
        *   如果将所有部分（包括原校验和）一起求反码和，结果应该是全1（即 `-0` in one's complement）。
        *   或者，如果将校验和字段视为0计算新校验和，然后与收到的校验和比较，应该相等。
        *   或者，如果用收到的数据部分计算新校验和，再与收到的校验和进行反码求和，结果应该是全1。
    * **结果**:
        *   不等于期望值（如全1）：检测到错误。
        *   等于期望值：**未检测到错误**。但这并不意味着100%没有错误，只是说发生的错误恰好没有被这种校验和算法检测出来（概率较低）。

* **特点**: 实现简单，计算速度快，但检错能力相对较弱，不如 `CRC`。

#### 2.3 循环冗余校验 (Cyclic Redundancy Check, CRC)

`CRC` 是一种非常强大且广泛使用的差错检测编码技术，常见于以太网、`WiFi`、`HDLC` 等多种链路层协议。

* **核心思想**: 将要发送的数据比特序列 `D` 视作一个多项式 $D$，然后用一个预先选定的**生成多项式 $G$** (对应一个比特模式 `G`)去除 $D$（进行模2多项式除法），得到的**余数 `R`** (对应多项式 $R$) 就是 `CRC` 校验码。
* **参数定义**:
    *   `D`: $d$ 比特的数据 ，将其视为一个 $d-1$ 次的多项式。
    *   `G`: $r+1$ 比特的生成模式 ，将其视为一个 $r$ 次的生成多项式 $G$。最高位和最低位通常都是1。
    *   `R`: $r$ 比特的 `CRC` 校验位 。
* **发送方操作**:
    1.  目标：选择 $r$ 个 `CRC` 比特 `R`，使得 $<D, R>$ (即 $D$ 后面跟着 $R$) 组成的 $d+r$ 比特序列能够被 `G`**整除** (在模2运算意义下)。
        *   这里的“整除”指的是用长除法（异或操作代替减法）后余数为0。
    2.  计算步骤：
        a.  将数据 `D` 左移 $r$ 位 (相当于 $D \cdot 2^r$，或多项式 $Dx^r$)。
        b.  用生成模式 `G` 去除这个左移后的 $D \cdot 2^r$。
        c.  得到的 $r$ 位余数就是 `R`。
        *   $\boxed{ R = \text{remainder} \left[ \frac{D \cdot 2^r}{G} \right] }$
        d.  实际发送的帧是 $D$ 拼接 $R$，即 $<D,R>$。但从数学上看，这等价于计算 $D \cdot 2^r \text{ XOR } R$。
* **接收方操作**:
    1.  接收到可能出错的 $d+r$ 比特序列 $<D', R'>$。
    2.  用相同的生成模式 `G` 去除这个序列。
    3.**检查余数**:
        *   如果余数非零：检测到错误。
        *   如果余数为零：未检测到错误（或者发生了G无法检测的特定错误）。
* **CRC的强大能力**:
    *   可以检测出所有**小于等于 $r$ 位的突发错误**。突发错误是指连续的比特发生错误。
    *   可以检测出所有**奇数个比特的错误**（如果 $G(x)$ 包含因子 $(x+1)$）。
    *   对于长度大于 $r$ 的突发错误，漏检的概率非常小，约为 $1/2^r$。
    *   广泛应用于实践中，如以太网 (`CRC-32`)，802.11 `WiFi`。
* **CRC 计算示例**:
	* ![](Pic/Pasted%20image%2020250524150719.png)

* **选择生成多项式 $G$**: 有一些国际标准化的 $G$，例如：
    *   `CRC-8`: $x^8+x^2+x^1+1$
    *   `CRC-16`: $x^{16}+x^{15}+x^2+1$ (常用)
    *   `CRC-CCITT`: $x^{16}+x^{12}+x^5+1$ (常用)
    *   `CRC-32`: $x^{32}+x^{26}+x^{23}+\dots+x^2+x^1+1$ (以太网使用)

---
### 3. 多路访问链路与协议：共享信道的智慧 🤝

在许多网络场景中，多个节点（主机、路由器）需要共享同一个物理通信介质。例如，早期的总线型以太网，或者我们现在广泛使用的无线局域网 (`WiFi`)。当多个节点同时试图在共享信道上发送数据时，它们的信号就会在信道中发生**碰撞**，导致数据损坏，接收方无法正确解码。

因此，我们需要**多路访问协议 (Multiple Access Protocols)** 来协调多个节点对共享信道的访问，以尽可能避免碰撞，或者在碰撞发生后有效地从中恢复。

#### 3.1 链路的两种基本类型

1.**点对点链路:
    *   链路两端只有一个发送方和一个接收方。
    *   例如：连接一台主机和一台以太网交换机的网线；早期的拨号上网使用的 `PPP`。
    *   在点对点链路上，多路访问问题相对简单或者不存在，因为信道是专用的。

2.**广播链路(或共享介质)**:
    *   多个发送和接收节点共享同一条物理链路。
    *   当一个节点发送帧时，链路上所有其他节点都能“听到”（接收到）这个帧。
    *   例如：
        *   老式的总线型以太网 。
        *   有线电视网络中的上行信道 。
        *   无线局域网 `802.11 WLAN` (`WiFi`)。
        *   4G/5G 蜂窝网络。
        *   卫星通信。
    * **类比**: 就像一个鸡尾酒会，所有人都共享同一个空气介质进行交谈。如果多个人同时大声说话，就会互相干扰。
    *   $\boxed{ \text{在广播链路上，核心挑战是如何协调多个节点的发送，以避免或处理信号碰撞。} }$

#### 3.2 多路访问协议的核心问题

* **单一共享广播信道**: 这是我们面临的环境。
* **碰撞**: 如果两个或多个节点在同一时间（或信号传播允许的重叠时间内）发送信号，它们的信号会在介质中叠加，导致接收节点无法正确识别任何一个原始信号。
    $\boxed{ \text{当一个节点同时接收到两个或多个信号时，就会发生碰撞。} }$
* **多路访问协议的作用**:
    *   它是一个**分布式算法**，运行在每个节点上，用于决定该节点何时可以发送数据。
    *   关键在于，这些协调信息（例如，信道是否空闲，是否可以发送）**必须通过共享信道本身来传递**，通常没有专门的带外控制信道。

#### 3.3 理想的多路访问协议应具备哪些特性？ 🌟 

假设我们有一个广播信道，其总数据传输速率为 $R$ bps。一个理想的多路访问协议应该追求以下目标：

1.**单一节点高效利用**: 当只有一个节点想要发送数据时，它应该能够以信道的全部速率 $R$ 进行发送。
2.**多节点公平共享**: 当有 $M$ 个节点都想发送数据时，每个节点应该能够获得平均 $R/M$ 的速率。
3.**完全分散 (Fully Decentralized)**:
    *   不应该依赖某个特殊的中心节点来进行协调。
    *   不应该要求所有节点之间进行严格的时钟同步或划分固定的时隙（除非协议本身设计如此）。
4.**简单**: 协议的实现和维护应该尽可能简单。

然而，现实中很难完美地同时满足所有这些理想特性。不同的多路访问协议会在这些目标之间进行权衡。

#### 3.4 多路访问协议的分类 

主要可以分为三大类：

1.**信道划分 (Channel Partitioning) 协议**:
    *   将共享信道在时间、频率或码字上分割成多个较小的“片断 ”。
    *   为每个节点分配一个专用的片断，使其可以独占使用。
    *   优点：避免了碰撞。
    *   缺点：当节点没有数据发送时，分配给它的信道资源就被浪费了。
    *   例如：时分多路复用 (`TDMA`)、频分多路复用 (`FDMA`)、码分多址 (`CDMA`)。

2.**随机接入 (Random Access) 协议**:
    *   不预先划分信道，允许节点在需要时尝试发送。
    *   允许碰撞发生，但协议需要提供检测碰撞和从碰撞中恢复的机制（通常是等待一段随机时间后重传）。
    *   优点：在低负载时，节点可以快速接入信道并以全速率发送；实现相对简单。
    *   缺点：在高负载时，碰撞概率增加，信道利用率可能下降。
    *   例如：`ALOHA`、时隙 `ALOHA` (`Slotted ALOHA`)、`CSMA` (载波侦听多路访问)、`CSMA/CD` (带碰撞检测的 `CSMA`)、`CSMA/CA` (带碰撞避免的 `CSMA`)。

3.**轮流 (Taking Turns) 协议**:
    *   节点之间轮流获得发送权。
    *   试图结合信道划分和随机接入的优点：在高负载时表现良好（类似信道划分），在低负载时允许更灵活的接入。
    *   通常需要一些机制来传递“令牌”或进行“轮询”。
    *   例如：轮询 (Polling)、令牌传递 (Token Passing，如令牌环网)。

接下来，我们将逐一了解这些协议。

---
##### 3.4.1 信道划分协议

###### a) 时分多路访问 (TDMA - Time Division Multiple Access) 

* **原理**: 将信道的使用时间划分成一系列重复的**帧**，每个帧再细分成固定数量的**时隙**。
*   每个节点被分配一个或多个固定的时隙，在它自己的时隙内才能发送数据。
*   每个时隙的长度通常设计为刚好能传输一个固定大小的数据包（或帧）。
* **优点**:
    *   无碰撞。
    *   每个节点都能保证获得一定的带宽。
* **缺点**:
    *   如果一个节点在它的时隙内没有数据要发送，该时隙就会被浪费掉 。
    *   即使只有一个节点活跃，它也只能在自己的时隙内发送，不能利用其他空闲时隙，信道利用率可能不高。
* **示例**:
    *   一个6个站点的局域网，`TDMA` 帧包含6个时隙。
    *   如果站点1、3、4有数据包要发送，而站点2、5、6没有，那么在每个 `TDMA` 帧中，时隙1、3、4会被使用，而时隙2、5、6则为空闲。
    ![](Pic/6-24)

###### b) 频分多路访问 (FDMA - Frequency Division Multiple Access) 

* **原理**: 将信道的总频带划分成多个较窄的**子频带**。
*   每个节点被分配一个固定的子频带，在该频带内发送数据。
* **优点**:
    *   无碰撞（如果频带划分得当，有足够的保护间隔）。
    *   每个节点获得专用频带。
* **缺点**:
    *   如果一个节点在它的频带内没有数据要发送，该频带资源就被浪费了。
    *   即使只有一个节点活跃，它也只能使用分配给它的那个窄频带，不能利用整个信道带宽。
* **示例**:
    *   一个6个站点的局域网，信道被划分为6个频带。
    *   站点1、3、4有数据发送，它们分别使用分配给自己的频带1、3、4。频带2、5、6则空闲。
    ![](Pic/6-25)

---
##### 3.4.2 随机接入协议 (Random Access Protocols) 

这类协议的核心思想是“先试后看，错了重来”。

* **基本运作方式**:
    *   当一个节点有数据包要发送时，它通常会以信道的全部速率 $R$ 进行发送。
    *   节点之间没有预先的协调（no a priori coordination）。
    *   如果两个或多个节点同时发送，就会发生**碰撞**。
* **随机接入 `MAC` 协议需要规定**:
    1.**如何检测碰撞**。
    2.**如何从碰撞中恢复**，例如通过延迟一段随机时间后重传。
* **常见的随机接入协议**:
    *   `ALOHA` (最原始的)
    *   时隙 `ALOHA` (`Slotted ALOHA`)
    *   `CSMA` (载波侦听多路访问)
    *   `CSMA/CD` (带碰撞检测的 `CSMA`，以太网经典协议)
    *   `CSMA/CA` (带碰撞避免的 `CSMA`，`WiFi` 使用)

###### a) 时隙 ALOHA 

这是对纯 `ALOHA` 协议（稍后会提到）的一个改进，引入了时间同步的概念。

* **基本假设 (Assumptions)**:
    1.  所有帧的大小相同。
    2.  时间被划分为等长的**时隙**，每个时隙的长度等于发送一个帧所需的时间。
    3.  节点只能在**时隙的开始时刻**才能开始发送帧。
    4.  所有节点都必须**同步**到这些时隙边界。
    5.  如果在同一个时隙内有2个或多个节点发送帧，则发生碰撞，所有参与碰撞的节点都能检测到这次碰撞。

* **操作流程 (Operation)**:
    1.  当一个节点有新的帧要发送时，它会等待到下一个时隙的开始，然后发送该帧。
    2.**如果发送成功**: 该节点可以准备在下一个时隙发送新的帧（如果还有的话）。
    3.**如果发生碰撞**:
        *   该节点会以概率 $p$ 在**后续的每一个时隙**尝试重传这个发生碰撞的帧。
        *   直到该帧发送成功为止。
        *   $\boxed{ \text{随机化 为何重要？} }$ 如果发生碰撞后，所有节点都选择在下一个时隙立即重传，那么很可能会再次碰撞。通过引入概率 $p$（或者说，每个节点在碰撞后独立选择一个随机的等待时隙数），可以错开它们的重传尝试，从而增加成功发送的几率。

* **时隙 `ALOHA` 示例**:
    *   图中显示了3个节点（Node 1, 2, 3）在不同时隙的发送情况。
    *   `C`: Collision (碰撞)
    *   `S`: Success (成功)
    *   `E`: Empty (空闲时隙)
    *   例如，在第一个时隙，Node 1 和 Node 3 都发送了，导致碰撞 (`C`)。
    *   在第四个时隙，只有 Node 1 发送，成功 (`S`)。
    ![](Pic/6-28)

* **优点 (Pros)**:
    *   当只有一个活动节点时，它可以持续地以信道的全速率发送数据。
    *   高度分散化：只需要节点之间在时隙上同步即可，不需要中心控制。
    *   协议相对简单。

* **缺点 (Cons)**:
    *   仍然会发生碰撞，导致时隙浪费。
    *   仍然可能出现空闲时隙，即使有节点等待发送（因为它们可能在前一个时隙碰撞了，正在等待重传）。
    *   节点可能在发送完整帧之前就能检测到碰撞（例如，如果信道传播延迟远小于帧发送时间），但 `Slotted ALOHA` 的基本模型是发送完整帧后才知道是否碰撞。
    *   需要时钟同步，这在实际中可能不容易实现。

* **效率 (Efficiency)**:
    *   效率定义为：在有大量节点和大量帧要发送的情况下，长期来看，成功发送帧的时隙所占的比例。
    *   假设有 $N$ 个节点，每个节点在任一时隙都有帧要发送，并以概率 $p$ 发送。
        *   某个特定节点成功发送的概率（即它发送，且其他 $N-1$ 个节点都不发送）是 $p(1-p)^{N-1}$。
        *   任一节点成功发送的概率（即恰好有一个节点发送）是 $Np(1-p)^{N-1}$。
        *   为了使这个成功概率最大化，可以对 $p$ 求导找到最优的 $p^*$。
        *   当节点数 $N$ 趋于无穷大时，可以证明，时隙 `ALOHA` 的**最大效率 约为 $1/e \approx 0.37$**。
    *   这意味着，在最佳情况下，时隙 ALOHA 协议也只有大约 37% 的时间用于成功传输数据，其余时间则因碰撞或空闲而被浪费。

###### b) 纯 ALOHA (Pure ALOHA) (非时隙) 

这是最早的随机接入协议，比时隙 `ALOHA` 更简单，但效率也更低。

* **特点**:
    * **无时隙**，无需时钟同步。
    *   当一个节点有帧要发送时，它**立即** 就发送，不等待任何时隙边界。
* **碰撞窗口变大**:
    *   由于发送是异步的，碰撞的风险期也更长。
    *   假设一个节点在 $t_0$ 时刻开始发送一个帧（帧长为 $T_{fr}$）。
    *   为了使这个帧不与其他帧碰撞，必须满足：
        *   在 $t_0$ 开始发送这个帧的整个持续时间 $(t_0,t_0+T_{fr})$ 内，没有其他节点开始发送。
        *   并且，在 $t_0$ 开始之前的 $T_{fr}$ 时间内（即 $(t_0-T_{fr},t_0)$），也没有其他节点开始发送（否则它们的帧会与 $t_0$ 开始的帧的前半部分重叠）。
    *   所以，一个帧的**易受攻击窗口** 长度是 $2T_{fr}$。 
    ![](Pic/6-30)
* **效率**:
    *   可以证明，纯 `ALOHA` 的最大效率只有时隙 `ALOHA` 的一半，约为 $1/(2e) \approx 0.18$ (或 18%)。
    *   这是因为它的碰撞窗口是时隙 `ALOHA` 的两倍。

**总结**：时隙 `ALOHA` 通过引入时隙同步，将碰撞窗口减半，从而将最大理论效率从18%提高到了37%。但这仍然不够理想。我们需要更智能的方法来减少碰撞。

###### c) CSMA (载波侦听多路访问 - Carrier Sense Multiple Access) 

`CSMA` 协议试图通过“**先听再说**”的策略来减少碰撞。

* **基本思想**: 在发送帧之前，节点先**侦听** 信道是否有其他节点正在发送（即是否有载波信号）。
    * **如果信道被侦测到空闲**: 则发送整个帧。
    * **如果信道被侦测到忙碌**: 则**延迟** 发送，等待一段时间后再侦听。
* **人类类比 (Human analogy)**: 就像在会议中发言前，先听听是否有人正在说话，如果有人在说，就等他说完。不要打断别人！
* **CSMA 的坚持程度**:
    * **1-坚持 CSMA (1-persistent CSMA)**: 如果信道忙，则持续侦听，一旦空闲立即发送。如果多个节点同时等待并同时发送，仍然会碰撞。
    * **非坚持 CSMA (Non-persistent CSMA)**: 如果信道忙，则等待一个随机的时间后再回来侦听，而不是持续侦听。这可以减少信道刚变空闲时多个等待节点同时发送的概率。
    * **p-坚持 CSMA**: 用于时隙信道。如果信道空闲，则以概率 $p$ 发送，以概率 $1-p$ 延迟到下一个时隙。如果信道忙，则等待下一个时隙再按同样规则处理。

* **CSMA 的碰撞问题**:
    *   即使使用了载波侦听，**碰撞仍然可能发生！**
    * **原因**: 信号在信道中的**传播延迟**。
    *   想象两个相距较远的节点A和B。
        1.  A开始侦听信道，发现是空闲的，于是A开始发送。
        2.  A的信号需要一段时间才能传播到B。
        3.  在A的信号到达B之前，B也可能侦听信道，发现（在它看来）是空闲的，于是B也开始发送。
        4.  结果，A和B的信号将在信道中的某个位置相遇并发生碰撞。
    *   $\boxed{ \text{信道传播延迟意味着，一个节点可能无法立即听到另一个刚刚开始发送的节点的信号。} }$
    *   当碰撞发生时，在 `CSMA`（没有碰撞检测）中，整个冲突帧的传输时间都被浪费了。
    * **碰撞的概率与信道传播延迟和帧发送时间有关**。传播延迟越大（节点距离越远），或者帧发送时间越短（速率越高或帧越短），则一个节点在侦听到信道空闲后开始发送，到它能检测到其他节点也开始发送（如果它们几乎同时开始）的时间窗口就相对越长，碰撞的风险也越大。
    ![](Pic/6-32) (图示了由于传播延迟导致CSMA碰撞的情况)

###### d) CSMA/CD (带碰撞检测的 CSMA) 

`CSMA/CD` 是对 `CSMA` 的一个重要改进，它不仅“先听再说”，还能“**边说边听**”，以便尽早检测到碰撞并中止发送，从而减少带宽浪费。这是传统有线以太网（如10BASE-T, 100BASE-TX）中使用的经典协议。

* **核心思想**:
    *   在发送数据的同时，节点继续侦听信道。
    *   如果在发送过程中检测到有其他节点也在发送（即检测到碰撞，通常表现为信道上的信号能量异常），则：
        1.  立即**中止** 当前帧的发送。
        2.  发送一个简短的**拥塞信号**，以确保所有其他参与碰撞的节点也都能明确地意识到发生了碰撞。
        3.  然后执行**退避算法**，等待一段随机时间后，再尝试重新发送（从第1步CSMA开始）。
* **碰撞检测的实现**:
    *   在**有线局域网** 中（如双绞线以太网），碰撞检测相对容易。节点可以通过比较它发送的信号和它在信道上实际“听到”的信号来实现。如果两者不一致，就说明发生了碰撞。
    *   在**无线局域网** 中，碰撞检测非常困难。因为：
        *   发送信号的功率远大于接收信号的功率，发送节点自己的信号会淹没掉远端其他节点可能发送的较弱信号，使得它无法在发送的同时有效检测到碰撞（“近场效应”或“隐藏终端问题”的前兆）。
        *   因此，无线网络通常使用 `CSMA/CA` (带碰撞避免)。
* **CSMA/CD 如何减少浪费**:
    *   通过在碰撞发生后尽早中止发送，`CSMA/CD` 显著减少了因碰撞而浪费的信道时间。相比于 `CSMA`（会发送完整个冲突帧），`CSMA/CD` 只发送了帧的一部分和拥塞信号。
    *   ![](Pic/6-33) (图示了CSMA/CD在碰撞发生后中止发送，节省了时间)

* **以太网 CSMA/CD 算法流程**:
    1.  `NIC` 从网络层接收数据报，创建链路层帧。
    2.  `NIC` 侦听信道：
        * **如果信道空闲**: 开始发送帧。
        * **如果信道忙碌**: 等待直到信道变空闲，然后立即发送 (这是1-坚持的特性)。
    3.**如果在发送整个帧的过程中没有检测到碰撞**: `NIC` 成功完成该帧的发送，任务结束！🎉
    4.**如果在发送过程中检测到其他节点也在发送 (即发生碰撞)**:
        *   `NIC` 立即**中止** 当前帧的发送。
        *   `NIC` 发送一个**拥塞信号** (通常是32到48比特的特定模式)，以强化碰撞，确保所有站点都能感知。
    5.**中止发送后，`NIC` 进入二进制指数退避 阶段**:
        *   对于第 $m$ 次连续碰撞（针对同一个帧的重传尝试），`NIC` 从集合 $\{0, 1, 2, \dots, 2^m-1\}$ 中随机选择一个整数 $K$。（注意：$m$ 的最大值通常有限制，例如到10次后，$2^m-1$ 可能不再增加，保持为 $2^{10}-1 = 1023$）。
        *   `NIC` 等待 $K \times 512$ 比特时间 。$512$ 比特时间被称为一个**时隙时间**，它与网络的最大传播延迟和最小帧长有关。
        *   等待结束后，返回到第2步 (重新侦听信道)。
        *   二进制指数退避的目的：碰撞次数越多，平均等待时间就越长，从而在高负载时动态地减少信道竞争，提高最终成功的概率。

* **CSMA/CD 效率**:
    *   `CSMA/CD` 的效率远高于 `ALOHA` 协议。
    *   其效率与两个关键时间参数的比值有关：
        *   $t_{prop}$: 信号在网络中任意两个节点之间的**最大单向传播延迟**。
        *   $t_{trans}$: 发送一个**最大长度帧所需的时间**。
    *   效率的近似公式为: $\text{efficiency} = \frac{1}{1 + 5 \frac{t_{prop}}{t_{trans}}}$
        (这里的常数5是一个经验值，不同文献可能有略微差异，但核心思想是效率与 $t_{prop}/t_{trans}$ 的比值成反比)。
        更常见的表达是与 $a = t_{prop}/t_{trans}$ 相关，当 $a \to 0$ 时效率趋于1。
    * **如何提高效率**:
        * **减小 $t_{prop}$**: 意味着网络物理范围更小，或者信号传播速度更快。
        * **增大 $t_{trans}$**: 意味着帧更长，或者信道速率更低（但这与我们追求高速率的目标矛盾）。实际上，为了保证 `CSMA/CD` 的有效性（即在发送完最短帧之前必须能检测到碰撞），以太网对**最小帧长**有要求。如果帧太短，可能在发送完成前，最远端发生的碰撞信号还没传回来。
    *   当 $t_{prop} \to 0$ (传播延迟极小) 或者 $t_{trans} \to \infty$ (帧非常长)，效率趋向于1。
    *   总的来说，`CSMA/CD` 性能优于 `ALOHA`，并且实现简单、廉价、分散，因此在早期的有线以太网中非常成功。
    * **然而，随着交换式以太网的普及，每个端口都是一个独立的碰撞域（或者说，与交换机构成点对点全双工链路），`CSMA/CD` 的碰撞检测和退避机制在现代交换网络中已不再是主要的运行模式。**

---
##### 3.4.3 轮流协议 ("Taking Turns" MAC Protocols) 

轮流协议试图在高负载和低负载情况下都获得较好的性能。

* **回顾信道划分协议**:
    *   优点：在高负载时，能公平且高效地共享信道（每个节点都有保证的份额）。
    *   缺点：在低负载时效率低下。如果只有一个节点活跃，它仍然只能使用分配给它的那一份带宽（例如 $1/N$），并且可能需要等待它的轮次，引入接入延迟。
* **回顾随机接入协议**:
    *   优点：在低负载时效率高，单个节点可以充分利用信道。
    *   缺点：在高负载时，碰撞开销显著增加。
* **轮流协议的目标**: $\boxed{ \text{寻求两全其美 !} }$

###### a) 轮询

* **原理**:
    *   有一个**主节点** 和多个**从节点**。
    *   主节点依次“邀请” (轮询) 每个从节点，询问它们是否有数据要发送。
    *   被轮询到的从节点，如果它有数据，就发送给主节点（或者通过主节点转发给其他节点）。如果没数据，就回应一个否定信息。
    *   主节点控制着整个发送的顺序和时机。
* **典型应用**:
    *   常用于一些主从式控制系统，或者需要与许多“哑”终端 通信的场景。
    *   例如，某些工业控制网络，或者早期的计算机终端系统。
* **关注点 (Concerns)**:
    1.**轮询开销 (Polling overhead)**: 轮询本身需要占用信道时间（发送轮询请求，接收从节点响应）。如果节点很多或者数据量小，这个开销可能比较大。
    2.**延迟 (Latency)**: 从节点必须等待被主节点轮询到才能发送数据，这会引入延迟。
    3.**单点故障**: 如果主节点发生故障，整个网络就瘫痪了。

###### b) 令牌传递 (Token Passing) 

* **原理**:
    *   一个特殊的小控制帧，称为**令牌**，在网络中的节点之间按预定的顺序循环传递。
    *   只有持有令牌的节点才有权发送数据。
    *   当一个节点接收到令牌后：
        *   如果它有数据要发送，它可以持有令牌一段时间（或发送一定数量的帧），然后将数据发送出去。发送完毕后，它必须将令牌传递给下一个节点。
        *   如果它没有数据要发送，它立即将令牌传递给下一个节点。
* **典型应用**:
    *   令牌环网 (Token Ring, IEEE 802.5)
    *   FDDI (Fiber Distributed Data Interface)
* **关注点**:
    1.**令牌开销**: 令牌本身也需要传输时间。
    2.**延迟**: 节点必须等待令牌到达才能发送。在低负载时，即使信道空闲，节点也可能因为没拿到令牌而无法立即发送。
    3.**单点故障**: 如果令牌丢失了（例如，持有令牌的节点突然崩溃），或者在传递过程中损坏，网络就无法正常工作，需要复杂的恢复机制来重新生成令牌。

---
#### 3.5 DOCSIS：有线电视网络中的混合接入 

`DOCSIS` (Data Over Cable Service Interface Specification) 是有线电视 (CATV) 网络提供互联网接入服务的标准。它巧妙地结合了 `FDM`、`TDM` 和随机接入的思想。

* **网络结构**:
    * **电缆调制解调器终端系统 (CMTS - Cable Modem Termination System)**:位于有线电视公司的头端 ，连接到 `ISP`。
    * **电缆调制解调器 (Cable Modem)**: 位于用户家中。
    *   使用同轴电缆在 `CMTS` 和用户Cable Modem之间传输数据。
    *   ![](Pic/Pasted%20image%2020250524203932.png)

* **信道分配**:
    * **下行信道 (Downstream, CMTS $\to$ 用户)**:
        *   `CMTS` 向所有用户广播数据。
        *   采用**FDM** 将可用频谱划分为多个下行信道 (例如，每个信道带宽6MHz，可以承载高达 1.6 Gbps 的数据，具体速率取决于调制方式和标准版本)。
        *   一个 `CMTS` 可以同时在多个下行FDM信道上发送数据。
        *   在每个FDM信道内，数据通常以**TDM** 方式发送给不同的用户（或者说，用户Cable Modem只接收发给自己的数据包）。
    * **上行信道 (Upstream, 用户 $\to$ CMTS)**:
        *   多个用户共享上行信道。
        *   也采用**FDM** 将可用频谱划分为多个上行信道 (例如，每个信道带宽可配置，速率可达 1 Gbps)。
        * **关键在于上行信道的介质访问控制**:
            *   `CMTS` 在下行信道上发送**MAP 帧 (MAP frame)**，该帧告诉用户Cable Modem在接下来的上行时间段内，哪些时隙是分配给特定用户（**TDM 方式，用于保证带宽的服务**），哪些时隙是可供竞争的（**随机接入方式，用于突发数据**）。
            *   对于竞争时隙，用户Cable Modem通常使用一种基于**时隙 ALOHA 或 CSMA 的变种协议**（带有二进制指数退避）来发送**带宽请求**。
            *   `CMTS` 收到请求后，会在后续的 `MAP` 帧中为该用户分配专门的发送时隙。
            *   ![](Pic/Pasted%20image%2020250524203908.png)
*   DOCSIS 上行接入是一个典型的混合方案：CMTS 通过 MAP 帧进行集中控制，部分时隙采用 TDM 分配，部分时隙采用随机接入（通常是带请求的、有控制的随机接入）来共享。

---
#### 3.6 MAC 协议总结 

我们已经学习了三大类多路访问控制协议：

1.**信道划分**:
    *   通过时间 (TDMA)、频率 (FDMA) 或码 (CDMA) 来划分。
    *   优点：公平，无冲突，保证性能。
    *   缺点：低负载时资源浪费，不够灵活。
2.**随机接入** (动态的):
    *   `ALOHA`, `S-ALOHA` , `CSMA`, `CSMA/CD`, `CSMA/CA`。
    * **载波侦听**: 在有线技术中容易实现，在无线中困难。
    *   `CSMA/CD` 曾是以太网的核心。
    *   `CSMA/CA` 是 `802.11 WiFi` 的核心。
    *   优点：低负载时高效，简单分散。
    *   缺点：高负载时碰撞增多，性能下降。
3.**轮流**:
    *   轮询。
    *   令牌传递 (如 `Bluetooth`, `FDDI`, Token Ring)。
    *   试图在高负载和低负载下都取得较好性能。
    *   优点：比信道划分更灵活，比随机接入在高负载下更稳定。
    *   缺点：有开销（轮询、令牌传递），有延迟，可能存在单点故障。

选择哪种 `MAC` 协议取决于具体的网络环境、负载特性、性能要求以及成本考虑。

---