# 第八章 网络安全 🛡️

你好！欢迎来到第八章的学习。在前面的章节中，我们已经了解了网络如何让我们方便地进行通信和获取信息。但是，便利性的背后也潜藏着各种安全风险。想象一下，如果你的银行账户信息在网上传输时被窃取，或者你的私人邮件被他人窥探，那将是多么可怕的事情！本章，我们将一起探索网络安全的奥秘，学习如何构建更安全的网络，保护我们的数字生活。

**本章学习目标** 🎯：
1.  理解网络安全的基本原则，包括密码学的核心概念及其在“机密性”之外的多种用途、身份认证机制以及报文完整性的重要性。
2.  学习网络安全在实践中的应用，包括防火墙和入侵检测系统的工作原理，以及安全如何在应用层、运输层、网络层和链路层得到实现。

---

**【本章概览】**

1.  **什么是网络安全？** (了解安全的核心要素和面临的威胁)
2.  **密码学原理** (对称密钥、公钥密码体制，RSA算法等)
3.  **报文完整性与身份认证** (数字签名、报文摘要、证书颁发机构CA)
4.  **安全电子邮件** (PGP, S/MIME的基本思想)
5.  **安全套接字层：TLS** (保障TCP连接的安全)
6.  **网络层安全：IPsec** (为IP数据报提供安全服务)
7.  **无线与移动网络安全** (WiFi安全如WPA3，4G/5G安全机制)
8.  **运行安全：防火墙与入侵检测系统** (网络边界防护与威胁检测)

---

### 8.1 什么是网络安全？🤔

网络安全旨在保护网络及其承载的数据免受未经授权的访问、使用、泄露、破坏、修改或销毁，并确保网络的正常运行。

*   **机密性 (Confidentiality)**: 保证信息仅被授权的发送方和预期的接收方“理解”。
    *   实现方式：发送方加密报文，接收方解密报文。
*   **身份认证 (Authentication)**: 通信双方（发送方、接收方）希望确认对方的真实身份。
*   **报文完整性 (Message Integrity)**: 确保报文在传输过程中或之后未被篡改，或者任何篡改都能被检测到。
*   **访问与可用性 (Access and Availability)**: 确保授权用户能够访问服务，并且服务能够正常提供。例如，抵御拒绝服务攻击 (Denial of Service, DoS)。

(见幻灯片 8-4)

---

#### 8.1.1 网络安全中的“角色”：Alice, Bob 和 Trudy 👥

在讨论网络安全时，我们经常使用一些经典角色来帮助理解：

*   **Alice** 和 **Bob**: 两位希望安全通信的合法用户（他们可能是恋人、同事、或者任何需要保密通信的双方）。
*   **Trudy**: 一位入侵者（intruder），她可能会：
    *   **窃听 (Eavesdrop)**: 截获Alice和Bob之间的报文。
    *   **插入 (Insert)**: 主动向连接中插入伪造的报文。
    *   **删除 (Delete)**: 删除Alice和Bob之间的报文。
    *   **修改 (Modify/Alter)**: 篡改Alice和Bob之间的报文。

(见幻灯片 8-5)

![](https://i.imgur.com/gDqJj1c.png)
*图：Alice、Bob 通过不安全信道通信，Trudy 可能进行窃听和篡改*

**Alice 和 Bob 在现实中可能是谁？**

*   任何进行在线交易的Web浏览器和服务器（例如网上购物）。
*   在线银行的客户端和服务器。
*   DNS服务器之间交换信息。
*   BGP路由器之间交换路由表更新。
*   以及你我这样的普通互联网用户！

(见幻灯片 8-6)

#### 8.1.2 “坏人”能做什么？😈

网络中的攻击者 (Trudy) 可以进行多种恶意活动：

*   **窃听 (Eavesdrop)**: 截获报文。
*   **主动插入报文 (Actively insert messages)**: 向连接中注入虚假信息。
*   **冒充 (Impersonation)**: 伪造（欺骗）源IP地址或报文中的任何字段，假冒他人身份。
*   **劫持 (Hijacking)**: “接管”一个正在进行的连接，将合法的发送方或接收方替换成攻击者自己。
*   **拒绝服务 (Denial of Service, DoS)**: 通过使服务过载（例如发送大量请求）或利用漏洞，阻止合法用户使用服务。

(见幻灯片 8-7)

---

### 8.2 密码学原理：安全通信的基石 🧱

密码学 (Cryptography) 是研究信息加密、解密以及信息安全的学科，它是实现网络安全的数学基础。

#### 8.2.1 密码学术语 📜

*   **明文 (Plaintext)**: 原始的可读报文，用 $m$ 表示。
*   **密文 (Ciphertext)**: 明文经过加密算法处理后生成的不可读报文，通常表示为 $K_A(m)$ (如果用Alice的密钥 $K_A$ 加密) 或 $K_B(m)$ (如果用Bob的密钥 $K_B$ 加密)。
*   **加密算法 (Encryption Algorithm)**: 将明文转换为密文的算法。
*   **解密算法 (Decryption Algorithm)**: 将密文还原为明文的算法。
*   **密钥 (Key)**: 控制加密和解密过程的参数。
    *   $K_A$: Alice使用的密钥。
    *   $K_B$: Bob使用的密钥。

(见幻灯片 8-9)

![](https://i.imgur.com/JjQv92q.png)
*图：密码学基本通信模型*

Alice 加密明文 $m$ 得到密文 $K_A(m)$。Bob 接收到密文后，使用密钥 $K_B$ 解密，理想情况下得到原始明文 $m = K_B(K_A(m))$。

#### 8.2.2 密码体制的分类

主要分为两大类：对称密钥密码体制和公钥密码体制。

##### 8.2.2.1 对称密钥密码体制 (Symmetric Key Cryptography)

在这种体制中，**发送方和接收方使用相同的密钥**进行加密和解密。这个共享的密钥必须保密。

*   令 $K_S$ 为Alice和Bob共享的对称密钥。
*   Alice加密：$ciphertext = K_S(m)$
*   Bob解密：$m = K_S(ciphertext)$
*   **核心问题**: $\boxed{ \text{Alice 和 Bob 如何安全地商定并共享这个密钥 } K_S \text{？} }$ (密钥分发问题)

(见幻灯片 8-11)

![](https://i.imgur.com/zR0cQJz.png)
*图：对称密钥密码体制*

*   **简单加密方案：替换密码 (Substitution Cipher)**
    *   **单表替换密码 (Monoalphabetic Cipher)**: 将明文字母表中的每个字母替换为密文字母表中的另一个确定字母。
        *   例如：明文 `abcdefghijklmnopqrstuvwxyz`
        *   密文 `mnbvcxzasdfghjklpoiuytrewq`
        *   `bob. i love you. alice` 会被加密成 `nkn. s gktc wky. mgsbc`
        *   **密钥**: 字母表的映射关系。总共有 $26!$ 种可能的密钥，数量巨大。
        *   **弱点**: 容易受到统计分析攻击（例如频率分析）。
    (见幻灯片 8-12)

*   **更复杂的加密方法：多表替换**
    *   使用 $n$ 个替换密码 $M_1, M_2, \dots, M_n$。
    *   按照一个循环模式来选择使用哪个替换密码。
        *   例如，模式 $M_1, M_3, M_4, M_3, M_2; M_1, M_3, M_4, M_3, M_2; \dots$
        *   加密 "dog"：d 用 $M_1$ 加密，o 用 $M_3$ 加密，g 用 $M_4$ 加密。
    *   **密钥**: $n$ 个替换密码表和循环模式。
    (见幻灯片 8-13)

*   **数据加密标准 DES (Data Encryption Standard)**
    *   美国国家标准局 (NIST) 于1993年颁布的美国加密标准。
    *   使用 **56位对称密钥**，对 **64位明文输入** 进行分组加密。
    *   是一种**分组密码 (Block Cipher)**，通常与**密码分组链接 (Cipher Block Chaining, CBC)**模式结合使用，使得每个密文块依赖于之前的明文块，增加安全性。
    *   **DES的安全性**:
        *   DES挑战赛：通过暴力破解（尝试所有 $2^{56}$ 个密钥），56位密钥加密的短语在一天内被破解。
        *   虽然没有已知的有效分析攻击方法，但56位密钥长度在现代计算能力下已不再安全。
    *   **增强DES安全性**:
        *   **3DES (Triple DES)**: 使用3个不同的密钥，对数据进行三次DES操作（加密-解密-加密）。有效密钥长度为 $56 \times 2 = 112$ 位或 $56 \times 3 = 168$ 位，显著提高了安全性。
    (见幻灯片 8-14)

*   **高级加密标准 AES (Advanced Encryption Standard)**
    *   NIST选择的对称密钥标准，于2001年11月取代DES。
    *   处理128位的明文数据块。
    *   密钥长度可以是 **128位、192位或256位**。
    *   **安全性**: 如果用破解DES需要1秒的计算能力来暴力破解AES：
        *   对于128位AES密钥，大约需要149万亿年！
    (见幻灯片 8-15)

##### 8.2.2.2 公钥密码体制 (Public Key Cryptography)

公钥密码体制是密码学领域的一项革命性进展，由Diffie和Hellman在1976年以及RSA的作者们在1978年提出。

*   **与对称密钥的区别**:
    *   对称密钥：发送方和接收方需要共享一个秘密密钥。如何安全地商定这个密钥是一个难题，尤其是在双方从未见过面的情况下。
    *   公钥密码：发送方和接收方**不需要**共享秘密密钥。
*   **密钥对**: 每个用户拥有一对密钥：
    *   **公钥 ($K^+$)**: 可以公开给任何人。
    *   **私钥 ($K^-$)**: 必须由用户自己保密。
*   **加密过程 (以Bob接收Alice的保密信息为例)**:
    1.  Bob生成一对密钥：公钥 $K_B^+$ 和私钥 $K_B^-$。
    2.  Bob将他的公钥 $K_B^+$ 公开（例如，发布在网站上，或通过邮件列表发送）。
    3.  Alice想给Bob发送保密信息 $m$。她使用Bob的**公钥** $K_B^+$ 来加密信息：$ciphertext = K_B^+(m)$。
    4.  Bob收到密文后，使用他自己的**私钥** $K_B^-$ 来解密：$m = K_B^-(ciphertext) = K_B^-(K_B^+(m))$。
    *   $\boxed{ \text{用公钥加密，用对应的私钥解密，用于实现机密性。} }$
    (见幻灯片 8-16, 8-17)

![](https://i.imgur.com/W4Zl03O.png)
*图：公钥密码体制 (机密性)*

*   **公钥加密算法的要求**:
    1.  需要找到一对密钥 $(K_B^+, K_B^-)$ 使得 $K_B^-(K_B^+(m)) = m$ 对所有明文 $m$ 成立。
    2.  $\boxed{ \text{在已知公钥 } K_B^+ \text{ 的情况下，计算出私钥 } K_B^- \text{ 在计算上是不可行的。} }$
    (见幻灯片 8-18)

*   **RSA算法 (Rivest, Shamir, Adelson)**: 是目前最著名和广泛使用的公钥密码算法。
    *   **基础：模运算 (Modular Arithmetic)**
        *   $x \pmod n$ 表示 $x$ 除以 $n$ 的余数。
        *   重要性质：
            *   $[(a \pmod n) + (b \pmod n)] \pmod n = (a+b) \pmod n$
            *   $[(a \pmod n) - (b \pmod n)] \pmod n = (a-b) \pmod n$
            *   $[(a \pmod n) \cdot (b \pmod n)] \pmod n = (a \cdot b) \pmod n$
            *   因此，$(a \pmod n)^d \pmod n = a^d \pmod n$
        *   例子：$x=14, n=10, d=2$。
            *   $(x \pmod n)^d \pmod n = (14 \pmod{10})^2 \pmod{10} = 4^2 \pmod{10} = 16 \pmod{10} = 6$
            *   $x^d \pmod n = 14^2 \pmod{10} = 196 \pmod{10} = 6$
        (见幻灯片 8-19)

    *   **RSA准备工作**:
        *   报文 $m$ 是一个比特模式，可以唯一地表示为一个整数。
        *   因此，加密报文等价于加密一个数字。
        *   例如：$m = 10010001_2 = 145_{10}$。加密 $m$ 就是加密数字145，得到一个新的数字（密文）。
        (见幻灯片 8-20)

    *   **RSA密钥对的生成**:
        1.  选择两个非常大的素数 $p$ 和 $q$ (例如，各1024位)。
        2.  计算 $n = p \cdot q$ 和 $z = (p-1)(q-1)$。
        3.  选择一个整数 $e$ (通常 $e < n$)，使得 $e$ 与 $z$ 互素（即它们没有公因子，除了1）。$e$ 通常选为较小的奇数，如 $65537 (2^{16}+1)$。
        4.  选择一个整数 $d$，使得 $ed - 1$ 能够被 $z$ 整除。也就是说，$ed \pmod z = 1$。$d$ 是 $e$ 模 $z$ 的乘法逆元。
        5.  $\boxed{ \text{公钥是 } (n,e) \text{，私钥是 } (n,d) \text{。} }$
        (见幻灯片 8-21)

    *   **RSA加密与解密**:
        *   设明文报文（整数表示）为 $m$，且 $m < n$。
        *   **加密**: $c = m^e \pmod n$ (使用公钥 $(n,e)$)
        *   **解密**: $m = c^d \pmod n$ (使用私钥 $(n,d)$)
        *   $\boxed{ \text{最终可以证明 } m = (m^e \pmod n)^d \pmod n \text{。} }$
        (见幻灯片 8-22)

    *   **RSA示例**:
        *   Bob选择 $p=5, q=7$。则 $n=35, z=(5-1)(7-1)=24$。
        *   选择 $e=5$ (与24互素)。
        *   计算 $d$ 使得 $5d \pmod{24} = 1$。可以找到 $d=29$ (因为 $5 \times 29 = 145 = 6 \times 24 + 1$)。
        *   公钥为 $(35, 5)$，私钥为 $(35, 29)$。
        *   加密8位报文，例如 $m=12$ (二进制 $00001100$)。
            *   加密: $c = 12^5 \pmod{35} = 248832 \pmod{35} = 17$。
            *   解密: $m = 17^{29} \pmod{35}$。
                *   $17^{29} \pmod{35}$ 计算会非常大，但可以通过模幂运算（如反复平方法）高效计算。
                *   $17^{29} \pmod{35} = 12$。
        (见幻灯片 8-23，图中 $17^{29}$ 的值为 $481968572106750915091411825223071697$)
        ![](https://i.imgur.com/g0xW37M.png)

    *   **RSA为什么能工作？(数学原理)**
        *   需要证明 $c^d \pmod n = (m^e)^d \pmod n = m^{ed} \pmod n = m$。
        *   这依赖于数论中的欧拉定理或费马小定理的推广。关键在于 $ed \equiv 1 \pmod z$，即 $ed = k \cdot z + 1$ 对于某个整数 $k$。
        *   所以 $m^{ed} \equiv m^{k \cdot z + 1} \equiv (m^z)^k \cdot m \pmod n$。
        *   如果 $m$ 与 $n$ 互素，则 $m^z \equiv m^{(p-1)(q-1)} \equiv 1 \pmod n$ (欧拉定理)。
        *   因此 $m^{ed} \equiv 1^k \cdot m \equiv m \pmod n$。
        *   如果 $m$ 不与 $n$ 互素（即 $m$ 是 $p$ 或 $q$ 的倍数），该等式仍然成立，需要更复杂的证明或使用中国剩余定理。
        *   幻灯片 8-24 给出了一个基于 $x^y \pmod n = x^{(y \pmod z)} \pmod n$ 的简化解释：
            $c^d \pmod n = (m^e \pmod n)^d \pmod n = m^{ed} \pmod n$
            $= m^{(ed \pmod z)} \pmod n$ (因为 $ed \equiv 1 \pmod z$)
            $= m^1 \pmod n = m \pmod n$
        (见幻灯片 8-24)

    *   **RSA的另一个重要性质 (用于数字签名)**:
        $\boxed{ K_B^-(K_B^+(m)) = K_B^+(K_B^-(m)) = m }$
        也就是说，用公钥加密再用私钥解密，等同于，用私钥“加密”（签名）再用公钥“解密”（验证）。
        *   $K_B^+(m) = m^e \pmod n$ (用公钥加密)
        *   $K_B^-(m) = m^d \pmod n$ (用私钥加密/签名)
        *   所以， $(m^e \pmod n)^d \pmod n = m^{ed} \pmod n = m$
        *   并且， $(m^d \pmod n)^e \pmod n = m^{de} \pmod n = m$
        *   $\boxed{ \text{用私钥加密，用对应的公钥解密，用于实现数字签名和身份认证。} }$
        (见幻灯片 8-25, 8-26)

    *   **RSA的安全性**:
        *   依赖于**大整数分解的困难性**。
        *   如果攻击者Trudy知道Bob的公钥 $(n,e)$，她想确定私钥中的 $d$。
        *   这本质上需要找到 $n$ 的因子 $p$ 和 $q$，从而计算出 $z=(p-1)(q-1)$，然后才能从 $e$ 计算出 $d$。
        *   目前没有已知的快速分解大整数的经典算法。量子计算机（如果建成）上的Shor算法可以快速分解大整数，对RSA构成潜在威胁。
        (见幻灯片 8-27)

*   **RSA在实践中的使用：会话密钥 (Session Keys)**
    *   RSA中的模幂运算计算量很大，比对称加密（如DES, AES）慢得多（至少慢100倍）。
    *   因此，在实际应用中，通常不直接用RSA加密大量数据。
    *   **常用方法**:
        1.  使用公钥密码（如RSA）来建立一个安全的连接，并协商或交换一个**对称的会话密钥 $K_S$**。
        2.  一旦双方都有了会话密钥 $K_S$，就使用更快速的对称加密算法（如AES）来加密后续的实际数据。
        *   例如，Alice想给Bob发送大量数据。Alice生成一个随机的对称会话密钥 $K_S$。她用Bob的公钥 $K_B^+$ 加密 $K_S$，得到 $K_B^+(K_S)$，发送给Bob。Bob用自己的私钥 $K_B^-$ 解密得到 $K_S$。之后，Alice和Bob就用 $K_S$ 通过对称加密进行通信。
    (见幻灯片 8-28)

#### 8.2.3 破解加密方案的常见攻击类型

*   **仅密文攻击 (Ciphertext-only attack)**: Trudy只有一些截获的密文。她尝试通过分析密文来恢复明文或密钥。
*   **已知明文攻击 (Known-plaintext attack)**: Trudy拥有一些（或许多）明文-密文对。
    *   例如，在单表替换密码中，如果Trudy知道某些常用词（如 "the", "alice", "bob"）对应的密文，她就可以推断出一些字母的映射关系。
*   **选择明文攻击 (Chosen-plaintext attack)**: Trudy可以选择一些特定的明文，并获得它们对应的密文。这对密码分析者来说是最有利的条件。
*   **攻击方法**:
    *   **暴力破解 (Brute force)**: 尝试所有可能的密钥。对称密钥长度越长，越难暴力破解。
    *   **统计分析 (Statistical analysis)**: 分析密文的统计特性（如字母频率、词频）来推断明文或密钥。对简单替换密码有效。

(见幻灯片 8-10)

---

### 8.3 报文完整性与身份认证：验明正身，防止篡改 🛡️

除了机密性，我们还需要确保报文在传输过程中没有被篡改（完整性），并且通信方的身份是真实的（身份认证）。

(见幻灯片 8-29)

#### 8.3.1 身份认证 (Authentication)

目标：Bob希望Alice能向他“证明”她的身份。

*   **协议 ap1.0**: Alice说：“我是Alice”。
    *   **缺陷**: Trudy可以简单地声称自己是Alice。在网络中，Bob无法“看见”Alice。
    (见幻灯片 8-30, 8-31 - 狗狗上网的漫画很经典：“在互联网上，没人知道你是一条狗。”)
    ![](https://i.imgur.com/nC4v7U9.png)
*   **协议 ap2.0**: Alice在一个包含她源IP地址的IP包中说“我是Alice”。
    *   **缺陷**: Trudy可以**IP欺骗 (IP spoofing)**，伪造源IP地址为Alice的IP地址。
    (见幻灯片 8-32, 8-33)
*   **协议 ap3.0**: Alice说“我是Alice”，并发送她的秘密口令来“证明”。
    *   **缺陷**: **重放攻击 (Playback attack)**。Trudy可以录下Alice发送的包含口令的包，然后在稍后重放给Bob，冒充Alice。即使口令是加密的，如果Trudy能录下加密后的口令并重放，而Bob只是简单地检查加密口令是否与存储的加密口令匹配，那么重放攻击仍然有效。
    (见幻灯片 8-34, 8-35, 8-36, 8-37)
    ![](https://i.imgur.com/x2G5N6b.png)
*   **协议 ap4.0 (使用一次性随机数 Nonce)**: 为了防止重放攻击，引入不重复的随机数。
    *   目标：证明Alice是“活的”(live)，并且知道共享密钥。
    *   **Nonce (R)**: 一个只使用一次的数字 (Number used once)。
    *   流程：
        1.  Alice说：“我是Alice”。
        2.  Bob发送一个Nonce $R$ 给Alice。
        3.  Alice必须返回用她和Bob共享的对称密钥 $K_{A-B}$ 加密的 $R$，即 $K_{A-B}(R)$。
        4.  Bob收到后，用 $K_{A-B}$ 解密，如果得到原来的 $R$，则认证成功。
    *   因为 $R$ 是Bob刚生成的，Trudy无法提前录制 $K_{A-B}(R)$。只有知道 $K_{A-B}$ 且“在线”的Alice才能正确加密 $R$。
    *   **缺点**: 仍然需要Alice和Bob预先共享一个对称密钥 $K_{A-B}$。
    (见幻灯片 8-38)
    ![](https://i.imgur.com/m9w1pL0.png)
*   **协议 ap5.0 (使用公钥和Nonce进行身份认证)**:
    *   流程：
        1.  Alice说：“我是Alice”。
        2.  Bob发送一个Nonce $R$ 给Alice。
        3.  Alice用她的**私钥** $K_A^-$ 加密 $R$，得到 $K_A^-(R)$，发送给Bob。
        4.  Bob拥有Alice的**公钥** $K_A^+$。他计算 $K_A^+(K_A^-(R))$，如果结果等于 $R$，则认证成功。
    *   只有拥有 $K_A^-$ 的Alice才能正确“签名” $R$。
    (见幻灯片 8-39)
    ![](https://i.imgur.com/0fXkCgJ.png)
*   **协议 ap5.0的缺陷：中间人攻击 (Man-in-the-Middle Attack)**
    *   Trudy截获Alice和Bob之间的通信。
    *   对Bob：Trudy冒充Alice。
        1.  Trudy说“我是Alice”给Bob。
        2.  Bob发送Nonce $R_B$ 给（Trudy以为的）Alice。
        3.  Trudy无法用 $K_A^-$ 加密 $R_B$。但Trudy可以告诉Bob她（Trudy）的公钥是 $K_T^+$ (冒充是Alice的公钥)。
        4.  或者，Trudy可以继续与Bob通信，同时对Alice冒充Bob。
    *   更经典的中间人攻击如下 (见幻灯片 8-40)：
        ![](https://i.imgur.com/f4Vb98d.png)
        1.  Alice $\to$ Trudy: "我是Alice" (想发给Bob)
        2.  Trudy $\to$ Bob: "我是Alice" (用自己的身份，但声称是Alice)
        3.  Bob $\to$ Trudy: (发送Nonce $R$ 给"Alice")
        4.  Trudy $\to$ Alice: (冒充Bob，发送同样的Nonce $R$ 给Alice，或者新的Nonce $R'$)
        5.  Alice $\to$ Trudy: (用 $K_A^-$ 加密 $R$ 或 $R'$，发给"Bob")
        6.  Trudy $\to$ Bob: (如果Trudy在第4步转发的是Bob的Nonce $R$，现在她无法用 $K_A^-$ 计算 $K_A^-(R)$。她只能用自己的私钥 $K_T^-$ 计算 $K_T^-(R)$，然后发给Bob，同时告诉Bob她的公钥 $K_T^+$ 是Alice的公钥。Bob用 $K_T^+$ 验证 $K_T^-(R)$ 得到 $R$，就会误以为Trudy是Alice。)
    *   **核心问题**: $\boxed{ \text{Bob如何确信他得到的公钥 } K_A^+ \text{ 确实是Alice的，而不是Trudy的？} }$ 这就需要**公钥证书**。

#### 8.3.2 数字签名 (Digital Signatures)

数字签名提供了报文的**身份认证**（谁签的名）、**完整性**（报文未被篡改）和**不可否认性**（签名者不能否认自己签过名）。

*   **简单数字签名**: Bob想对报文 $m$ 进行数字签名。
    1.  Bob使用他的**私钥** $K_B^-$ “加密”报文 $m$，得到签名后的报文 $K_B^-(m)$。
    2.  Bob将原始报文 $m$ 和签名 $K_B^-(m)$ 一起发送给Alice。
    (见幻灯片 8-42)
    ![](https://i.imgur.com/F8i079z.png)
*   **Alice验证签名**:
    1.  Alice收到 $m$ 和 $K_B^-(m)$。
    2.  Alice使用Bob的**公钥** $K_B^+$ 对 $K_B^-(m)$ 进行“解密”操作，得到 $K_B^+(K_B^-(m))$。
    3.  如果结果等于原始报文 $m$，则签名验证成功。
*   **验证结果的含义**:
    *   Bob确实签署了报文 $m$ (因为只有Bob拥有 $K_B^-$)。
    *   没有其他人能签署 $m$ (冒充Bob)。
    *   Bob签署的是 $m$，而不是某个被篡改的 $m'$ (如果 $m$ 被篡改，验证会失败)。
*   **不可否认性 (Non-repudiation)**: Alice可以将 $m$ 和 $K_B^-(m)$ 作为证据，证明Bob确实发送了报文 $m$。
(见幻灯片 8-43)

#### 8.3.3 报文摘要 (Message Digests / Hash Functions)

直接用私钥加密整个长报文进行签名，计算开销很大。一个更有效的方法是先计算报文的“指纹”，然后对指纹进行签名。

*   **目标**: 为任意长度的报文 $m$ 计算出一个固定长度、易于计算的数字“指纹”，称为**报文摘要 (Message Digest)** 或**哈希值 (Hash Value)**，用 $H(m)$ 表示。
*   **密码学哈希函数的特性**:
    1.  **易于计算**: 给定 $m$，计算 $H(m)$ 很快。
    2.  **固定长度输出**: 无论 $m$多长，$H(m)$ 的长度是固定的（例如128位，160位，256位）。
    3.  **单向性/前像抵抗 (Pre-image resistance)**: 给定哈希值 $h$，在计算上难以找到一个报文 $m$ 使得 $H(m)=h$。
    4.  **第二前像抵抗 (Second pre-image resistance)**: 给定报文 $m_1$，在计算上难以找到另一个报文 $m_2 \neq m_1$ 使得 $H(m_1) = H(m_2)$。
    5.  **碰撞抵抗 (Collision resistance)**: 在计算上难以找到任意两个不同的报文 $m_1 \neq m_2$ 使得 $H(m_1) = H(m_2)$。
        *   (注：碰撞总是存在的，因为输入空间远大于输出空间（多对一映射），但“难以找到”是关键。)
*   **互联网校验和 (Internet Checksum)**: 这是一个简单的校验和算法，用于IP、TCP、UDP头部。它能检测一些错误，但**不是密码学安全的哈希函数**，因为它不满足上述后三条特性，很容易找到碰撞。
    *   例如，`IOU1` 和 `IOU9` (如果调整其他字节使其总和不变) 可能有相同的16位校验和。
    (见幻灯片 8-44, 8-45)

*   **数字签名 = 签名的报文摘要**
    1.  Bob计算报文 $m$ 的摘要 $H(m)$。
    2.  Bob用他的私钥 $K_B^-$ 对摘要进行签名：$K_B^-(H(m))$。
    3.  Bob将原始报文 $m$ 和签名的摘要 $K_B^-(H(m))$ 一起发送给Alice。
    4.  Alice收到后：
        a.  对收到的 $m'$ 重新计算摘要 $H(m')$。
        b.  用Bob的公钥 $K_B^+$ “解密”收到的签名 $K_B^-(H(m))$，得到 $H(m)_{verified} = K_B^+(K_B^-(H(m)))$。
        c.  比较 $H(m')$ 和 $H(m)_{verified}$。如果相等，则签名有效，报文完整性得到保证，发送者身份得到认证。
    (见幻灯片 8-46)
    ![](https://i.imgur.com/o9l2P8M.png)

*   **常用的哈希函数算法**:
    *   **MD5 (Message Digest 5)**: 由Ron Rivest设计，产生128位摘要。曾广泛使用，但现已发现其碰撞抵抗性被攻破，不应用于安全性要求高的场景（如数字签名）。(RFC 1321)
    *   **SHA-1 (Secure Hash Algorithm 1)**: 美国国家标准与技术研究院 (NIST) 标准，产生160位摘要。也曾广泛使用，但其碰撞抵抗性也已被攻破（尽管比MD5困难）。(FIPS PUB 180-1)
    *   **SHA-2家族 (SHA-224, SHA-256, SHA-384, SHA-512)**: 目前推荐使用的哈希算法，摘要长度更长，安全性更高。
    *   **SHA-3**: 最新的NIST标准，采用了与SHA-1/SHA-2不同的内部结构 (Keccak算法)。
    (见幻灯片 8-47)

#### 8.3.4 公钥证书与证书颁发机构 (CA)

回到之前ap5.0身份认证的问题：Bob如何确信他获得的公钥 $K_A^+$ 确实是Alice的？

*   **需求**: 需要一种机制来将公钥与其所有者（实体E，如个人、网站、路由器）绑定起来。
*   **证书颁发机构 (Certification Authority, CA)**: 一个受信任的第三方，负责验证实体的身份，并为其公钥签发**数字证书 (Digital Certificate)**。
*   **证书**:
    *   包含实体E的身份信息（如名称、域名）和其实体E的公钥 $K_E^+$。
    *   由CA使用CA自己的**私钥** $K_{CA}^-$ 对这些信息进行数字签名。
    *   证书的作用相当于CA说：“我（CA）证明，这个公钥 $K_E^+$ 确实属于实体E”。
*   **使用证书进行身份验证 (例如，Alice想获取Bob的公钥)**:
    1.  Alice从某个地方（例如Bob本人，或一个公共目录）获取Bob的证书。
    2.  证书中包含了Bob的公钥 $K_B^+$ 和CA对 $(Bob, K_B^+)$ 的签名。
    3.  Alice需要拥有CA的**公钥** $K_{CA}^+$ (这个公钥通常预装在操作系统或浏览器中，或者通过更高一级的CA证书获得，形成信任链)。
    4.  Alice使用 $K_{CA}^+$ 验证证书上CA的签名。
    5.  如果签名验证成功，Alice就可以信任证书中的 $K_B^+$ 确实是Bob的公钥。
    (见幻灯片 8-49, 8-50, 8-51)

![](https://i.imgur.com/Fh69k3u.png)
*图：CA为Bob的公钥签发证书*

![](https://i.imgur.com/c46E18k.png)
*图：Alice验证Bob的证书以获取其可信公钥*

**例子：Trudy的披萨恶作剧 (为什么需要CA)**
1.  Trudy创建了一封邮件订单：“亲爱的披萨店，请送4个意大利辣香肠披萨给我。谢谢，Bob。”
2.  Trudy用她自己的私钥 $K_T^-$ 对订单进行了签名。
3.  Trudy将订单和她的公钥 $K_T^+$ 一起发给披萨店，但声称这个公钥 $K_T^+$ 是Bob的公钥。
4.  披萨店用“Bob的”（实际上是Trudy的）公钥 $K_T^+$ 验证了签名（因为签名是用 $K_T^-$ 做的，所以能验证通过），然后高高兴兴地把4个披萨送给了Bob。
5.  可怜的Bob根本不喜欢意大利辣香肠披萨！
如果披萨店要求Bob提供由CA签发的证书，Trudy就无法得逞，因为CA不会为Trudy颁发一个声称公钥 $K_T^+$ 属于Bob的证书。
(见幻灯片 8-49)

---
### 8.4 安全电子邮件 📧

目标：Alice想给Bob发送一封电子邮件 $m$，要求：
1.  **机密性 (Confidentiality)**: 只有Bob能阅读邮件内容。
2.  **身份认证 (Authentication)**: Bob能确认邮件确实是Alice发送的。
3.  **完整性 (Integrity)**: Bob能确认邮件内容在传输过程中未被篡改。

#### 8.4.1 只保证机密性

*   **步骤**:
    1.  Alice生成一个一次性的**对称会话密钥 $K_S$**。
    2.  Alice用 $K_S$ 加密邮件内容 $m$，得到 $K_S(m)$。 (使用对称加密效率高)
    3.  Alice用Bob的**公钥 $K_B^+$** 加密会话密钥 $K_S$，得到 $K_B^+(K_S)$。 (用公钥加密密钥)
    4.  Alice将 $K_S(m)$ 和 $K_B^+(K_S)$ 一起发送给Bob。
*   **Bob接收和解密**:
    1.  Bob用自己的**私钥 $K_B^-$** 解密 $K_B^+(K_S)$，得到会话密钥 $K_S$。
    2.  Bob用会话密钥 $K_S$ 解密 $K_S(m)$，得到原始邮件内容 $m$。
(见幻灯片 8-53, 8-54)

![](https://i.imgur.com/t5T1X3s.png)
*图：安全邮件 - 机密性*

#### 8.4.2 只保证身份认证和完整性 (不保证机密性)

*   **步骤**:
    1.  Alice计算邮件 $m$ 的哈希值 $H(m)$。
    2.  Alice用她的**私钥 $K_A^-$** 对哈希值进行签名，得到 $K_A^-(H(m))$。
    3.  Alice将原始邮件 $m$ (明文) 和签名 $K_A^-(H(m))$ 一起发送给Bob。
*   **Bob接收和验证**:
    1.  Bob对收到的 $m'$ 重新计算哈希值 $H(m')$。
    2.  Bob用Alice的**公钥 $K_A^+$** “解密”收到的签名 $K_A^-(H(m))$，得到 $H(m)_{verified}$。
    3.  如果 $H(m') = H(m)_{verified}$，则身份认证成功，报文完整性得到保证。
(见幻灯片 8-55)
![](https://i.imgur.com/D8d7b2o.png)
*图：安全邮件 - 完整性与身份认证*

#### 8.4.3 同时保证机密性、身份认证和完整性

*   **步骤 (Alice发送)**:
    1.  Alice计算邮件 $m$ 的哈希值 $H(m)$。
    2.  Alice用她的**私钥 $K_A^-$** 对哈希值进行签名，得到数字签名 $S = K_A^-(H(m))$。
    3.  Alice将原始邮件 $m$ 和数字签名 $S$ 附加在一起，形成 $m' = (m, S)$。
    4.  Alice生成一个一次性的**对称会话密钥 $K_S$**。
    5.  Alice用 $K_S$ 加密 $m'$，得到 $C_1 = K_S(m')$。
    6.  Alice用Bob的**公钥 $K_B^+$** 加密会话密钥 $K_S$，得到 $C_2 = K_B^+(K_S)$。
    7.  Alice将 $C_1$ 和 $C_2$ 一起发送给Bob。
*   **步骤 (Bob接收)**: (请思考Bob的解密和验证步骤)
    1.  Bob用自己的**私钥 $K_B^-$** 解密 $C_2$，得到会话密钥 $K_S$。
    2.  Bob用会话密钥 $K_S$ 解密 $C_1$，得到 $m'=(m, S)$。
    3.  Bob从 $m'$ 中分离出 $m$ 和 $S=K_A^-(H(m))$。
    4.  Bob对收到的 $m$ 重新计算哈希值 $H(m_{received})$。
    5.  Bob用Alice的**公钥 $K_A^+$** “解密” $S$，得到 $H(m)_{verified}$。
    6.  如果 $H(m_{received}) = H(m)_{verified}$，则邮件确实来自Alice，内容未被篡改，并且内容是保密的。
(见幻灯片 8-56)
![](https://i.imgur.com/jXJ4R9n.png)
*图：安全邮件 - 机密性、完整性与身份认证 (简化流程)*

---

### 8.5 传输层安全性：TLS (Transport Layer Security) 🔒

TLS (及其前身SSL - Secure Sockets Layer) 是在TCP之上提供安全通信的协议，广泛用于Web安全 (HTTPS)。

*   **目标**: 为基于TCP的应用程序（如HTTP, FTP, SMTP）提供机密性、完整性和身份认证。
*   **位置**: 位于应用层和TCP层之间。
    *   应用层将数据交给TLS。
    *   TLS进行安全处理（加密、添加MAC等）后，将结果交给TCP。
    *   TCP将TLS处理后的数据段发送出去。
    *   接收端TCP收到数据段后交给TLS，TLS解密、验证后，将原始数据交给应用层。
*   **提供的服务**:
    *   **机密性**: 通过对称加密（如AES）。
    *   **完整性**: 通过报文认证码 (Message Authentication Code, MAC)，使用哈希函数（如SHA-256）和共享密钥计算。
    *   **身份认证**: 通过公钥证书（通常是服务器向客户端证明身份，客户端也可以向服务器证明身份）。
*   **历史**:
    *   早期研究：安全网络编程，安全套接字。
    *   SSL (Secure Socket Layer) 由Netscape开发，SSL 3.0是重要版本。
    *   TLS 1.0 (RFC 2246) 是SSL 3.0的标准化和改进。
    *   TLS 1.2 (RFC 5246, 2008) 曾是主流。
    *   **TLS 1.3 (RFC 8846, 2018)** 是最新版本，进行了显著改进，更安全、更高效。
(见幻灯片 8-58, 8-59)

#### 8.5.1 TLS工作流程概述 (以一个简化的“玩具”t-tls为例)

一个完整的TLS会话通常包括：握手阶段、密钥派生、数据传输、连接关闭。

1.  **握手阶段 (Handshake)**:
    *   客户端和服务器建立TCP连接。
    *   **身份认证**: 服务器向客户端发送其数字证书，客户端验证证书（检查CA签名、有效期、域名等）。客户端也可以向服务器发送证书（双向认证）。
    *   **协商密码套件 (Cipher Suite)**: 双方协商将使用的加密算法、哈希算法、密钥交换算法等。
    *   **密钥交换/生成**: 客户端和服务器安全地生成一个共享的**主密钥 (Master Secret, MS)**。这通常通过Diffie-Hellman密钥交换或基于RSA的密钥传输完成。
    *   例如，在简化的t-tls中：
        *   服务器 (Bob) 建立TCP连接后，向客户端 (Alice) 发送其证书。
        *   Alice验证证书，然后生成一个主密钥MS，用Bob的公钥加密后发送给Bob。
        *   Bob用私钥解密得到MS。
        *   (此简化版存在一些问题，如没有客户端认证，可能需要多个RTT)
    (见幻灯片 8-60, 8-61)

2.  **密钥派生 (Key Derivation)**:
    *   客户端和服务器使用共享的主密钥MS，通过一个**密钥派生函数 (Key Derivation Function, KDF)** 生成一套实际用于数据加密和MAC计算的**会话密钥**。
    *   通常会生成4个密钥：
        *   $K_c$: 客户端 $\to$ 服务器的加密密钥。
        *   $M_c$: 客户端 $\to$ 服务器的MAC密钥。
        *   $K_s$: 服务器 $\to$ 客户端的加密密钥。
        *   $M_s$: 服务器 $\to$ 客户端的MAC密钥。
    *   $\boxed{ \text{为不同方向和不同目的（加密 vs MAC）使用不同的密钥，可以增强安全性。} }$
    (见幻灯片 8-62)

3.  **数据传输 (Data Transfer)**:
    *   TCP是字节流协议，TLS将应用数据流分割成一系列**记录 (records)**。
    *   对每个记录：
        *   计算MAC值（例如，使用 $M_c$ 对客户端发出的记录计算MAC）。
        *   将数据和MAC一起用对称加密密钥（例如，使用 $K_c$）加密。
        *   形成TLS记录：`Kc( length | data | MAC )`
        *   为了防止重放攻击和重排序攻击，TLS记录通常包含序列号，该序列号也参与MAC计算。
    (见幻灯片 8-63, 8-64)

4.  **连接关闭 (Connection Closure)**:
    *   需要防止**截断攻击 (Truncation Attack)**，即攻击者过早地伪造TCP连接关闭。
    *   TLS使用特定类型的记录（例如，close_notify alert）来指示连接的正常关闭。
    *   关闭消息本身也受MAC保护。
    (见幻灯片 8-65)

#### 8.5.2 TLS与应用的关系

(见幻灯片 8-66)
![](https://i.imgur.com/E1mJv4Z.png)
*图：TLS在协议栈中的位置及与HTTP/QUIC的关系*

*   HTTP/1.0 和 HTTP/2 通常运行在TCP之上，可以通过TLS来保护，形成HTTPS。
*   HTTP/3 则运行在QUIC之上，而QUIC协议本身就集成了TLS 1.3的功能（运行在UDP之上）。

#### 8.5.3 TLS 1.3 简介

TLS 1.3 相比之前的版本，主要改进包括：

*   **更快的握手**:
    *   **1-RTT握手**: 对于初次连接，理想情况下只需要1个往返时间完成握手。
        1.  ClientHello: 客户端发送支持的密码套件、密钥共享数据（如Diffie-Hellman公钥）、可能的预共享密钥ID。
        2.  ServerHello: 服务器选择密码套件、发送其密钥共享数据、证书、并完成密钥交换。之后服务器可以立即发送加密的应用数据。
        3.  客户端验证证书，完成密钥交换，然后也可以发送加密的应用数据。
    (见幻灯片 8-68)
    *   **0-RTT握手**: 对于会话恢复（resumption），客户端可以在第一个消息（ClientHello）中就发送加密的应用数据。这使用了之前会话中建立的预共享密钥（Resumption Master Secret）。
        *   存在一定的重放攻击风险，适用于幂等请求 (如HTTP GET)。
    (见幻灯片 8-69)
*   **更强的安全性**:
    *   移除了过时和不安全的密码算法和特性（如静态RSA密钥交换、CBC模式加密、SHA-1、MD5等）。
    *   **密码套件 (Cipher Suite)** 选择更受限：TLS 1.3只支持5种推荐的AEAD (Authenticated Encryption with Associated Data) 密码套件，它们同时提供加密和认证。例如 `TLS_AES_128_GCM_SHA256`。
    *   强制要求使用**前向保密 (Forward Secrecy)** 的密钥交换算法（如Diffie-Hellman Ephemeral - DHE, Elliptic Curve DHE - ECDHE）。这意味着即使服务器的长期私钥泄露，过去的会话密钥也不会泄露。
    *   加密了更多的握手消息，减少信息泄露。
(见幻灯片 8-67)

---

### 8.6 网络层安全：IPsec (IP Security) 🌐🛡️

IPsec是一套在IP层提供安全服务的协议簇，它可以为IP数据报提供机密性、完整性、身份认证和抗重放保护。

*   **工作模式**:
    *   **传输模式 (Transport Mode)**: 通常用于端到端（主机到主机）的安全。只对IP数据报的**载荷 (payload)** 部分（即上层协议数据，如TCP段）进行加密和/或认证。原始IP头部基本保持不变（可能会修改协议字段）。
    *   **隧道模式 (Tunnel Mode)**: 通常用于构建VPN (Virtual Private Networks)，例如连接两个受保护的网络（路由器到路由器）或远程主机到受保护网络（主机到路由器）。将**整个原始IP数据报** (包括头部和载荷) 进行加密和/或认证，然后将其封装在一个**新的IP数据报**中。
    (见幻灯片 8-71)
    ![](https://i.imgur.com/rK03r9D.png)
    *图：IPsec传输模式 (左) vs 隧道模式 (右)*

*   **IPsec的两个核心协议**:
    1.  **认证头 (Authentication Header, AH)**: (RFC 4302)
        *   提供**无连接的完整性**、**数据源认证**和**抗重放保护**。
        *   $\boxed{ \text{AH不提供机密性 (不加密数据)。} }$
        *   它会计算一个MAC值，覆盖IP头部（部分易变字段除外）和整个IP载荷。
    2.  **封装安全载荷 (Encapsulating Security Payload, ESP)**: (RFC 4303)
        *   提供**机密性** (通过加密IP载荷)。
        *   也可以提供（可选的）无连接完整性、数据源认证和抗重放保护。
        *   ESP比AH使用更广泛，因为它能提供加密。
    (见幻灯片 8-72)

*   **安全关联 (Security Association, SA)**:
    *   IPsec操作的基础。SA是发送方和接收方之间关于如何保护它们之间通信的一组**协定和状态信息**。
    *   SA是**单向的** (simplex)。因此，两个实体间的双向安全通信至少需要两个SA（每个方向一个）。
    *   SA由三个参数唯一标识：
        1.  安全参数索引 (Security Parameter Index, SPI): 一个32位的值，用于在接收端标识SA。
        2.  目的IP地址。
        3.  安全协议标识符 (AH或ESP)。
    *   SA中存储的状态信息包括：
        *   序列号计数器 (用于抗重放)。
        *   AH/ESP使用的认证算法、加密算法和密钥。
        *   SA的生存期等。
    *   $\boxed{ \text{IP本身是无连接的，但IPsec通过SA引入了“连接”的概念来管理安全状态。} }$
    (见幻灯片 8-73)

*   **IPsec数据报格式 (以ESP隧道模式为例)**:
    `[ 新IP头 | ESP头 | 原始IP头 | 原始IP载荷 | ESP尾部 | ESP认证数据 ]`
    *   **新IP头**: 用于在公共网络中路由这个IPsec包。源/目IP是隧道端点（如VPN网关）。
    *   **ESP头**: 包含SPI和序列号。
    *   **原始IP头和载荷**: 被视为ESP的载荷，进行加密。
    *   **ESP尾部**: 包含填充 (Padding, 用于使数据长度满足加密算法块大小要求)、填充长度和下一个头部类型 (指原始IP载荷中的协议类型)。
    *   **ESP认证数据**: 一个可选的MAC值 (HMAC)，覆盖ESP头、原始IP数据报和ESP尾部，用于提供完整性和认证。
    (见幻灯片 8-74)
    ![](https://i.imgur.com/gq3hM1d.png)
    *图：ESP隧道模式数据报结构 (简化版)*

*   **IPsec操作 (ESP隧道模式，路由器R1发送)**: (见幻灯片 8-75)
    1.  R1从内部网络收到一个原始IP数据报。
    2.  R1查找SPD (Security Policy Database) 确定该数据报需要IPsec保护，并查找SAD (Security Association Database) 找到对应的SA。
    3.  R1将ESP尾部附加到原始数据报后。
    4.  使用SA中指定的加密算法和密钥，对[原始IP头 | 原始IP载荷 | ESP尾部]进行加密。
    5.  在加密部分前加上ESP头（包含SPI和序列号）。
    6.  如果需要认证，使用SA中指定的认证算法和密钥，计算整个[ESP头 | 加密部分]的MAC值，作为ESP认证数据附加在末尾。
    7.  构造新的IP头部（源IP为R1的外部接口，目的IP为隧道另一端点如R2的外部接口），将整个ESP包作为新IP数据报的载荷发送出去。

*   **IPsec序列号**: 用于防止重放攻击。发送方在每个包中递增序列号，接收方使用一个窗口来检查序列号是否有效。

*   **IPsec数据库**:
    *   **安全策略数据库 (SPD - Security Policy Database)**: 定义了对哪些IP流量应用何种IPsec保护（或不应用）。策略基于源/目IP、协议、端口等。决定“**什么**”流量需要保护。
    *   **安全关联数据库 (SAD - Security Association Database)**: 存储所有活动SA的参数（密钥、算法、SPI、序列号计数器等）。决定“**如何**”保护流量。
    (见幻灯片 8-77)

*   **因特网密钥交换 (IKE - Internet Key Exchange)**:
    *   手动配置SA在大型网络中不切实际。
    *   IKE是一个复杂的协议，用于动态协商和建立IPsec SA，包括认证通信方、协商加密/认证算法、生成和分发密钥。
    *   IKE可以使用**预共享密钥 (Pre-Shared Key, PSK)** 或**公钥证书 (PKI)** 进行身份认证。
    *   IKE通常分两个阶段：
        *   **阶段1**: 建立一个安全的IKE SA (也叫ISAKMP SA)，用于保护后续的IKE协商。可以工作在主模式 (Main Mode) 或积极模式 (Aggressive Mode)。
        *   **阶段2**: 在已建立的IKE SA的保护下，协商实际用于数据传输的IPsec SA (AH或ESP的SA)。
    (见幻灯片 8-79, 8-80, 8-81)

---

### 8.7 无线与移动网络安全 📶🔐

无线链路由于其广播特性，更容易受到窃听和未经授权的访问。

#### 8.7.1 IEEE 802.11 (WiFi) 安全

当一个移动设备加入一个802.11无线局域网 (WLAN) 时，需要：
1.  **关联 (Associate)**: 与接入点 (Access Point, AP) 建立无线链路通信。
2.  **认证 (Authenticate)**: 向网络证明自己的身份，并（理想情况下）认证网络。

*   **WiFi安全发展历程**:
    *   **WEP (Wired Equivalent Privacy)**: 最早的安全协议，存在严重漏洞，已被弃用。
    *   **WPA (Wi-Fi Protected Access)**: 作为WEP的过渡替代方案，修复了WEP的一些漏洞，使用TKIP加密。
    *   **WPA2 (IEEE 802.11i)**: 更强的安全标准，使用AES-CCMP加密，是长期推荐的标准。
    *   **WPA3**: 最新的标准，提供更强的保护，例如针对暴力破解的保护，以及开放网络中的机会性加密。

*   **802.1X认证框架**:
    *   802.11i (WPA2/WPA3) 通常使用IEEE 802.1X端口访问控制协议进行认证。
    *   涉及三个角色：
        *   **申请者 (Supplicant)**: 移动设备。
        *   **认证者 (Authenticator)**: AP。
        *   **认证服务器 (Authentication Server, AS)**: 通常是一个RADIUS (Remote Authentication Dial-In User Service) 服务器，存储用户凭据。
    *   **EAP (Extensible Authentication Protocol)**: (RFC 3748) 在申请者和AS之间传输认证信息。AP通常作为EAP消息的传递者（EAP over LAN, EAPoL）。
    (见幻灯片 8-90)

*   **WPA3认证和密钥派生过程 (简化概述)**: (见幻灯片 8-84 至 8-89)
    1.  **发现安全能力**: 设备和AP交换它们支持的安全机制。
    2.  **相互认证和共享对称密钥派生 (SAE - Simultaneous Authentication of Equals)**:
        *   在WPA3-Personal中，SAE (也称Dragonfly握手) 允许设备和AP基于一个共享的预设密码 (PSK，即WiFi密码) 安全地派生出会话密钥，同时能抵抗离线字典攻击。
        *   在WPA3-Enterprise中，使用802.1X/EAP与AS进行认证，AS会生成一个主会话密钥 (MSK)。
    3.  **会话密钥分发**: AS (如果使用) 将会话密钥安全地分发给AP。
    4.  **加密通信**: 设备和AP使用派生出的会话密钥（例如，成对主密钥PMK进一步派生出成对瞬时密钥PTK）通过AES-CCMP等方式加密所有无线数据帧。

    *   **WPA3握手示例 (概念性)**: (幻灯片 8-87展示了一个简化的基于初始共享密钥的nonce交换和HMAC过程，用于派生会话密钥 $K_{M-AP}$。这与SAE的实际流程有所不同，但说明了通过共享秘密和nonce交换来建立会话密钥的基本思想。)
    ![](https://i.imgur.com/RjNfW9J.png)
    *图：WPA3握手概念图（AS和Mobile之间通过初始共享密钥和Nonce派生会话密钥）*

#### 8.7.2 4G/5G 蜂窝网络安全

4G (LTE) 和 5G网络具有更复杂的安全架构，涉及到核心网元。

*   **基本流程**:
    *   移动设备（UE）需要与基站（BS，如eNodeB for 4G, gNB for 5G）关联。
    *   UE需要向网络认证自己，网络也需要向UE认证自己。
    *   认证过程通常涉及UE中的**SIM卡 (Subscriber Identity Module)** 或 USIM/ISIM，它存储了用户的身份信息和与运营商共享的密钥。
*   **关键网元**:
    *   **UE (User Equipment)**: 移动设备。
    *   **BS (Base Station)**: 基站。
    *   **MME (Mobility Management Entity)** (4G) / **AMF (Access and Mobility Management Function)** (5G): 核心网中负责移动性管理和认证流程协调的网元。
    *   **HSS (Home Subscriber Server)** (4G) / **AUSF (Authentication Server Function) + UDM (Unified Data Management)** (5G): 存储用户签约数据和主密钥，是认证的最终权威。
(见幻灯片 8-92, 8-93)

*   **4G LTE认证和密钥协商 (AKA - Authentication and Key Agreement) 过程 (简化)**:
    (见幻灯片 8-94 至 8-98)
    1.  **认证请求**: UE向网络发起附着请求，MME从UE获取IMSI (国际移动用户识别码)，并向HSS请求认证向量。
    2.  **认证向量生成与分发**: HSS使用与UE SIM卡共享的长期主密钥 $K$ (以及序列号SQN) 生成一组认证向量，包括：
        *   随机质询 RAND
        *   预期响应 XRES
        *   加密密钥 CK
        *   完整性密钥 IK
        *   认证令牌 AUTN (包含MAC和SQN，用于UE认证网络)
        HSS将这些向量发送给MME。MME存储XRES, CK, IK，并将RAND和AUTN发送给UE (通过BS)。
    3.  **UE侧处理**:
        *   UE的SIM卡使用其存储的 $K$ 和收到的RAND、AUTN来：
            *   验证AUTN，从而认证网络。如果AUTN无效，UE拒绝连接。
            *   计算响应 RES。
            *   计算加密密钥 CK' 和完整性密钥 IK'。
        *   UE将RES发送给MME。
    4.  **网络侧验证UE**: MME比较收到的RES和之前存储的XRES。如果匹配，则UE认证成功。
    5.  **密钥派生与使用**: CK和IK (或由它们派生的密钥) 被用于保护UE和BS之间的无线接口上的信令（RRC完整性保护、加密）和数据（PDCP加密、完整性保护）的机密性和完整性。
    ![](https://i.imgur.com/M2k6qV3.png)
    *图：4G LTE 认证和密钥协商流程 (概念性)*

*   **4G与5G安全的主要区别/改进**: (见幻灯片 8-99)
    *   **认证决策权**: 4G中MME（位于拜访网络）做出部分认证决策；5G中核心认证决策权更集中在归属网络的AUSF。
    *   **密钥共享**: 4G依赖预共享的主密钥；5G对物联网(IoT)等场景考虑了不预共享密钥的方案。
    *   **用户永久标识符 (IMSI/SUPI) 保护**: 4G中IMSI可能在初始附着时以明文发送；5G强制要求使用公钥加密（SUCI - Subscription Concealed Identifier）来保护SUPI的传输，防止IMSI Catcher攻击。
    *   更细粒度的安全上下文，增强了对不同网络切片和服务的安全支持。

---

### 8.8 运行安全：防火墙与入侵检测系统 🧱👀

运行安全关注于保护网络基础设施和运行中的服务。

#### 8.8.1 防火墙 (Firewalls)

防火墙是一个位于组织内部网络（“可信网络”）和外部互联网（“不可信网络”）之间的设备或软件，用于控制进出内部网络的流量，允许授权流量通过，阻止未经授权或恶意的流量。

*   **目的**:
    *   防止外部攻击者对内部网络的非法访问和修改。
    *   防止内部用户对外部网络进行不当访问。
    *   防止拒绝服务攻击 (如SYN洪泛)。
    *   执行组织的安全策略。

*   **防火墙类型**:
    1.  **无状态包过滤防火墙 (Stateless Packet Filters)**:
        *   逐个检查每个数据包的头部信息（如源/目IP地址、源/目端口号、协议类型、TCP标志位如SYN/ACK），根据预设的**访问控制列表 (ACL - Access Control List)** 规则来决定是转发还是丢弃该数据包。
        *   ACL规则通常按顺序匹配，第一条匹配的规则生效。
        *   **优点**: 简单，处理速度快。
        *   **缺点**: 不考虑连接状态。例如，它可能会允许一个设置了ACK位的TCP包进入内部网络，即使内部并没有建立相应的TCP连接，这可能被用于某些扫描或攻击。
        *   **ACL示例**:

| 动作    | 源地址 | 目的地址       | 协议  | 源端口 | 目的端口    | TCP标志 | 描述                    |
| ----- | --- | ---------- | --- | --- | ------- | ----- | --------------------- |
| allow | any | 1.2.3.4/32 | TCP | any | 80      | SYN   | 允许外部访问内部Web服务器 (端口80) |
| deny  | any | any        | UDP | any | 137-139 |       | 阻止NetBIOS流量           |
| deny  | any | any        | any | any | any     |       | 默认拒绝所有其他流量 (如果放在最后)   |
    2.  **有状态包过滤防火墙 (Stateful Packet Filters)**: (见幻灯片 8-107, 8-108)
        *   不仅检查包头信息，还**跟踪活动TCP连接的状态**（如连接建立、数据传输、连接终止）。
        *   它维护一个连接状态表。只有当一个入站包与某个已建立的、合法的连接相关联时，才允许通过。
        *   例如，如果内部主机向外部Web服务器发起了TCP连接（SYN发出，收到SYN/ACK），防火墙会记录此连接。之后，来自该Web服务器的、属于此连接的TCP包（如ACK、数据包）才会被允许进入。
        *   **优点**: 比无状态防火墙更安全，能阻止更多类型的攻击。
        *   **缺点**: 需要更多内存和处理能力来维护连接状态表。
    3.  **应用网关 (Application Gateways / Proxies)**:
        *   工作在应用层，能理解特定应用协议（如HTTP, FTP, SMTP）的内容。
        *   所有进出网络的特定应用流量都必须经过应用网关。
        *   网关可以对应用层数据进行深度检查，例如过滤恶意内容、执行用户认证、记录详细日志等。
        *   例如，一个HTTP代理：内部用户配置浏览器通过代理访问外部网站。代理代表用户向外部网站发出请求，并将响应返回给用户。
        *   **优点**: 提供最高级别的安全控制。
        *   **缺点**: 需要为每个应用配置专门的网关，可能成为性能瓶颈，对新应用或加密应用支持可能滞后。

*   **防火墙的局限性**:
    *   无法防御内部攻击（例如来自心怀不满的员工）。
    *   如果配置不当，可能形同虚设或阻碍正常业务。
    *   无法阻止通过“隧道”或加密方式绕过防火墙的恶意流量（除非有解密和检查能力）。
    *   对IP欺骗的防御能力有限（尽管有状态防火墙和反欺骗技术可以缓解）。
    *   安全性和易用性/连通性之间需要权衡。

#### 8.8.2 入侵检测系统 (Intrusion Detection Systems, IDS)

IDS用于监视网络或系统中的活动，分析这些活动以发现潜在的恶意行为或安全策略违规，并产生告警。

*   **与防火墙的区别**: 防火墙主要在于“阻止”，IDS主要在于“检测和告警”。
    *   **IDS可以部署在防火墙之后**，检测那些成功绕过防火墙的攻击。
    *   **入侵防御系统 (Intrusion Prevention System, IPS)**: 是IDS的演进，不仅能检测，还能主动采取措施阻止检测到的攻击（例如，断开连接，修改防火墙规则）。

*   **IDS检测方法**:
    1.  **基于签名的检测 (Signature-based Detection)**:
        *   维护一个已知攻击模式（签名）的数据库。
        *   将捕获到的网络流量或系统日志与签名库进行匹配。
        *   如果匹配成功，则认为发生了攻击。
        *   **优点**: 准确性高，误报率低（对于已知攻击）。
        *   **缺点**: 无法检测新的、未知的攻击（0-day攻击）。需要定期更新签名库。
    2.  **基于异常的检测 (Anomaly-based Detection)**:
        *   首先学习网络或系统的“正常”行为模式（基线）。
        *   然后监视当前活动，如果发现与正常基线显著偏离，则认为是异常，可能是攻击。
        *   **优点**: 有可能检测到未知攻击。
        *   **缺点**: 误报率可能较高（正常行为的突变也可能被误报为异常），建立准确的基线比较困难。

*   **IDS功能**:
    *   **深度包检测 (Deep Packet Inspection, DPI)**: 检查数据包的载荷内容，而不仅仅是头部。例如，查找已知的病毒特征码、攻击字符串。
    *   **关联分析**: 分析多个数据包或事件之间的关联，以识别更复杂的攻击模式，如：
        *   端口扫描 (Port scanning)
        *   网络映射 (Network mapping)
        *   分布式拒绝服务攻击 (DDoS)
*   **IDS部署位置**: (见幻灯片 8-112)
    *   可以在网络的不同位置部署多个IDS传感器，例如：
        *   互联网接入点 (边界)。
        *   DMZ (Demilitarized Zone, 隔离区，用于放置对外提供服务的服务器如Web服务器)。
        *   内部网络关键网段。
        *   主机上 (HIDS - Host-based IDS)。
    ![](https://i.imgur.com/hB4Xv5J.png)
    *图：IDS传感器部署示例*

---

### 8.9 网络安全总结 回顾与展望 🌟

本章我们学习了网络安全的许多方面：

*   **基本安全目标**: 机密性、完整性、身份认证、可用性。
*   **核心技术 - 密码学**:
    *   对称密钥加密 (DES, AES) - 速度快，用于数据加密。
    *   公钥密码加密 (RSA) - 解决了密钥分发问题，用于密钥交换和数字签名。
    *   哈希函数 (MD5, SHA) - 用于生成报文摘要，保证完整性。
    *   数字签名 - 提供身份认证、完整性和不可否认性。
    *   数字证书和CA - 解决公钥信任问题。
*   **安全协议的应用**:
    *   **安全电子邮件**: PGP, S/MIME的思想。
    *   **安全传输层**: SSL/TLS (HTTPS)。
    *   **安全网络层**: IPsec (VPN)。
    *   **无线与移动安全**: WEP, WPA/WPA2/WPA3, 4G/5G安全机制。
*   **运行安全**:
    *   **防火墙**: 包过滤 (无状态、有状态)，应用网关。
    *   **入侵检测/防御系统 (IDS/IPS)**: 基于签名、基于异常的检测。

网络安全是一个持续对抗和不断发展的领域。新的威胁和漏洞不断出现，安全技术和策略也必须随之进步。作为网络用户和未来的网络专业人士，理解这些基本原理对于构建和维护一个更安全的数字世界至关重要。

---

希望这份笔记能帮助你更好地理解网络安全的核心概念！👍